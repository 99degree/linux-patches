diff --git a/.clang-format b/.clang-format
index 1247d54f9e49..74c71a7ed5f0 100644
--- a/.clang-format
+++ b/.clang-format
@@ -52,7 +52,7 @@ BreakConstructorInitializersBeforeComma: false
 BreakConstructorInitializers: BeforeComma
 BreakAfterJavaFieldAnnotations: false
 BreakStringLiterals: false
-ColumnLimit: 80
+ColumnLimit: 79
 CommentPragmas: '^ IWYU pragma:'
 CompactNamespaces: false
 ConstructorInitializerAllOnOneLineOrOnePerLine: false
diff --git a/Documentation/devicetree/bindings/display/panel/panel-simple-dsi.yaml b/Documentation/devicetree/bindings/display/panel/panel-simple-dsi.yaml
index 2c00813f5d20..5d647050876b 100644
--- a/Documentation/devicetree/bindings/display/panel/panel-simple-dsi.yaml
+++ b/Documentation/devicetree/bindings/display/panel/panel-simple-dsi.yaml
@@ -57,6 +57,10 @@ properties:
       - samsung,sofef00
         # Shangai Top Display Optoelectronics 7" TL070WSH30 1024x600 TFT LCD panel
       - tdo,tl070wsh30
+        # Sony Kirin nt36672a Truly FHD+ IPS LCD panel
+      - sony,kirin-nt36672a-truly
+        # Sony mermaid nt36672a Tianma FHD+ IPS LCD panel
+      - sony,mermaid-nt36672a-tianma
 
   reg:
     maxItems: 1
diff --git a/Documentation/devicetree/bindings/vendor-prefixes.yaml b/Documentation/devicetree/bindings/vendor-prefixes.yaml
index 9bf7c2cd7e89..5836f214205e 100644
--- a/Documentation/devicetree/bindings/vendor-prefixes.yaml
+++ b/Documentation/devicetree/bindings/vendor-prefixes.yaml
@@ -891,6 +891,8 @@ patternProperties:
     description: Nokia
   "^nordic,.*":
     description: Nordic Semiconductor
+  "^novatek,.*":
+    description: Novatek Microelectronics Corp.
   "^novtech,.*":
     description: NovTech, Inc.
   "^nutsboard,.*":
diff --git a/Makefile b/Makefile
index f659d3085121..16c754f8ebf7 100644
--- a/Makefile
+++ b/Makefile
@@ -11,6 +11,10 @@ NAME = Hurr durr I'ma ninja sloth
 # Comments in this file are targeted only to the developer, do not
 # expect to learn how to build the kernel reading this file.
 
+ARCH = arm64
+CROSS_COMPILE = aarch64-linux-gnu-
+CROSS_COMPILE_ARM32 = arm-none-eabi-
+
 $(if $(filter __%, $(MAKECMDGOALS)), \
 	$(error targets prefixed with '__' are only for internal use))
 
@@ -492,7 +496,7 @@ OBJDUMP		= $(LLVM_PREFIX)llvm-objdump$(LLVM_SUFFIX)
 READELF		= $(LLVM_PREFIX)llvm-readelf$(LLVM_SUFFIX)
 STRIP		= $(LLVM_PREFIX)llvm-strip$(LLVM_SUFFIX)
 else
-CC		= $(CROSS_COMPILE)gcc
+CC		= $(CROSS_COMPILE)gcc-10
 LD		= $(CROSS_COMPILE)ld
 AR		= $(CROSS_COMPILE)ar
 NM		= $(CROSS_COMPILE)nm
diff --git a/arch/arm/boot/dts/qcom-pm8941.dtsi b/arch/arm/boot/dts/qcom-pm8941.dtsi
index 59d0cde63251..19412cf31823 100644
--- a/arch/arm/boot/dts/qcom-pm8941.dtsi
+++ b/arch/arm/boot/dts/qcom-pm8941.dtsi
@@ -154,10 +154,9 @@ pm8941_lpg: lpg {
 			status = "disabled";
 		};
 
-		pm8941_wled: wled@d800 {
+		pm8941_wled: backlight@d800 {
 			compatible = "qcom,pm8941-wled";
 			reg = <0xd800>;
-			label = "backlight";
 
 			status = "disabled";
 		};
diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
index 1d86a33de528..c72e8e38e688 100644
--- a/arch/arm64/boot/dts/qcom/Makefile
+++ b/arch/arm64/boot/dts/qcom/Makefile
@@ -135,6 +135,7 @@ dtb-$(CONFIG_ARCH_QCOM)	+= sdm850-lenovo-yoga-c630.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sdm850-samsung-w737.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm6125-sony-xperia-seine-pdx201.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm6350-sony-xperia-lena-pdx213.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-idp.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm7225-fairphone-fp4.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8150-hdk.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sm8150-microsoft-surface-duo.dtb
diff --git a/arch/arm64/boot/dts/qcom/pm6150l.dtsi b/arch/arm64/boot/dts/qcom/pm6150l.dtsi
index 7aa2ef90cb6a..217f75aa7f67 100644
--- a/arch/arm64/boot/dts/qcom/pm6150l.dtsi
+++ b/arch/arm64/boot/dts/qcom/pm6150l.dtsi
@@ -53,12 +53,11 @@ pm6150l_lsid5: pmic@5 {
 		#address-cells = <1>;
 		#size-cells = <0>;
 
-		pm6150l_wled: leds@d800 {
+		pm6150l_wled: backlight@d800 {
 			compatible = "qcom,pm6150l-wled";
 			reg = <0xd800>, <0xd900>;
 			interrupts = <0x5 0xd8 0x1 IRQ_TYPE_EDGE_RISING>;
 			interrupt-names = "ovp";
-			label = "backlight";
 
 			status = "disabled";
 		};
diff --git a/arch/arm64/boot/dts/qcom/pm660l.dtsi b/arch/arm64/boot/dts/qcom/pm660l.dtsi
index c7945470ffee..3c70fc4ee6b2 100644
--- a/arch/arm64/boot/dts/qcom/pm660l.dtsi
+++ b/arch/arm64/boot/dts/qcom/pm660l.dtsi
@@ -30,6 +30,36 @@ pm660l_crit: pm660l-crit {
 				};
 			};
 		};
+
+		pm660l_pon2: pon@800 {
+			compatible = "qcom,pm8998-pon";
+			reg = <0x800>;
+			mode-bootloader = <0x2>;
+			mode-recovery = <0x1>;
+
+			pwrkey {
+				compatible = "qcom,pm8941-pwrkey";
+				interrupts = <0x0 0x8 0 IRQ_TYPE_EDGE_BOTH>;
+				debounce = <15625>;
+				bias-pull-up;
+				linux,code = <KEY_POWER>;
+			};
+		};
+
+		pm660l_pon2: pon@800 {
+			compatible = "qcom,pm8998-pon";
+			reg = <0x800>;
+			mode-bootloader = <0x2>;
+			mode-recovery = <0x1>;
+
+			pwrkey {
+				compatible = "qcom,pm8941-pwrkey";
+				interrupts = <0x0 0x8 0 IRQ_TYPE_EDGE_BOTH>;
+				debounce = <15625>;
+				bias-pull-up;
+				linux,code = <KEY_POWER>;
+			};
+		};
 	};
 };
 
@@ -57,6 +87,22 @@ pm660l_gpios: gpios@c000 {
 			interrupt-controller;
 			#interrupt-cells = <2>;
 		};
+
+                pon2: pon@800 {
+                        compatible = "qcom,pm8998-pon";
+                        reg = <0x800>;
+                        mode-bootloader = <0x2>;
+                        mode-recovery = <0x1>;
+
+                        pwrkey {
+                                compatible = "qcom,pm8941-pwrkey";
+                                interrupts = <0x0 0x8 0 IRQ_TYPE_EDGE_BOTH>;
+                                debounce = <15625>;
+                                bias-pull-up;
+                                linux,code = <KEY_POWER>;
+                        };
+
+                };
 	};
 
 	pmic@3 {
diff --git a/arch/arm64/boot/dts/qcom/pmi8994.dtsi b/arch/arm64/boot/dts/qcom/pmi8994.dtsi
index 84c44912ec93..4e28ac420c24 100644
--- a/arch/arm64/boot/dts/qcom/pmi8994.dtsi
+++ b/arch/arm64/boot/dts/qcom/pmi8994.dtsi
@@ -53,7 +53,7 @@ pmi8994_spmi_regulators: regulators {
 			#size-cells = <1>;
 		};
 
-		pmi8994_wled: wled@d800 {
+		pmi8994_wled: backlight@d800 {
 			compatible = "qcom,pmi8994-wled";
 			reg = <0xd800>, <0xd900>;
 			interrupts = <3 0xd8 0x02 IRQ_TYPE_EDGE_RISING>;
diff --git a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-ganges-kirin.dts b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-ganges-kirin.dts
index 71b448978e88..74af2102a963 100644
--- a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-ganges-kirin.dts
+++ b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-ganges-kirin.dts
@@ -23,4 +23,9 @@ framebuffer@9d400000 {
 
 /* Ganges devices feature a Novatek touchscreen instead. */
 /delete-node/ &touchscreen;
+#if 0
+&panel {
+	compatible = "sony,kirin-nt36672a-truly";
+};
+#endif
 /delete-node/ &vreg_l18a_1v8;
diff --git a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-discovery.dts b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-discovery.dts
index dd484a9bc7cd..cc2983d8d11d 100644
--- a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-discovery.dts
+++ b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-discovery.dts
@@ -13,3 +13,8 @@ / {
 	compatible = "sony,discovery-row", "qcom,sdm630";
 	chassis-type = "handset";
 };
+#if 0
+&panel {
+	compatible = "sony,discovery-td4322-innolux";
+};
+#endif
diff --git a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-pioneer.dts b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-pioneer.dts
index 2da83cd41187..444eb1e6dd10 100644
--- a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-pioneer.dts
+++ b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-pioneer.dts
@@ -13,3 +13,8 @@ / {
 	compatible = "sony,pioneer-row", "qcom,sdm630";
 	chassis-type = "handset";
 };
+#if 0
+&panel {
+	compatible = "sony,pioneer-td4322-truly";
+};
+#endif
diff --git a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-voyager.dts b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-voyager.dts
index a679d4acee29..7f05744c9886 100644
--- a/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-voyager.dts
+++ b/arch/arm64/boot/dts/qcom/sdm630-sony-xperia-nile-voyager.dts
@@ -20,3 +20,8 @@ framebuffer@9d400000 {
 		};
 	};
 };
+#if 0
+&panel {
+	compatible = "sony,voyager-td4328-tianma";
+};
+#endif
diff --git a/arch/arm64/boot/dts/qcom/sdm636-asus-x00td.dts b/arch/arm64/boot/dts/qcom/sdm636-asus-x00td.dts
new file mode 100644
index 000000000000..0430748a277b
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sdm636-asus-x00td.dts
@@ -0,0 +1,783 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2022, Aboothahir U <aboothahirpkd@gmail.com>
+ */
+
+/dts-v1/;
+
+#include "sdm636.dtsi"
+#include "pm660.dtsi"
+#include "pm660l.dtsi"
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/input/gpio-keys.h>
+
+/delete-node/ &qhee_code;
+/delete-node/ &smem_region;
+/delete-node/ &tz_mem;
+/delete-node/ &mpss_region;
+/delete-node/ &mba_region;
+/delete-node/ &adsp_region;
+/delete-node/ &buffer_mem;
+/delete-node/ &zap_shader_region;
+
+/ {
+	model = "Asus Zenfone Max Pro M1";
+	compatible = "asus,x00td", "qcom,sdm660", "qcom,sdm636";
+	chassis-type = "handset";
+/*
+	qcom,msm-id = <0x159 0x0>;
+	qcom,board-id = <0x1000b 0x0>;
+	qcom,pmic-id = <0x1001b 0x101011a 0x0 0x0 0x1001b 0x201011a 0x0 0x0 0x1001b 0x102001a 0x0 0x0>;
+*/
+	// override with meizu
+        qcom,msm-id = <0x159 0x0>;
+        qcom,board-id = <0x8 0x0>;
+        qcom,pmic-id = <0x1001b 0x101011a 0x0 0x0 0x1001b 0x201011a 0x0 0x0>;
+
+	chosen {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		stdout-path = "framebuffer0";
+
+		framebuffer0: framebuffer@9d400000 {
+			compatible = "drm-simple-framebuffer", "simple-framebuffer";
+			reg = <0x0 0x9d400000 0x0 (1080 * 2160 * 4)>;
+			status = "okay";
+			width = <1080>;
+			height = <2160>;
+			stride = <(1080 * 4)>;
+			format = "a8r8g8b8";
+		};
+	};
+
+	gpio-keys {
+		status = "okay";
+		compatible = "gpio-keys";
+
+		vol_up {
+			label = "Volume Up";
+			gpios = <&tlmm 44 GPIO_ACTIVE_LOW>;
+			linux,input-type = <1>;
+			linux,code = <KEY_VOLUMEUP>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+
+		vol_down {
+			label = "Volume Down";
+			gpios = <&tlmm 43 GPIO_ACTIVE_LOW>;
+			linux,input-type = <1>;
+			linux,code = <KEY_VOLUMEDOWN>;
+			gpio-key,wakeup;
+			debounce-interval = <15>;
+		};
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		wlan_msa_guard: wlan-msa-guard@85600000 {
+			reg = <0x0 0x85600000 0x0 0x100000>;
+			no-map;
+		};
+
+		wlan_msa_mem: wlan-msa-mem@85700000 {
+			reg = <0x0 0x85700000 0x0 0x100000>;
+			no-map;
+		};
+
+		/* removed_regions in downstream / qhee_code */
+		removed_region: removed_region@85800000 {
+			reg = <0x0 0x85800000 0x0 0x600000>;
+			no-map;
+		};
+
+		smem_region: smem_memory@86000000 {
+			reg = <0x0 0x86000000 0x0 0x200000>;
+			no-map;
+		};
+
+		/* tz_mem */
+		tz_mem: tz_memory@86200000 {
+			reg = <0x0 0x86200000 0x0 0x2D00000>;
+			/* 0x86200000 + 0x2D00000 = 0x88F00000 */
+			no-map;
+		};
+
+		/* downstream has this: */
+		/* removed_regions@85800000 {
+			reg = <0x0 0x85800000 0x0 0x3700000>;
+			no-map;
+		}; */
+		/* which covers region starting from removed_regions to 0x88F00000 (end of our tz_mem) */
+
+		/* modem_fw_region */
+		modem_fw_mem: modem_fw_region@8ac00000 {
+			reg = <0x0 0x8ac00000 0x0 0x7e00000>;
+			no-map;
+		};
+
+		/* adsp_fw_region */
+		adsp_region: adsp@92a00000 {
+			reg = <0x0 0x92a00000 0x0 0x1e00000>;
+			no-map;
+		};
+
+		/* pil_mba_mem */
+		pil_mba_mem: mba@94800000 {
+			reg = <0x0 0x94800000 0x0 0x200000>;
+			no-map;
+		};
+
+		/* cdsp_fw_region */
+		buffer_mem: buffer_region@94a00000 {
+			reg = <0x0 0x94a00000 0x0 0x600000>;
+			no-map;
+		};
+
+		/* cont_splash_region / framebuffer */
+		cont_splash: splash_region@9d400000 {
+			reg = <0x0 0x9d400000 0x0 0x2400000>;
+			no-map;
+		};
+
+		zap_shader_region: gpu@fa800000 {
+                        compatible = "shared-dma-pool";
+                        reg = <0x0 0xfa800000 0x0 0x2000>;
+                        no-map;
+		};
+
+		ramoops@a0000000 {
+			compatible = "ramoops";
+			reg = <0x0 0xa0000000 0x0 0x400000>;
+			console-size = <0x20000>;
+			record-size = <0x20000>;
+			ftrace-size = <0x0>;
+			pmsg-size = <0x20000>;
+		};
+	};
+	
+	/*
+	 * Until we hook up type-c detection, we
+	 * have to stick with this. But it works.
+	 */
+	extcon_usb: extcon-usb {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpio = <&tlmm 58 GPIO_ACTIVE_HIGH>;
+	};
+
+	vph_pwr: vph-pwr-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vph_pwr";
+		regulator-min-microvolt = <3700000>;
+		regulator-max-microvolt = <3700000>;
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	/* Add support of modem and Wi-Fi */
+	soc {
+		/*
+		 * We don't know origin of remoteproc
+		 * description now, it was provided on Github
+		 * by konradybcio/58ninges_labs
+		 */
+		remoteproc_mss: remoteproc@4080000 {
+			compatible = "qcom,msm8998-mss-pil";
+			reg = <0x04080000 0x100>, <0x04180000 0x40>;
+			reg-names = "qdsp6", "rmb";
+			status = "okay";
+
+			interrupts-extended =
+				<&intc GIC_SPI 448 IRQ_TYPE_EDGE_RISING>,
+				<&modem_smp2p_in 0 IRQ_TYPE_EDGE_RISING>,
+				<&modem_smp2p_in 1 IRQ_TYPE_EDGE_RISING>,
+				<&modem_smp2p_in 2 IRQ_TYPE_EDGE_RISING>,
+				<&modem_smp2p_in 3 IRQ_TYPE_EDGE_RISING>,
+				<&modem_smp2p_in 7 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "wdog", "fatal", "ready",
+					  "handover", "stop-ack",
+					  "shutdown-ack";
+
+			clocks = <&gcc GCC_MSS_CFG_AHB_CLK>,
+				 <&gcc GCC_BIMC_MSS_Q6_AXI_CLK>,
+				 <&gcc GCC_BOOT_ROM_AHB_CLK>,
+				 <&gcc GPLL0_OUT_MSSCC>,
+				 <&gcc GCC_MSS_SNOC_AXI_CLK>,
+				 <&gcc GCC_MSS_MNOC_BIMC_AXI_CLK>,
+				 <&rpmcc RPM_SMD_QDSS_CLK>,
+				 <&rpmcc RPM_SMD_XO_CLK_SRC>;
+			clock-names = "iface", "bus", "mem", "gpll0_mss",
+				      "snoc_axi", "mnoc_axi", "qdss", "xo";
+
+			qcom,smem-states = <&modem_smp2p_out 0>;
+			qcom,smem-state-names = "stop";
+
+			resets = <&gcc GCC_MSS_RESTART>;
+			reset-names = "mss_restart";
+
+			qcom,halt-regs = <&tcsr_mutex_regs 0x23000 0x25000 0x24000>;
+
+			power-domains = <&rpmpd SDM660_VDDCX>,
+					<&rpmpd SDM660_VDDMX>;
+			power-domain-names = "cx", "mx";
+
+			/* firmware from device */
+			firmware-name = "mba.mbn", "modem.mdt";
+
+			/* modem regions */
+			mba {
+				memory-region = <&pil_mba_mem>;
+			};
+
+			mpss {
+				memory-region = <&modem_fw_mem>;
+			};
+
+			glink-edge {
+				interrupts = <GIC_SPI 452 IRQ_TYPE_EDGE_RISING>;
+				label = "modem";
+				qcom,remote-pid = <1>;
+				mboxes = <&apcs_glb 15>;
+			};
+		};
+
+		wifi: wifi@18800000 {
+			/*
+			 * Generated from ICNSS - they have same
+			 * membase, clocks, iommus and interrupts
+			 * However, SMMU not working now :(
+			 */
+			compatible = "qcom,wcn3990-wifi"; /* common for all QCOMs */
+			reg = <0x18800000 0x800000>;
+			reg-names = "membase";
+			memory-region = <&wlan_msa_mem>;
+			clocks = <&rpmcc RPM_SMD_RF_CLK1_PIN>;
+			clock-names = "cxo_ref_clk_pin";
+			interrupts =
+				<GIC_SPI 413 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 414 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 415 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 416 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 417 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 418 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 420 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 421 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 422 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 423 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 424 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 425 IRQ_TYPE_LEVEL_HIGH>;
+
+			iommus = <&anoc2_smmu 0x1a00>,
+				 <&anoc2_smmu 0x1a01>;
+			qcom,snoc-host-cap-8bit-quirk; /* unknown property */
+			status = "okay";
+
+			/* supplies are same with downstream */
+			vdd-1.8-xo-supply = <&vreg_l9a_1p8>;
+			vdd-1.3-rfa-supply = <&vreg_l6a_1p3>;
+			vdd-3.3-ch0-supply = <&vreg_l19a_3p3>;
+		};
+	};
+};
+
+/ {
+	soc {
+		firmware {
+				android {
+					compatible = "android,firmware";
+					fstab {
+							compatible = "android,fstab";
+							vendor {
+									compatible = "android,vendor";
+									dev = "/dev/block/platform/soc/c0c4000.sdhci/by-name/vendor";
+									type = "ext4";
+									mnt_flags = "ro,barrier=1,discard";
+									fsmgr_flags = "wait";
+									status = "ok";
+							};
+							system {
+									compatible = "android,system";
+									dev = "/dev/block/platform/soc/c0c4000.sdhci/by-name/system";
+									type = "ext4";
+									mnt_flags = "ro,barrier=1,discard";
+									fsmgr_flags = "wait";
+									status = "ok";
+							};
+					};
+				};
+		};
+	};
+};
+
+&blsp2_uart1 {
+	status = "okay";
+	/* HCI Bluetooth */
+	bluetooth {
+		compatible = "qcom,wcn3990-bt"; // common for all QCOM
+		vddxo-supply = <&vreg_l9a_1p8>; // downstream: vdd-core-supply
+		vddrf-supply = <&vreg_l6a_1p3>; // vdd-pa-supply
+		vddch0-supply = <&vreg_l19a_3p3>; // vdd-ldo-supply
+		max-speed = <3200000>;
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&pon_pwrkey {
+	status = "okay";
+};
+
+&pon_resin {
+        status = "okay";
+
+        linux,code = <KEY_VOLUMEUP>;
+};
+
+&rpm_requests {
+	pm660-regulators {
+		compatible = "qcom,rpm-pm660-regulators";
+
+		vdd_s4-supply = <&vph_pwr>;
+		vdd_s5-supply = <&vph_pwr>;
+		vdd_s6-supply = <&vph_pwr>;
+
+		vdd_l1_l6_l7-supply = <&vreg_s5a_1p35>;
+		vdd_l2_l3-supply = <&vreg_s2b_1p05>;
+		vdd_l5-supply = <&vreg_s2b_1p05>;
+		vdd_l8_l9_l10_l11_l12_l13_l14-supply = <&vreg_s4a_2p04>;
+		vdd_l15_l16_l17_l18_l19-supply = <&vreg_bob>;
+
+		/*
+		 * S1A (FTAPC0), S2A (FTAPC1), S3A (HFAPC1) are managed
+		 * by the Core Power Reduction hardened (CPRh) and the
+		 * Operating State Manager (OSM) HW automatically.
+		 */
+
+		vreg_s4a_2p04: s4 {
+			regulator-min-microvolt = <1805000>;
+			regulator-max-microvolt = <2040000>;
+			regulator-enable-ramp-delay = <200>;
+			regulator-always-on;
+		};
+
+		vreg_s5a_1p35: s5 {
+			regulator-min-microvolt = <1224000>;
+			regulator-max-microvolt = <1350000>;
+			regulator-enable-ramp-delay = <200>;
+		};
+
+		vreg_s6a_0p87: s6 {
+			regulator-min-microvolt = <504000>;
+			regulator-max-microvolt = <992000>;
+			regulator-enable-ramp-delay = <150>;
+		};
+
+		/* LDOs */
+		vreg_l1a_1p225: l1 {
+			regulator-min-microvolt = <1150000>;
+			regulator-max-microvolt = <1250000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l2a_1p0: l2 {
+			regulator-min-microvolt = <950000>;
+			regulator-max-microvolt = <1010000>;
+			regulator-enable-ramp-delay = <250>;
+		};
+
+		vreg_l3a_1p0: l3 {
+			regulator-min-microvolt = <950000>;
+			regulator-max-microvolt = <1010000>;
+			regulator-enable-ramp-delay = <250>;
+		};
+
+		vreg_l5a_0p848: l5 {
+			regulator-min-microvolt = <525000>;
+			regulator-max-microvolt = <950000>;
+			regulator-enable-ramp-delay = <250>;
+		};
+
+		vreg_l6a_1p3: l6 {
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1370000>;
+			regulator-allow-set-load;
+			regulator-enable-ramp-delay = <250>;
+		};
+
+		vreg_l7a_1p2: l7 {
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-enable-ramp-delay = <250>;
+		};
+
+		vreg_l8a_1p8: l8 {
+			regulator-min-microvolt = <1750000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-system-load = <325000>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l9a_1p8: l9 {
+			regulator-min-microvolt = <1750000>;
+			regulator-max-microvolt = <1900000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l10a_1p8: l10 {
+			regulator-min-microvolt = <1780000>;
+			regulator-max-microvolt = <1950000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l11a_1p8: l11 {
+			regulator-min-microvolt = <1780000>;
+			regulator-max-microvolt = <1950000>;
+			regulator-enable-ramp-delay = <250>;
+		};
+
+		vreg_l12a_1p8: l12 {
+			regulator-min-microvolt = <1780000>;
+			regulator-max-microvolt = <1950000>;
+			regulator-enable-ramp-delay = <250>;
+		};
+
+		/* This gives power to the LPDDR4: never turn it off! */
+		vreg_l13a_1p8: l13 {
+			regulator-min-microvolt = <1780000>;
+			regulator-max-microvolt = <1950000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+		vreg_l14a_1p8: l14 {
+			regulator-min-microvolt = <1710000>;
+			regulator-max-microvolt = <1900000>;
+			regulator-enable-ramp-delay = <250>;
+		};
+
+		vreg_l15a_1p8: l15 {
+			regulator-min-microvolt = <1650000>;
+			regulator-max-microvolt = <2950000>;
+			regulator-enable-ramp-delay = <250>;
+		};
+
+		vreg_l17a_1p8: l17 {
+			regulator-min-microvolt = <1648000>;
+			regulator-max-microvolt = <2952000>;
+			regulator-enable-ramp-delay = <250>;
+		};
+
+		vreg_l19a_3p3: l19 {
+			regulator-min-microvolt = <3312000>;
+			regulator-max-microvolt = <3400000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-allow-set-load;
+		};
+	};
+
+	pm660l-regulators {
+		compatible = "qcom,rpm-pm660l-regulators";
+
+		vdd_s1-supply = <&vph_pwr>;
+		vdd_s2-supply = <&vph_pwr>;
+		vdd_s3_s4-supply = <&vph_pwr>;
+		vdd_s5-supply = <&vph_pwr>;
+		vdd_s6-supply = <&vph_pwr>;
+
+		vdd_l1_l9_l10-supply = <&vreg_s2b_1p05>;
+		vdd_l2-supply = <&vreg_bob>;
+		vdd_l3_l5_l7_l8-supply = <&vreg_bob>;
+		vdd_l4_l6-supply = <&vreg_bob>;
+		vdd_bob-supply = <&vph_pwr>;
+
+		vreg_s1b_1p125: s1 {
+			regulator-min-microvolt = <1125000>;
+			regulator-max-microvolt = <1125000>;
+			regulator-enable-ramp-delay = <200>;
+		};
+
+		vreg_s2b_1p05: s2 {
+			regulator-min-microvolt = <1050000>;
+			regulator-max-microvolt = <1050000>;
+			regulator-enable-ramp-delay = <200>;
+		};
+
+		/* LDOs */
+		vreg_l1b_0p925: l1 {
+			regulator-min-microvolt = <800000>;
+			regulator-max-microvolt = <925000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-allow-set-load;
+		};
+
+		/* SDHCI 3.3V signal doesn't seem to be supported. */
+		vreg_l2b_2p95: l2 {
+			regulator-min-microvolt = <1648000>;
+			regulator-max-microvolt = <2696000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l3b_3p3: l3 {
+			regulator-min-microvolt = <1700000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l4b_2p95: l4 {
+			regulator-min-microvolt = <2944000>;
+			regulator-max-microvolt = <2952000>;
+			regulator-enable-ramp-delay = <250>;
+
+			regulator-min-microamp = <200>;
+			regulator-max-microamp = <600000>;
+			regulator-system-load = <570000>;
+			regulator-allow-set-load;
+		};
+
+		/*
+		 * Downstream specifies a range of 1721-3600mV,
+		 * but the only assigned consumers are SDHCI2 VMMC
+		 * and Coresight QPDI that both request pinned 2.95V.
+		 * Tighten the range to 1.8-3.328 (closest to 3.3) to
+		 * make the mmc driver happy.
+		 */
+		vreg_l5b_2p95: l5 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3328000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-allow-set-load;
+			regulator-system-load = <800000>;
+		};
+
+		vreg_l7b_3p125: l7 {
+			regulator-min-microvolt = <2700000>;
+			regulator-max-microvolt = <3125000>;
+			regulator-enable-ramp-delay = <250>;
+		};
+
+		vreg_l8b_3p3: l8 {
+			regulator-min-microvolt = <3200000>;
+			regulator-max-microvolt = <3400000>;
+			regulator-enable-ramp-delay = <250>;
+		};
+
+		vreg_bob: bob {
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3600000>;
+			regulator-enable-ramp-delay = <500>;
+		};
+	};
+};
+
+&sdhc_1 {
+	status = "okay";
+	bus-width = <8>;
+	non-removable;
+	mmc-ddr-1_8v;    
+	mmc-hs200-1_8v;  
+	mmc-hs400-1_8v; 
+	vmmc-supply = <&vreg_l4b_2p95>;
+	vqmmc-supply = <&vreg_l8a_1p8>;  
+};
+
+
+&sdhc_2 {
+	status = "okay";
+
+	vmmc-supply = <&vreg_l5b_2p95>;
+	vqmmc-supply = <&vreg_l2b_2p95>;
+};
+
+&tlmm {
+	gpio-reserved-ranges = <8 4>;
+	
+	panel_reset_gpio: panel-reset-gpio {
+		pins = "gpio53";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable = <0>;
+	};
+	
+	mdss_dsi_suspend: mdss-dsi-suspend {
+		pins = "gpio53";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	panel_te_gpio: panel-te-gpio {
+		pins = "gpio59";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+};
+
+&usb3 {
+	status = "okay";
+};
+
+&usb3_dwc3 {
+	status = "okay";
+	dr_mode = "peripheral";
+	extcon = <&extcon_usb>;
+};
+
+&qusb2phy {
+	status = "okay";
+
+	vdd-supply = <&vreg_l1b_0p925>;
+	vdda-pll-supply = <&vreg_l10a_1p8>;
+	vdda-phy-dpdm-supply = <&vreg_l7b_3p125>;
+};
+
+&blsp_i2c2 {
+	status = "okay";
+};
+
+&blsp_i2c4 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	touchscreen@62 {
+		compatible = "novatek,nt36525";
+		reg = <0x62>;
+		interrupt-parent = <&tlmm>;
+		interrupts = <67 IRQ_TYPE_EDGE_RISING>;
+		reset-gpios = <&tlmm 66 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&blsp_i2c6 {
+	status = "okay";
+
+	tfa98xx@34 {
+		compatible = "nxp,tfa98xx";
+		reg = <0x34>;
+	};
+};
+
+&blsp_i2c7 { /* for P/L Sensor */
+	status = "okay";
+};
+
+&dsi0 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	vdd-supply = <&vreg_l1b_0p925>;
+	vdda-supply = <&vreg_l1a_1p225>;
+	status = "okay";
+	panel@0 {
+		compatible = "mdss,s6d6ft0-tianma-fhd", "meizu,s6d6ft0-tianma-fhd";
+		reg = <0>;
+
+		backlight = <&pm660l_wled>;
+		reset-gpios = <&tlmm 53 GPIO_ACTIVE_HIGH>;
+		disp-te-gpios = <&tlmm 59 GPIO_ACTIVE_HIGH>;
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&panel_reset_gpio &panel_te_gpio>;
+		port {
+			panel_in: endpoint {
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+	};
+};
+
+&dsi0_out {
+	data-lanes = <0 1 2 3>;
+	remote-endpoint = <&panel_in>;
+};
+
+&dsi0_phy {
+	vcca-supply = <&vreg_l1b_0p925>;
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&pm660l_wled {
+        status = "okay";
+        default-brightness = <512>;
+};
+
+&dsi1_phy{
+	status = "disabled";
+};
+
+&dsi1{
+	status = "disabled";
+};
+
+&gcc {
+	status = "okay";
+};
+
+&gpucc {
+	status = "okay";
+};
+
+&mmcc {
+	status = "okay";
+};
+
+&mmss_smmu {
+        status = "okay";
+};
+
+&anoc2_smmu {
+        status = "okay";
+};
+
+&kgsl_smmu {
+        status = "okay";
+};
+
+&lpass_smmu {
+        status = "okay";
+};
+
+        /* firmware from device */
+
+
+&adreno_gpu {
+	status = "okay";
+	zap-shader {
+		memory-region = <&zap_shader_region>;
+		firmware-name = "qcom/a512_zap.mdt";
+	};
+	// These OPPs are correct, but we are lacking support for the
+	// GPU regulator. Hence, disable them for now to prevent the
+	// platform from hanging on high graphics loads
+	opp-table {
+		/delete-node/ opp-700000000;
+		/delete-node/ opp-266000000;
+	};
+};
+
+&adsp_pil {
+	status = "okay";
+	firmware-name = "adsp.mdt";
+};
+
+&venus {
+	status = "okay";
+	firmware-name = "qcom/venus-4.4/venus.mdt";
+};
diff --git a/arch/arm64/boot/dts/qcom/sdm636-meizu-E3.dts b/arch/arm64/boot/dts/qcom/sdm636-meizu-E3.dts
new file mode 100644
index 000000000000..60bd6e8018e8
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sdm636-meizu-E3.dts
@@ -0,0 +1,151 @@
+// SPDX-License-Identifier: BSD-3-Clause
+
+/dts-v1/;
+
+#include "sdm636.dtsi"
+#include "sdm630-sony-xperia-nile.dtsi"
+
+/ {
+	model = "Meizu E3";
+	compatible = "qcom,sdm636", "qcom,sdm630";
+	chassis-type = "handset";
+
+	qcom,msm-id = <0x159 0x0>;
+	qcom,board-id = <0x8 0x0>;
+	qcom,pmic-id = <0x1001b 0x101011a 0x0 0x0 0x1001b 0x201011a 0x0 0x0>;
+
+	chosen {
+		#address-cells = <2>;
+		#size-cells = <2>;
+                ranges;
+
+		stdout-path = "framebuffer0";
+		bootargs = "earlycon=tty0 console=tty0";
+
+		framebuffer0: framebuffer@9d400000 {
+			compatible = "drm-simple-framebuffer", "simple-framebuffer";
+			reg = <0x0 0x9d400000 0x0 (1080 * 2160 * 4)>;
+			status = "okay";
+			width = <1080>;
+			height = <2160>;
+			stride = <(1080 * 4)>;
+			format = "a8r8g8b8";
+		};
+        };
+
+	reserved-memory {
+
+		/* cont_splash_region / framebuffer */
+		cont_splash: splash_region@9d400000 {
+			reg = <0x0 0x9d400000 0x0 0x2400000>;
+			no-map;
+		};
+	};
+};
+
+&usb3 {
+	status = "okay";
+};
+
+&usb3_dwc3 {
+	status = "okay";
+};
+
+&usb2 {
+        status = "disabled";
+};
+
+&usb2_dwc3 {
+        status = "disabled";
+};
+
+&sdc2_state_on {
+	pinconf-clk {
+		drive-strength = <14>;
+	};
+};
+
+&anoc2_smmu {
+	qcom,secured-cbs = /bits/ 8 <7 8 9 10 11 12 13 14 15 16 17 18 19 20>;
+	status = "okay";
+};
+
+&kgsl_smmu {
+	qcom,secured-cbs = /bits/ 8 <2 3 4>;
+	status = "okay";
+};
+
+&lpass_smmu {
+	qcom,secured-cbs = /bits/ 8 <13>;
+	status = "okay";
+};
+
+&mmss_smmu {
+	qcom,secured-cbs = /bits/ 8 <14 15 16>;
+	status = "okay";
+};
+
+&panel {
+        compatible = "mdss,s6d6ft0-tianma-fhd", "meizu,s6d6ft0-tianma-fhd", "meizu,s6d6ft0-tianma", "sony,mermaid-nt36672a-tianma";
+};
+
+&adreno_gpu {
+	//status = "disabled";
+	status = "okay";
+};
+
+&mdss {
+	//status = "disabled";
+	status = "okay";
+};
+
+&tlmm {
+                        ts_active: ts_active {
+                                        pins = "gpio66", "gpio67";
+                                        function = "gpio";
+                                        drive-strength = <16>;
+                                        bias-pull-up;
+                        };
+
+                        ts_reset_suspend: ts_reset_suspend {
+                                        pins = "gpio66";
+                                        function = "gpio";
+                                        drive-strength = <2>;
+                                        bias-pull-down;
+                        };
+
+                        ts_int_suspend: ts_int_suspend {
+                                        pins = "gpio67";
+                                        function = "gpio";
+                                        drive-strength = <2>;
+                                        bias-disable;
+                        };
+
+};
+
+&blsp_i2c4 {
+        status = "ok";
+
+                sec_ts: sec_touchscreen@48 {
+                                compatible = "sec,sec_ts";
+                                reg = <0x48>;
+                                /*status = "disabled";*/
+				status = "okay";
+                                interrupt-parent = <&tlmm>;
+                                /*sec,irq_gpio = <0x7f 0x43 0x2008>;*/
+                                /* irq 67 -> 249 from E3 orig*/
+                                /* irq 67 -> 237 from new dts*/
+                                /* irq 67+(249-237) - > 79 */
+                                sec,irq_gpio = <&tlmm 0x43 0x2008>;
+                                pinctrl-names = "on_state", "off_state";
+                                pinctrl-0 = <&ts_active>;
+                                pinctrl-1 = <&ts_int_suspend>;
+				//pinctrl-1 = <&ts_active>;
+                                sec,max_coords = <0x438 0x870>;
+                                sec,num_lines = <0x12 0x20>;
+                        };
+};
+
+&bluetooth {
+	status = "disabled";
+};
diff --git a/arch/arm64/boot/dts/qcom/sdm636.dtsi b/arch/arm64/boot/dts/qcom/sdm636.dtsi
index ae15d81fa3f9..0cf72f0def38 100644
--- a/arch/arm64/boot/dts/qcom/sdm636.dtsi
+++ b/arch/arm64/boot/dts/qcom/sdm636.dtsi
@@ -5,19 +5,248 @@
  * Copyright (c) 2020, Martin Botka <martin.botka1@gmail.com>
  */
 
-#include "sdm660.dtsi"
-
-/*
- * According to the downstream DTS,
- * 636 is basically a 660 except for
- * different CPU frequencies, Adreno
- * 509 instead of 512 and lack of
- * turing IP. These differences will
- * be addressed when the aforementioned
- * peripherals will be enabled upstream.
- */
+#include "sdm630.dtsi"
 
 &adreno_gpu {
 	compatible = "qcom,adreno-509.0", "qcom,adreno";
-	/* Adreno 509 shares the frequency table with 512 */
+	operating-points-v2 = <&gpu_sdm660_opp_table>;
+
+	gpu_sdm660_opp_table: opp-table {
+		compatible  = "operating-points-v2";
+
+		/*
+		 * 775MHz is only available on the highest speed bin
+		 * Though it cannot be used for now due to interconnect
+		 * framework not supporting multiple frequencies
+		 * at the same opp-level
+
+		opp-750000000 {
+			opp-hz = /bits/ 64 <750000000>;
+			opp-level = <RPM_SMD_LEVEL_TURBO>;
+			opp-peak-kBps = <5412000>;
+			opp-supported-hw = <0xCHECKME>;
+		};
+
+		* These OPPs are correct, but we are lacking support for the
+		* GPU regulator. Hence, disable them for now to prevent the
+		* platform from hanging on high graphics loads.
+
+		opp-700000000 {
+			opp-hz = /bits/ 64 <700000000>;
+			opp-level = <RPM_SMD_LEVEL_TURBO>;
+			opp-peak-kBps = <5184000>;
+			opp-supported-hw = <0xFF>;
+		};
+
+		opp-647000000 {
+			opp-hz = /bits/ 64 <647000000>;
+			opp-level = <RPM_SMD_LEVEL_NOM_PLUS>;
+			opp-peak-kBps = <4068000>;
+			opp-supported-hw = <0xFF>;
+		};
+
+		opp-588000000 {
+			opp-hz = /bits/ 64 <588000000>;
+			opp-level = <RPM_SMD_LEVEL_NOM>;
+			opp-peak-kBps = <3072000>;
+			opp-supported-hw = <0xFF>;
+		};
+
+		opp-465000000 {
+			opp-hz = /bits/ 64 <465000000>;
+			opp-level = <RPM_SMD_LEVEL_SVS_PLUS>;
+			opp-peak-kBps = <2724000>;
+			opp-supported-hw = <0xFF>;
+		};
+
+		opp-370000000 {
+			opp-hz = /bits/ 64 <370000000>;
+			opp-level = <RPM_SMD_LEVEL_SVS>;
+			opp-peak-kBps = <2188000>;
+			opp-supported-hw = <0xFF>;
+		};
+		*/
+
+		opp-266000000 {
+			opp-hz = /bits/ 64 <266000000>;
+			opp-level = <RPM_SMD_LEVEL_LOW_SVS>;
+			opp-peak-kBps = <1648000>;
+			opp-supported-hw = <0xFF>;
+		};
+
+		opp-160000000 {
+			opp-hz = /bits/ 64 <160000000>;
+			opp-level = <RPM_SMD_LEVEL_MIN_SVS>;
+			opp-peak-kBps = <1200000>;
+			opp-supported-hw = <0xFF>;
+		};
+	};
+};
+
+&CPU0 {
+	compatible = "qcom,kryo260";
+	capacity-dmips-mhz = <1024>;
+	/delete-property/ operating-points-v2;
+};
+
+&CPU1 {
+	compatible = "qcom,kryo260";
+	capacity-dmips-mhz = <1024>;
+	/delete-property/ operating-points-v2;
+};
+
+&CPU2 {
+	compatible = "qcom,kryo260";
+	capacity-dmips-mhz = <1024>;
+	/delete-property/ operating-points-v2;
+};
+
+&CPU3 {
+	compatible = "qcom,kryo260";
+	capacity-dmips-mhz = <1024>;
+	/delete-property/ operating-points-v2;
+};
+
+&CPU4 {
+	compatible = "qcom,kryo260";
+	capacity-dmips-mhz = <640>;
+	/delete-property/ operating-points-v2;
+};
+
+&CPU5 {
+	compatible = "qcom,kryo260";
+	capacity-dmips-mhz = <640>;
+	/delete-property/ operating-points-v2;
+};
+
+&CPU6 {
+	compatible = "qcom,kryo260";
+	capacity-dmips-mhz = <640>;
+	/delete-property/ operating-points-v2;
+};
+
+&CPU7 {
+	compatible = "qcom,kryo260";
+	capacity-dmips-mhz = <640>;
+	/delete-property/ operating-points-v2;
+};
+
+&gcc {
+	compatible = "qcom,gcc-sdm660";
+};
+
+&gpucc {
+	compatible = "qcom,gpucc-sdm660";
+};
+
+&mdp {
+	ports {
+		port@1 {
+			reg = <1>;
+			mdp5_intf2_out: endpoint {
+				remote-endpoint = <&dsi1_in>;
+			};
+		};
+	};
+};
+
+&mdss {
+	dsi1: dsi@c996000 {
+		compatible = "qcom,mdss-dsi-ctrl";
+		reg = <0x0c996000 0x400>;
+		reg-names = "dsi_ctrl";
+
+		/* DSI1 shares the OPP table with DSI0 */
+		operating-points-v2 = <&dsi_opp_table>;
+		power-domains = <&rpmpd SDM660_VDDCX>;
+
+		interrupt-parent = <&mdss>;
+		interrupts = <5>;
+
+		assigned-clocks = <&mmcc BYTE1_CLK_SRC>,
+					<&mmcc PCLK1_CLK_SRC>;
+		assigned-clock-parents = <&dsi1_phy 0>,
+						<&dsi1_phy 1>;
+
+		clocks = <&mmcc MDSS_MDP_CLK>,
+				<&mmcc MDSS_BYTE1_CLK>,
+				<&mmcc MDSS_BYTE1_INTF_CLK>,
+				<&mmcc MNOC_AHB_CLK>,
+				<&mmcc MDSS_AHB_CLK>,
+				<&mmcc MDSS_AXI_CLK>,
+				<&mmcc MISC_AHB_CLK>,
+				<&mmcc MDSS_PCLK1_CLK>,
+				<&mmcc MDSS_ESC1_CLK>;
+		clock-names = "mdp_core",
+					"byte",
+					"byte_intf",
+					"mnoc",
+					"iface",
+					"bus",
+					"core_mmss",
+					"pixel",
+					"core";
+
+		phys = <&dsi1_phy>;
+		phy-names = "dsi";
+
+		status = "disabled";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				dsi1_in: endpoint {
+					remote-endpoint = <&mdp5_intf2_out>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				dsi1_out: endpoint {
+				};
+			};
+		};
+	};
+
+	dsi1_phy: dsi-phy@c996400 {
+		compatible = "qcom,dsi-phy-14nm-660";
+		reg = <0x0c996400 0x100>,
+				<0x0c996500 0x300>,
+				<0x0c996800 0x188>;
+		reg-names = "dsi_phy",
+				"dsi_phy_lane",
+				"dsi_pll";
+
+		#clock-cells = <1>;
+		#phy-cells = <0>;
+
+		clocks = <&mmcc MDSS_AHB_CLK>, <&rpmcc RPM_SMD_XO_CLK_SRC>;
+		clock-names = "iface", "ref";
+		status = "disabled";
+	};
+};
+
+&mmcc {
+	compatible = "qcom,mmcc-sdm660";
+	clocks = <&rpmcc RPM_SMD_XO_CLK_SRC>,
+			<&sleep_clk>,
+			<&gcc GCC_MMSS_GPLL0_CLK>,
+			<&gcc GCC_MMSS_GPLL0_DIV_CLK>,
+			<&dsi0_phy 1>,
+			<&dsi0_phy 0>,
+			<&dsi1_phy 1>,
+			<&dsi1_phy 0>,
+			<0>,
+			<0>;
+};
+
+&tlmm {
+	compatible = "qcom,sdm660-pinctrl";
+};
+
+&tsens {
+	#qcom,sensors = <14>;
 };
diff --git a/arch/arm64/boot/dts/qcom/sdm660-xiaomi-clover.dts b/arch/arm64/boot/dts/qcom/sdm660-xiaomi-clover.dts
new file mode 100644
index 000000000000..0ad747ecd4a9
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sdm660-xiaomi-clover.dts
@@ -0,0 +1,518 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2020, Mark Hargreaves <clashclanacc2602@gmail.com>
+ */
+
+/dts-v1/;
+#include "sdm660.dtsi"
+#include "pm660.dtsi"
+#include "pm660l.dtsi"
+
+/ {
+	model = "Xiaomi Mi Pad 4";	
+	compatible = "xiaomi,clover", "qcom,sda660", "qcom,sda660-mtp", "qcom,mtp";
+	qcom,board-id = <11 0>;
+	qcom,msm-id = <324 0>;
+	qcom,pmic-id = <0x0001001b 0x0101011a 0x0 0x0>, <0x0001001b 0x0201011a 0x0 0x0>,<0x0001001b 0x0102001a 0x0 0x0>;
+	chosen {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		framebuffer@0x9d400000 {
+			compatible = "simple-framebuffer";
+			reg = <0x0 0x9d400000 0x0 (1200 * 1920 * 4)>;
+			width = <1200>;
+			height = <1920>;
+			stride = <(1200 * 4)>;
+			format = "a8r8g8b8";
+		};
+	};
+
+	vph_pwr: vph-pwr-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vph_pwr";
+
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	memory {
+		device_type = "memory";
+		/* We expect the bootloader to fill in the reg */
+		reg = <0 0 0 0>;
+	};
+
+	gpio_keys {
+		compatible = "gpio-keys-polled";
+		poll-interval = <100>;
+		label = "Volume up";
+		pinctrl-names = "default";
+		pinctrl-0 = <&vol_up_pin_active>;
+
+		vol-up {
+			label = "Volume up";
+			gpios = <&pm660l_gpios 7 GPIO_ACTIVE_LOW>;
+			linux,input-type = <EV_KEY>;
+			linux,code = <KEY_VOLUMEUP>;
+			debounce-interval = <15>;
+		};
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		ramoops@0x9fe00000 {
+			compatible = "ramoops";
+			reg = <0x0 0x9fe00000 0x0 0x400000>;
+			console-size = <0x20000>;
+			record-size = <0x20000>;
+			ftrace-size = <0x0>;
+			pmsg-size = <0x20000>;
+		};
+		framebuffer_memory@0x9d400000 {
+			reg = <0x0 0x9d400000 0x0 (1200 * 1920 * 4)>;
+			no-map;
+		};
+	};
+
+};
+
+&rpm_requests {
+	pm660l-regulators {
+		compatible = "qcom,rpm-pm660l-regulators";
+
+		vdd_s1-supply = <&vph_pwr>;
+		vdd_s2-supply = <&vph_pwr>;
+		vdd_s3_s4-supply = <&vph_pwr>;
+		vdd_s5-supply = <&vph_pwr>;
+		vdd_s6-supply = <&vph_pwr>;
+
+		vdd_l1_l9_l10-supply = <&vreg_s2b_1p05>;
+		vdd_l2-supply = <&vreg_bob>;
+		vdd_l3_l5_l7_l8-supply = <&vreg_bob>;
+		vdd_l4_l6-supply = <&vreg_bob>;
+		vdd_bob-supply = <&vph_pwr>;
+
+		vreg_s1b_1p125: s1 {
+			regulator-min-microvolt = <1125000>;
+			regulator-max-microvolt = <1125000>;
+			regulator-enable-ramp-delay = <200>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_s2b_1p05: s2 {
+			regulator-min-microvolt = <1050000>;
+			regulator-max-microvolt = <1050000>;
+			regulator-enable-ramp-delay = <200>;
+			regulator-ramp-delay = <0>;
+		};
+
+		/* LDOs */
+		vreg_l1b_0p925: l1 {
+			regulator-min-microvolt = <800000>;
+			regulator-max-microvolt = <925000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l2b_2p95: l2 {
+			/*
+			 * This regulator supports 1.648 - 3.104V on this board
+			 * but we set a max voltage of anything less than 2.7V
+			 * to satisfy a condition in sdhci.c that will disable
+			 * 3.3V SDHCI signaling, which happens to be not really
+			 * supported on the Xperia Nile/Ganges platform.
+			 */
+			regulator-min-microvolt = <350000>;
+			regulator-max-microvolt = <3100000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l3b_3p0: l3 {
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3000000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-min-microamp = <200>;
+			regulator-max-microamp = <600000>;
+			regulator-system-load = <100000>;
+			regulator-allow-set-load;
+			regulator-always-on;
+		};
+
+		vreg_l4b_29p5: l4 {
+			regulator-min-microvolt = <1700000>;
+			regulator-max-microvolt = <2952000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+
+			regulator-min-microamp = <200>;
+			regulator-max-microamp = <600000>;
+			regulator-system-load = <570000>;
+			regulator-allow-set-load;
+		};
+
+		/*
+		 * Downstream specifies a range of 1721-3600mV,
+		 * but the only assigned consumers are SDHCI2 VMMC
+		 * and Coresight QPDI that both request pinned 2.95V.
+		 * Tighten the range to 1.8-3.328 (closest to 3.3) to
+		 * make the mmc driver happy.
+		 */
+		vreg_l5b_29p5: l5 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3328000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+			regulator-system-load = <800000>;
+		};
+
+		vreg_l6b_3p3: l6 {
+			regulator-min-microvolt = <1704000>;
+			regulator-max-microvolt = <3312000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l7b_3p125: l7 {
+			regulator-min-microvolt = <2700000>;
+			regulator-max-microvolt = <3125000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l8b_3p3: l8 {
+			regulator-min-microvolt = <3200000>;
+			regulator-max-microvolt = <3400000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l9b_0p87: l9 {
+			/* Unused */
+			status = "disabled";
+		};
+
+		vreg_l10b_0p915: l10 {
+			/* Unused */
+			status = "disabled";
+		};
+
+		vreg_bob: bob {
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3600000>;
+			regulator-enable-ramp-delay = <500>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_bob_pin1: bob_pin1 {
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3600000>;
+			regulator-enable-ramp-delay = <500>;
+			regulator-ramp-delay = <0>;
+			qcom,bob-pin-id = <1>;
+		};
+
+		vreg_bob_pin2: bob_pin2 {
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3600000>;
+			regulator-enable-ramp-delay = <500>;
+			regulator-ramp-delay = <0>;
+			qcom,bob-pin-id = <2>;
+		};
+
+		vreg_bob_pin3: bob_pin3 {
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3600000>;
+			regulator-enable-ramp-delay = <500>;
+			regulator-ramp-delay = <0>;
+			qcom,bob-pin-id = <3>;
+		};
+	};
+
+	pm660-regulators {
+		compatible = "qcom,rpm-pm660-regulators";
+
+		vdd_s1-supply = <&vph_pwr>;
+		vdd_s2-supply = <&vph_pwr>;
+		vdd_s3-supply = <&vph_pwr>;
+		vdd_s4-supply = <&vph_pwr>;
+		vdd_s5-supply = <&vph_pwr>;
+		vdd_s6-supply = <&vph_pwr>;
+
+		vdd_l1_l6_l7-supply = <&vreg_s5a_1p35>;
+		vdd_l2_l3-supply = <&vreg_s2b_1p05>;
+		vdd_l5-supply = <&vreg_s2b_1p05>;
+		vdd_l8_l9_l10_l11_l12_l13_l14-supply = <&vreg_s4a_2p04>;
+		vdd_l15_l16_l17_l18_l19-supply = <&vreg_bob>;
+
+		vreg_s1a_ftapc0: s1 {
+			/* Unused */
+			status = "disabled";
+		};
+
+		vreg_s2a_ftapc1: s2 {
+			/* Unused */
+			status = "disabled";
+		};
+
+		vreg_s3a_hfapc1: s3 {
+			/* Unused */
+			status = "disabled";
+		};
+
+		vreg_s4a_2p04: s4 {
+			regulator-min-microvolt = <1805000>;
+			regulator-max-microvolt = <2040000>;
+			regulator-enable-ramp-delay = <200>;
+			regulator-ramp-delay = <0>;
+			regulator-always-on;
+		};
+
+		vreg_s5a_1p35: s5 {
+			regulator-min-microvolt = <1224000>;
+			regulator-max-microvolt = <1350000>;
+			regulator-enable-ramp-delay = <200>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_s6a_0p87: s6 {
+			regulator-min-microvolt = <504000>;
+			regulator-max-microvolt = <992000>;
+			regulator-enable-ramp-delay = <150>;
+			regulator-ramp-delay = <0>;
+		};
+
+		/* LDOs */
+		vreg_l1a_1p225: l1 {
+			regulator-min-microvolt = <1150000>;
+			regulator-max-microvolt = <1250000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+			/* regulator-always-on; */
+		};
+
+		vreg_l2a_1p0: l2 {
+			regulator-min-microvolt = <950000>;
+			regulator-max-microvolt = <1010000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l3a_1p0: l3 {
+			regulator-min-microvolt = <950000>;
+			regulator-max-microvolt = <1010000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l5a_0p848: l5 {
+			regulator-min-microvolt = <525000>;
+			regulator-max-microvolt = <952000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l6a_1p3: l6 {
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1368000>;
+			regulator-allow-set-load;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l7a_1p2: l7 {
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l8a_1p8: l8 {
+			regulator-min-microvolt = <1750000>;
+			regulator-max-microvolt = <1900000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-system-load = <325000>;
+			regulator-allow-set-load;
+		};
+
+
+		vreg_l9a_1p8: l9 {
+			regulator-min-microvolt = <1750000>;
+			regulator-max-microvolt = <1900000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l10a_1p8: l10 {
+			regulator-min-microvolt = <1780000>;
+			regulator-max-microvolt = <1950000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l11a_1p8: l11 {
+			regulator-min-microvolt = <1784000>;
+			regulator-max-microvolt = <1944000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-always-on;
+		};
+
+		vreg_l12a_1p8: l12 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1944000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		/* This gives power to the LPDDR4: never turn it off! */
+		vreg_l13a_1p8: l13 {
+			regulator-min-microvolt = <1780000>;
+			regulator-max-microvolt = <1950000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+		vreg_l14a_1p8: l14 {
+			regulator-min-microvolt = <1710000>;
+			regulator-max-microvolt = <1904000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l15a_1p8: l15 {
+			regulator-min-microvolt = <1650000>;
+			regulator-max-microvolt = <2952000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l16a_2p7: l16 {
+			/* Unused */
+			status = "disabled";
+		};
+
+		vreg_l17a_1p8: l17 {
+			regulator-min-microvolt = <1648000>;
+			regulator-max-microvolt = <2952000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l18a_1v8: l18 {
+			status = "disabled";
+		};
+
+		vreg_l19a_3p3: l19 {
+			regulator-min-microvolt = <3200000>;
+			regulator-max-microvolt = <3400000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+		};
+	};
+};
+
+&adreno_gpu{
+	status = "disabled";
+};
+
+&blsp_i2c3 {
+	status = "okay";
+	touchscreen@38 {
+		compatible = "edt,edt-ft5406", "edt,edt-ft5x06";
+		reg = <0x38>;
+		vcc-supply = <&vreg_l11a_1p8>;
+		pinctrl-0 = <&ts_int_active &ts_rst>;
+		pinctrl-names = "default";
+		interrupt-parent = <&tlmm>;
+		interrupts = <67 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&tlmm 66 GPIO_ACTIVE_LOW>;
+		touchscreen-size-x = <1200>;
+		touchscreen-size-y = <1920>;
+	};
+};
+
+&gpucc{
+	status = "disabled";
+};
+
+&mmcc{
+	status = "disabled";
+};
+
+&pm660l_gpios {
+	vol_up_pin_active: vol_up_pin {
+		pins = "gpio7";
+		function = "normal";
+		input-enable;
+		bias-pull-up;
+	};
+};
+
+&pon {
+	resin {
+		compatible = "qcom,pm8941-resin";
+		interrupts = <0x0 0x8 1 IRQ_TYPE_EDGE_BOTH>;
+		debounce = <15625>;
+		bias-pull-up;
+		linux,code = <KEY_VOLUMEDOWN>;
+	};
+};
+
+&qusb2phy0 {
+	status = "okay";
+};
+
+&sdhc_1 {
+	status = "okay";
+	bus-width = <8>;
+	non-removable;
+	mmc-ddr-1_8v;
+	mmc-hs200-1_8v;
+	mmc-hs400-1_8v;
+};
+
+&sdhc_2 {
+	status = "okay";
+
+	vmmc-supply = <&vreg_l5b_29p5>;
+	vqmmc-supply = <&vreg_l2b_2p95>;
+};
+
+&tlmm {
+	gpio-reserved-ranges = <0 4>;
+
+	ts_int_active: ts-int-active {
+		pins = "gpio67";
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+	ts_rst: ts-rst {
+		pins = "gpio66";
+		drive-strength = <8>;
+		bias-pull-up;
+	};
+};
+
+&usb3 {
+	status = "okay";
+};
+
+&usb3_dwc3 {
+	status = "okay";
+	dr_mode = "peripheral";
+};
diff --git a/arch/arm64/boot/dts/qcom/sdm660-xiaomi-lavender.dts b/arch/arm64/boot/dts/qcom/sdm660-xiaomi-lavender.dts
index a3559f6e34a5..5ade1687c1a9 100644
--- a/arch/arm64/boot/dts/qcom/sdm660-xiaomi-lavender.dts
+++ b/arch/arm64/boot/dts/qcom/sdm660-xiaomi-lavender.dts
@@ -89,6 +89,18 @@ extcon_usb: extcon-usb {
 	};
 };
 
+&blsp_i2c1 {
+	status = "okay";
+
+	touchscreen: novatek@62 {
+		compatible = "novatek,nt36525";
+		reg = <0x62>;
+		interrupt-parent = <&tlmm>;
+		interrupts = <67 IRQ_TYPE_EDGE_RISING>;
+		reset-gpios = <&tlmm 66 GPIO_ACTIVE_HIGH>;
+	};
+};
+
 &blsp1_uart2 {
 	status = "okay";
 };
@@ -387,6 +399,46 @@ sd-cd {
 	};
 };
 
+&pm660l_wled {
+	status = "okay";
+
+	qcom,switching-freq = <800>;
+	qcom,current-limit-microamp = <20000>;
+	qcom,num-strings = <2>;
+};
+
+&sdc2_state_on {
+	sd-cd {
+		pins = "gpio54";
+		bias-pull-up;
+		drive-strength = <2>;
+	};
+};
+
+&sdc2_state_off {
+	sd-cd {
+		pins = "gpio54";
+		bias-disable;
+		drive-strength = <2>;
+	};
+};
+
+&sdc2_state_on {
+	sd-cd {
+		pins = "gpio54";
+		bias-pull-up;
+		drive-strength = <2>;
+	};
+};
+
+&sdc2_state_off {
+	sd-cd {
+		pins = "gpio54";
+		bias-disable;
+		drive-strength = <2>;
+	};
+};
+
 &sdhc_1 {
 	status = "okay";
 	supports-cqe;
diff --git a/arch/arm64/boot/dts/qcom/sdm660-xiaomi-platina.dts b/arch/arm64/boot/dts/qcom/sdm660-xiaomi-platina.dts
new file mode 100644
index 000000000000..5e9c316ac250
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sdm660-xiaomi-platina.dts
@@ -0,0 +1,782 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2021, AngeloGioacchino Del Regno
+ *                     <angelogioacchino.delregno@somainline.org>
+ * Copyright (c) 2022, Molly Sophia <mollysophia379@gmail.com>
+ */
+
+/dts-v1/;
+
+#include "sdm660.dtsi"
+#include "pm660.dtsi"
+#include "pm660l.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/input/gpio-keys.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pinctrl/qcom,pmic-gpio.h>
+
+/ {
+	model = "Xiaomi Mi 8 Lite";
+	compatible = "xiaomi,platina", "qcom,sdm660";
+
+	aliases {
+		serial0 = &blsp1_uart2;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		framebuffer@9d400000 {
+			compatible = "simple-framebuffer";
+			reg = <0x0 0x9d400000 0x0 (1080 * 2280 * 4)>;
+			width = <1080>;
+			height = <2280>;
+			stride = <(1080 * 4)>;
+			format = "a8r8g8b8";
+		};
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		ramoops@ffc00000 {
+			compatible = "ramoops";
+			reg = <0x0 0xffc00000 0x0 0x100000>;
+			record-size = <0x10000>;
+			console-size = <0x60000>;
+			ftrace-size = <0x10000>;
+			pmsg-size = <0x20000>;
+			ecc-size = <16>;
+			status = "okay";
+		};
+
+		debug_region@ffb00000 {
+			reg = <0x00 0xffb00000 0x00 0x100000>;
+			no-map;
+		};
+
+		cdsp-region@94e00000 {
+			reg = <0x00 0x94e00000 0x00 0x600000>;
+			no-map;
+		};
+
+		removed_region@85800000 {
+			reg = <0x00 0x85800000 0x00 0x3700000>;
+			no-map;
+		};
+
+		framebuffer_memory@9d400000 {
+			reg = <0x0 0x9d400000 0x0 (1080 * 2280 * 4)>;
+			no-map;
+		};
+	};
+
+	board_vbat: vbat-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "VBAT";
+
+		regulator-min-microvolt = <4000000>;
+		regulator-max-microvolt = <4000000>;
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	cam_avdd_front_vreg: cam-avdd-front-vreg {
+		compatible = "regulator-fixed";
+		regulator-name = "cam-avdd-front-vreg";
+
+		regulator-min-microvolt = <3600000>;
+		regulator-max-microvolt = <3600000>;
+		startup-delay-us = <0>;
+		enable-active-high;
+		gpio = <&tlmm 49 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cam_avdd_front_default>;
+		vin-supply = <&vreg_bob>;
+	};
+
+	cam_actuator_rear_vreg: cam-actuator-rear-vreg {
+		compatible = "regulator-fixed";
+		regulator-name = "cam-actuator-rear-vreg";
+
+		regulator-min-microvolt = <3600000>;
+		regulator-max-microvolt = <3600000>;
+		startup-delay-us = <0>;
+		enable-active-high;
+		gpio = <&tlmm 50 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cam_actuator_rear_default>;
+		vin-supply = <&vreg_bob>;
+	};
+
+	cam_avdd_rear_vreg: cam-avdd-rear-vreg {
+		compatible = "regulator-fixed";
+		regulator-name = "cam-avdd-rear-vreg";
+
+		regulator-min-microvolt = <3600000>;
+		regulator-max-microvolt = <3600000>;
+		startup-delay-us = <0>;
+		enable-active-high;
+		gpio = <&tlmm 51 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cam_avdd_rear_default>;
+		vin-supply = <&vreg_bob>;
+	};
+
+	cam_dvdd_front_vreg: cam-dvdd-front-vreg {
+		compatible = "regulator-fixed";
+		regulator-name = "cam-dvdd-front-vreg";
+
+		regulator-min-microvolt = <1350000>;
+		regulator-max-microvolt = <1350000>;
+		startup-delay-us = <0>;
+		enable-active-high;
+		gpio = <&pm660l_gpios 3 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cam_dvdd_front_default>;
+		vin-supply = <&vreg_s5a_1p35>;
+	};
+
+	cam_dvdd_rear_vreg: cam-dvdd-rear-vreg {
+		compatible = "regulator-fixed";
+		regulator-name = "cam-dvdd-rear-vreg";
+
+		regulator-min-microvolt = <1350000>;
+		regulator-max-microvolt = <1350000>;
+		startup-delay-us = <0>;
+		enable-active-high;
+		gpio = <&pm660l_gpios 4 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cam_dvdd_rear_default>;
+		vin-supply = <&vreg_s5a_1p35>;
+	};
+
+	disp_vdd_vreg: disp-vdd-vreg {
+		compatible = "regulator-fixed";
+		regulator-name = "display-vdd";
+
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	ts_vdd_vreg: ts-vdd-vreg {
+		compatible = "regulator-fixed";
+		regulator-name = "ts-vdd";
+
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		startup-delay-us = <4000>;
+		enable-active-high;
+		regulator-boot-on;
+		gpio = <&tlmm 73 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&ts_vdd_default>;
+	};
+
+	vph_pwr: vph-pwr-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vph_pwr";
+
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	gpio_keys {
+		status = "okay";
+		compatible = "gpio-keys-polled";
+		poll-interval = <100>;
+		label = "Volume up";
+		pinctrl-names = "default";
+		pinctrl-0 = <&vol_up_gpio_default>;
+
+		vol_up {
+			label = "Volume Up";
+			gpios = <&pm660l_gpios 7 GPIO_ACTIVE_LOW>;
+			linux,input-type = <EV_KEY>;
+			linux,code = <KEY_VOLUMEUP>;
+			debounce-interval = <15>;
+		};
+	};
+
+	gpio-hall-sensor {
+		compatible = "gpio-keys";
+		label = "Hall effect sensor";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&hall_sensor_default>;
+
+		hall-sensor {
+			label = "Hall Effect Sensor";
+			gpios = <&tlmm 75 GPIO_ACTIVE_LOW>;
+			linux,input-type = <EV_SW>;
+			linux,code = <SW_LID>;
+			linux,can-disable;
+			wakeup-source;
+		};
+	};
+
+
+	/*
+	 * Until we hook up type-c detection, we
+	 * have to stick with this. But it works.
+	 */
+	extcon_usb: extcon-usb {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpio = <&tlmm 58 GPIO_ACTIVE_HIGH>;
+	};
+};
+
+&blsp_i2c2 {
+	status = "okay";
+
+	/*
+	 * Two instances of SMB1355 charger: 0x8, 0xc but only
+	 * one SMB1355 chip is present on board. What's the
+	 * right address?
+	 */
+};
+
+&blsp_i2c4 {
+	status = "okay";
+	/* Novatek device tree node */
+	novatek@62 {
+		compatible = "novatek,nt36525";
+		reg = <0x62>;
+		vcc-supply = <&vreg_l11a_1p8>;
+		pinctrl-0 = <&ts_int_active &ts_rst_n>;
+		pinctrl-names = "default";
+		interrupt-parent = <&tlmm>;
+		interrupts = <67 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpios = <&tlmm 66 GPIO_ACTIVE_LOW>;
+		touchscreen-size-x = <1080>;
+		touchscreen-size-y = <2280>;
+	};
+};
+
+&blsp1_uart2 {
+	status = "okay";
+};
+
+&rpm_requests {
+	pm660l-regulators {
+		compatible = "qcom,rpm-pm660l-regulators";
+
+		vdd_s1-supply = <&vph_pwr>;
+		vdd_s2-supply = <&vph_pwr>;
+		vdd_s3_s4-supply = <&vph_pwr>;
+		vdd_s5-supply = <&vph_pwr>;
+		vdd_s6-supply = <&vph_pwr>;
+
+		vdd_l1_l9_l10-supply = <&vreg_s2b_1p05>;
+		vdd_l2-supply = <&vreg_bob>;
+		vdd_l3_l5_l7_l8-supply = <&vreg_bob>;
+		vdd_l4_l6-supply = <&vreg_bob>;
+		vdd_bob-supply = <&vph_pwr>;
+
+		vreg_s1b_1p125: s1 {
+			regulator-min-microvolt = <1125000>;
+			regulator-max-microvolt = <1125000>;
+			regulator-enable-ramp-delay = <200>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_s2b_1p05: s2 {
+			regulator-min-microvolt = <1050000>;
+			regulator-max-microvolt = <1050000>;
+			regulator-enable-ramp-delay = <200>;
+			regulator-ramp-delay = <0>;
+		};
+
+		/*
+		 * At least on Nile's configuration, S3B/S4B (VDD_CX) and
+		 * S5B (VDD_MX) are managed only through RPM Power Domains.
+		 * Trying to set a voltage on the main supply will create
+		 * havoc and freeze the SoC.
+		 * In any case, reference voltages for these regulators are:
+		 * S3B/S4B: 0.870V
+		 * S5B: 0.915V
+		 */
+
+		/* LDOs */
+		vreg_l1b_0p925: l1 {
+			regulator-min-microvolt = <920000>;
+			regulator-max-microvolt = <928000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l2b_2p95: l2 {
+			/*
+			 * This regulator supports 1.648 - 3.104V on this board
+			 * but we set a max voltage of anything less than 2.7V
+			 * to satisfy a condition in sdhci.c that will disable
+			 * 3.3V SDHCI signaling, which happens to be not really
+			 * supported on the Xperia Nile/Ganges platform.
+			 */
+			regulator-min-microvolt = <1648000>;
+			regulator-max-microvolt = <2696000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l3b_3p3: l3 {
+			regulator-min-microvolt = <3296000>;
+			regulator-max-microvolt = <3312000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-min-microamp = <200>;
+			regulator-max-microamp = <600000>;
+			regulator-system-load = <100000>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l4b_2p95: l4 {
+			regulator-min-microvolt = <2944000>;
+			regulator-max-microvolt = <2952000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+
+			regulator-min-microamp = <200>;
+			regulator-max-microamp = <600000>;
+			regulator-system-load = <570000>;
+			regulator-allow-set-load;
+		};
+
+		/*
+		 * Downstream specifies a range of 1721-3600mV,
+		 * but the only assigned consumers are SDHCI2 VMMC
+		 * and Coresight QPDI that both request pinned 2.95V.
+		 * Tighten the range to 1.8-3.328 (closest to 3.3) to
+		 * make the mmc driver happy.
+		 */
+		vreg_l5b_29p5: l5 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <3328000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+			regulator-system-load = <800000>;
+		};
+
+		vreg_l7b_3p125: l7 {
+			regulator-min-microvolt = <2704000>;
+			regulator-max-microvolt = <3128000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l8b_3p3: l8 {
+			regulator-min-microvolt = <2800000>;
+			regulator-max-microvolt = <3400000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		/* L9B (870mV) is currently unused */
+		/* L10B (915mV) is currently unused */
+
+		vreg_bob: bob {
+			regulator-min-microvolt = <3304000>;
+			regulator-max-microvolt = <3624000>;
+			regulator-enable-ramp-delay = <500>;
+			regulator-ramp-delay = <0>;
+		};
+	};
+
+
+	pm660-regulators {
+		compatible = "qcom,rpm-pm660-regulators";
+
+		vdd_s1-supply = <&vph_pwr>;
+		vdd_s2-supply = <&vph_pwr>;
+		vdd_s3-supply = <&vph_pwr>;
+		vdd_s4-supply = <&vph_pwr>;
+		vdd_s5-supply = <&vph_pwr>;
+		vdd_s6-supply = <&vph_pwr>;
+
+		vdd_l1_l6_l7-supply = <&vreg_s5a_1p35>;
+		vdd_l2_l3-supply = <&vreg_s2b_1p05>;
+		vdd_l5-supply = <&vreg_s2b_1p05>;
+		vdd_l8_l9_l10_l11_l12_l13_l14-supply = <&vreg_s4a_2p04>;
+		vdd_l15_l16_l17_l18_l19-supply = <&vreg_bob>;
+
+		/*
+		 * S1A (FTAPC0), S2A (FTAPC1), S3A (HFAPC1) are managed
+		 * by the Core Power Reduction hardened (CPRh) and the
+		 * Operating State Manager (OSM) HW automatically.
+		 */
+
+		vreg_s4a_2p04: s4 {
+			regulator-min-microvolt = <2040000>;
+			regulator-max-microvolt = <2040000>;
+			regulator-enable-ramp-delay = <200>;
+			regulator-ramp-delay = <0>;
+			regulator-always-on;
+		};
+
+		vreg_s5a_1p35: s5 {
+			regulator-min-microvolt = <1224000>;
+			regulator-max-microvolt = <1350000>;
+			regulator-enable-ramp-delay = <200>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_s6a_0p87: s6 {
+			regulator-min-microvolt = <504000>;
+			regulator-max-microvolt = <992000>;
+			regulator-enable-ramp-delay = <150>;
+			regulator-ramp-delay = <0>;
+		};
+
+		/* LDOs */
+		vreg_l1a_1p225: l1 {
+			regulator-min-microvolt = <1226000>;
+			regulator-max-microvolt = <1250000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l2a_1p0: l2 {
+			regulator-min-microvolt = <944000>;
+			regulator-max-microvolt = <1008000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l3a_1p0: l3 {
+			regulator-min-microvolt = <944000>;
+			regulator-max-microvolt = <1008000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l5a_0p848: l5 {
+			regulator-min-microvolt = <800000>;
+			regulator-max-microvolt = <952000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l6a_1p3: l6 {
+			regulator-min-microvolt = <1304000>;
+			regulator-max-microvolt = <1368000>;
+			regulator-allow-set-load;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l7a_1p2: l7 {
+			regulator-min-microvolt = <1200000>;
+			regulator-max-microvolt = <1200000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l8a_1p8: l8 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-system-load = <325000>;
+			regulator-allow-set-load;
+		};
+
+
+		vreg_l9a_1p8: l9 {
+			regulator-min-microvolt = <1804000>;
+			regulator-max-microvolt = <1896000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l10a_1p8: l10 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1944000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+		};
+
+		vreg_l11a_1p8: l11 {
+			regulator-min-microvolt = <1784000>;
+			regulator-max-microvolt = <1944000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l12a_1p8: l12 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1944000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l13a_1p8: l13 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1944000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-boot-on;
+			regulator-always-on;
+		};
+
+		vreg_l14a_1p8: l14 {
+			regulator-min-microvolt = <1710000>;
+			regulator-max-microvolt = <1952000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l15a_1p8: l15 {
+			regulator-min-microvolt = <1648000>;
+			regulator-max-microvolt = <2952000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		/* DRX: QM13111 */
+		vreg_l16a_2p7: l16 {
+			regulator-min-microvolt = <2704000>;
+			regulator-max-microvolt = <2712000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		vreg_l17a_1p8: l17 {
+			regulator-min-microvolt = <1648000>;
+			regulator-max-microvolt = <2952000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+		};
+
+		/* L18A (2.7V) is unused */
+
+		vreg_l19a_3p3: l19 {
+			regulator-min-microvolt = <3312000>;
+			regulator-max-microvolt = <3328000>;
+			regulator-enable-ramp-delay = <250>;
+			regulator-ramp-delay = <0>;
+			regulator-allow-set-load;
+		};
+	};
+};
+
+&sdhc_1 {
+	status = "okay";
+	supports-cqe;
+
+	mmc-ddr-1_8v;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+
+	vmmc-supply = <&vreg_l4b_2p95>;
+	vqmmc-supply = <&vreg_l8a_1p8>;
+};
+
+&sdhc_2 {
+	status = "disabled";
+
+	vmmc-supply = <&vreg_l5b_29p5>;
+	vqmmc-supply = <&vreg_l2b_2p95>;
+};
+
+&pm660_gpios {
+	nfc_clk_req_n: nfc-clkreq-n {
+		pins = "gpio4";
+		function = PMIC_GPIO_FUNC_NORMAL;
+		bias-disable;
+		input-enable;
+		power-source = <1>;
+	};
+};
+
+&pm660l_gpios {
+	cam_dvdd_front_default: cam-dvdd-front-default {
+		pins = "gpio3";
+		function = "normal";
+		output-low;
+		power-source = <0>;
+	};
+
+	cam_dvdd_rear_default: cam-dvdd-rear-default {
+		pins = "gpio4";
+		function = "normal";
+		output-low;
+		power-source = <0>;
+	};
+
+	vol_up_gpio_default: vol-up-gpio-default {
+		pins = "gpio7";
+		function = "normal";
+		bias-pull-up;
+		input-enable;
+		qcom,drive-strength = <PMIC_GPIO_STRENGTH_NO>;
+	};
+};
+
+&pon_resin {
+	linux,code = <KEY_VOLUMEDOWN>;
+	status = "okay";
+};
+
+&pon_pwrkey {
+	status = "okay";
+};
+
+&tlmm {
+	gpio-reserved-ranges = <8 4>;
+
+	camera_rear_default: camera-rear-default {
+		mclk0 {
+			pins = "gpio32";
+			function = "cam_mclk";
+			drive-strength = <4>;
+			bias-disable;
+		};
+
+		rst {
+			pins = "gpio46";
+			function = "gpio";
+			drive-strength = <16>;
+			bias-disable;
+		};
+	};
+
+	camera_front_default: camera-front-default {
+		mclk1 {
+			pins = "gpio33";
+			function = "cam_mclk";
+			drive-strength = <4>;
+			bias-disable;
+		};
+
+		rst {
+			pins = "gpio47";
+			function = "gpio";
+			drive-strength = <16>;
+			bias-disable;
+		};
+	};
+
+	camera_front_iris_default: camera-front-iris-default {
+		mclk1 {
+			pins = "gpio35";
+			function = "cam_mclk";
+			drive-strength = <4>;
+			bias-disable;
+		};
+
+		rst {
+			pins = "gpio52";
+			function = "gpio";
+			drive-strength = <16>;
+			bias-disable;
+		};
+	};
+
+	cam_avdd_front_default: cam-avdd-front-default {
+		pins = "gpio49";
+		function = "gpio";
+		bias-disable;
+		drive-strength = <2>;
+	};
+
+	cam_actuator_rear_default: cam-actuator-rear-default {
+		pins = "gpio50";
+		function = "gpio";
+		bias-disable;
+		drive-strength = <2>;
+	};
+
+	cam_avdd_rear_default: cam-avdd-rear-default {
+		pins = "gpio51";
+		function = "gpio";
+		bias-disable;
+		drive-strength = <2>;
+	};
+
+	panel_reset_n: panel-rst-n {
+		pins = "gpio53";
+		function = "gpio";
+		drive-strength = <8>;
+		bias-disable;
+	};
+
+	mdp_vsync_n: mdp-vsync-n {
+		pins = "gpio59";
+		function = "mdp_vsync";
+		drive-strength = <2>;
+		bias-pull-down;
+	};
+
+	ts_rst_n: ts-rst-n {
+		pins = "gpio66";
+		function = "gpio";
+		bias-disable;
+		drive-strength = <8>;
+	};
+
+	ts_int_active: ts-int-active {
+		pins = "gpio67";
+		drive-strength = <16>;
+		bias-pull-up;
+	};
+
+	ts_vdd_default: ts-vdd-default {
+		pins = "gpio73";
+		function = "gpio";
+		bias-disable;
+		drive-strength = <8>;
+	};
+
+	hall_sensor_default: hall-sensor-default {
+		pins = "gpio75";
+		function = "gpio";
+		drive-strength = <2>;
+		bias-disable;
+		input-enable;
+	};
+
+};
+
+&adreno_gpu{
+	status = "disabled";
+};
+
+&gpucc{
+	status = "disabled";
+};
+
+&mmcc{
+	status = "disabled";
+};
+
+&qusb2phy0 {
+	status = "okay";
+
+	vdd-supply = <&vreg_l1b_0p925>;
+	vdda-pll-supply = <&vreg_l10a_1p8>;
+	vdda-phy-dpdm-supply = <&vreg_l7b_3p125>;
+};
+
+&usb3 {
+	status = "okay";
+};
+
+&usb3_dwc3 {
+	dr_mode = "peripheral";
+	extcon = <&extcon_usb>;
+};
diff --git a/arch/arm64/boot/dts/qcom/sdm660.dtsi b/arch/arm64/boot/dts/qcom/sdm660.dtsi
index 43220af1b685..a0c69c5648dc 100644
--- a/arch/arm64/boot/dts/qcom/sdm660.dtsi
+++ b/arch/arm64/boot/dts/qcom/sdm660.dtsi
@@ -9,6 +9,74 @@
 
 #include "sdm630.dtsi"
 
+/ {
+	reserved-memory {
+		/delete-node/ tzbuffer@94a00000;
+
+		cdsp_region: cdsp@94a00000 {
+			reg = <0x0 0x94a00000 0x0 0x600000>;
+			no-map;
+		};
+
+	};
+
+	smp2p-cdsp {
+		compatible = "qcom,smp2p";
+		qcom,smem = <94>, <432>;
+		interrupts = <GIC_SPI 514 IRQ_TYPE_EDGE_RISING>;
+		mboxes = <&apcs_glb 30>;
+		qcom,local-pid = <0>;
+		qcom,remote-pid = <5>;
+
+		cdsp_smp2p_out: master-kernel {
+			qcom,entry-name = "master-kernel";
+			#qcom,smem-state-cells = <1>;
+		};
+
+		cdsp_smp2p_in: slave-kernel {
+			qcom,entry-name = "slave-kernel";
+			interrupt-controller;
+			#interrupt-cells = <2>;
+		};
+	};
+
+	soc {
+		cdsp_pil: remoteproc@1a300000 {
+			compatible = "qcom,sdm660-cdsp-pas";
+			reg = <0x1a300000 0x4040>;
+
+			interrupts-extended =
+				<&intc GIC_SPI 518 IRQ_TYPE_EDGE_RISING>,
+				<&cdsp_smp2p_in 0 IRQ_TYPE_EDGE_RISING>,
+				<&cdsp_smp2p_in 1 IRQ_TYPE_EDGE_RISING>,
+				<&cdsp_smp2p_in 2 IRQ_TYPE_EDGE_RISING>,
+				<&cdsp_smp2p_in 3 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "wdog", "fatal", "ready",
+					  "handover", "stop-ack";
+
+			clocks = <&rpmcc RPM_SMD_XO_CLK_SRC>;
+			clock-names = "xo";
+
+			memory-region = <&cdsp_region>;
+			power-domains = <&rpmpd SDM660_VDDCX>;
+			power-domain-names = "cx";
+
+			qcom,smem-states = <&cdsp_smp2p_out 0>;
+			qcom,smem-state-names = "stop";
+
+			glink-edge {
+				interrupts = <GIC_SPI 513 IRQ_TYPE_EDGE_RISING>;
+
+				label = "turing";
+				mboxes = <&apcs_glb 29>;
+				qcom,remote-pid = <5>;
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+	};
+};
+
 &adreno_gpu {
 	compatible = "qcom,adreno-512.0", "qcom,adreno";
 	operating-points-v2 = <&gpu_sdm660_opp_table>;
diff --git a/arch/arm64/boot/dts/qcom/sm7125-idp.dts b/arch/arm64/boot/dts/qcom/sm7125-idp.dts
new file mode 100644
index 000000000000..e44d52fdab7e
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-idp.dts
@@ -0,0 +1,1409 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * SC7180 IDP board device tree source
+ *
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/regulator/qcom,rpmh-regulator.h>
+#include <dt-bindings/pinctrl/qcom,pmic-gpio.h>
+#include "sc7180.dtsi"
+#include "pm6150.dtsi"
+#include "pm6150l.dtsi"
+
+/ {
+	model = "Qualcomm Technologies, Inc. SM7125 IDP";
+	compatible = "qcom,sm7125", "qcom,sc7180-idp", "qcom,sc7180";
+        qcom,board-id = <0x50022 0x01>;
+        qcom,msm-id = <0x1bb 0x00>;
+        qcom,msm-name = "ATOLL-AB";
+        qcom,pmic-name = "PM6150";
+
+	aliases {
+		bluetooth0 = &bluetooth;
+		hsuart0 = &uart3;
+		serial0 = &uart8;
+		wifi0 = &wifi;
+	};
+
+        chosen {
+                #address-cells = <2>;
+                #size-cells = <2>;
+                ranges;
+
+                stdout-path = "serial0:115200n8";
+
+		//framebuffer: a{};
+                framebuffer: framebuffer@9c000000 {
+                        compatible = "drm-simple-framebuffer", "simple-framebuffer";
+                        reg = <0 0x9c000000 0 0x1700000>;
+                        width = <1080>;
+                        height = <2400>;
+                        stride = <(1080 * 4)>;
+                        format = "a8r8g8b8";
+
+#if 1
+                        clocks = <&gcc GCC_DISP_AHB_CLK>,
+                                 <&gcc GCC_DISP_HF_AXI_CLK>,
+//                                 <&gcc GCC_DISP_THROTTLE_CORE_CLK>,
+				<&gcc GCC_DISP_THROTTLE_HF_AXI_CLK>,
+                                 <&gcc GCC_DISP_GPLL0_DIV_CLK_SRC>;
+#endif
+                };
+        };
+
+/*
+	gpio-keys {
+                compatible = "gpio-keys";
+                autorepeat;
+
+                pinctrl-names = "default";
+                pinctrl-0 = <&vol_up_pin_a>;
+
+                key-vol-up {
+                        label = "Volume Up";
+                        linux,code = <KEY_VOLUMEUP>;
+                        gpios = <&pm6150l_gpio 2 GPIO_ACTIVE_LOW>;
+                };
+
+	};
+*/
+};
+
+&soc {
+	dummy_clk: dummy_clk {
+		compatible = "fixed-factor-clock";
+	        clocks = <&dispcc DISP_CC_MDSS_AHB_CLK>, <&dispcc DISP_CC_MDSS_NON_GDSC_AHB_CLK>, <&dispcc DISP_CC_MDSS_MDP_LUT_CLK>;
+	        #clock-cells = <2>;
+	        clock-div = <1>;
+	        clock-mult = <1>;
+	};
+};
+
+&CPU0 { compatible = "qcom,kryo465"; };
+&CPU1 { compatible = "qcom,kryo465"; };
+&CPU2 { compatible = "qcom,kryo465"; };
+&CPU3 { compatible = "qcom,kryo465"; };
+&CPU4 { compatible = "qcom,kryo465"; };
+&CPU5 { compatible = "qcom,kryo465"; };
+&CPU6 { compatible = "qcom,kryo465"; };
+&CPU7 { compatible = "qcom,kryo465"; };
+
+/*
+ * Reserved memory changes
+ *
+ * Delete all unused memory nodes and define the peripheral memory regions
+ * required by the board dts.
+ *
+ */
+
+/* Increase the size from 2MB to 8MB */
+&rmtfs_mem {
+	reg = <0x0 0x94600000 0x0 0x800000>;
+};
+
+///delete-node/ &rmtfs_mem;
+/delete-node/ &ipa_fw_mem;
+
+/ {
+	reserved-memory {
+/*joyeuse
+@1:0x800000                      adsp_mem = "/reserved-memory/adsp_region";
+@0                      reserved_memory = "/reserved-memory";
+@2:0x1000000                      qseecom_ta_mem = "/reserved-memory/qseecom_ta_region";
+@3:0x8c00000                      secure_display_memory = "/reserved-memory/secure_display_region";
+@80000000";0x600000             hyp_region = "/reserved-memory/hyp_region
+@80700000";0x140000             xbl_aop_mem = "/reserved-memory/xbl_aop_mem
+@808ff000";0x1000             sec_apps_mem = "/reserved-memory/sec_apps_region
+@80900000";0x200000             smem_region = "/reserved-memory/smem
+@80b00000";0x3900000             removed_region = "/reserved-memory/removed_region
+@86000000";0x8400000             pil_modem_mem = "/reserved-memory/modem_region
+@8e400000";0x500000             pil_camera_mem = "/reserved-memory/camera_region
+@8e900000";0x500000             pil_npu_mem = "/reserved-memory/pil_npu_region
+@8ee00000";0x500000             pil_video_mem = "/reserved-memory/pil_video_region
+@8f300000";0x1e00000             pil_cdsp_mem = "/reserved-memory/cdsp_regions
+@91100000";0x2800000             pil_adsp_mem = "/reserved-memory/pil_adsp_region
+@93900000";0x200000             wlan_fw_mem = "/reserved-memory/wlan_fw_region
+@93b00000":0x10000             pil_ipa_fw_mem = "/reserved-memory/ipa_fw_region
+@93b10000";0x5000             pil_ipa_gsi_mem = "/reserved-memory/ipa_gsi_region
+@93b15000";0x2000             pil_gpu_mem = "/reserved-memory/gpu_region
+@9c000000";0x1700000           cont_splash_memory = "/reserved-memory/cont_splash_region
+@9d700000";0x100000             dfps_data_memory = "/reserved-memory/dfps_data_region
+@9e000000";0x1400000             qseecom_mem = "/reserved-memory/qseecom_region
+@9f400000";0x1e00000           cdsp_sec_mem = "/reserved-memory/cdsp_sec_regions
+*/
+
+		/*
+		sc7180 arrangement:
+			xbl_mem arranged 0x80600000-0x80800000
+			aop_mem arranged 0x80800000-0x80820000
+
+		which is equivlent to joyeuse
+			@80600000-80700000	joyeuse@available to sc7180@xbl_mem (80600000:200000)
+			@80700000";0x140000             xbl_aop_mem = "/reserved-memory/xbl_aop_mem
+
+		====
+
+		sc7180:
+			sec_apps_mem: memory@808ff000 { //size 0x1000
+			@808ff000";0x1000             sec_apps_mem = "/reserved-memory/sec_apps_region
+		joyeuse:
+			sec_apps_mem = "/reserved-memory/sec_apps_region		
+
+		====
+		sc7180:
+			smem_mem: memory@80900000 {
+		joyeuse:
+			smem_region = "/reserved-memory/smem
+
+		*/
+
+
+		/*
+		sc7180:
+			tz_mem: memory@80b00000 {
+		joyeuse:
+			removed_region = "/reserved-memory/removed_region
+
+		*/
+
+		atf_mem: memory@80b00000 {
+			reg = <0x0 0x80b00000 0x0 0x100000>;
+			no-map;
+		};
+
+		/*
+		joyeuse:
+			@86000000";0x8400000             pil_modem_mem = "/reserved-memory/modem_region
+
+			@86000000 till 0x8E400000
+		sc7180:
+			@86000000 till 0x8EC00000
+		*/
+		mpss_mem: memory@86000000 {
+			reg = <0x0 0x86000000 0x0 0x8400000>;
+			no-map;
+		};
+
+		/*
+		joyeuse:
+			@8e400000";0x500000             pil_camera_mem = "/reserved-memory/camera_region
+		sc7180:
+			0x0 0x8ec00000 0x0 0x500000
+	
+		*/
+		camera_mem: memory@8e400000 {
+			reg = <0x0 0x8e400000 0x0 0x500000>;
+			no-map;
+		};
+
+		/* TODO:check
+		joyeuse:
+			@8ee00000";0x500000             pil_video_mem = "/reserved-memory/pil_video_region
+		sc7180:
+			reg = <0 0x8f600000 0 0x500000>;
+		*/
+		venus_mem: memory@8ee00000 {
+			reg = <0 0x8ee00000 0 0x500000>;
+			no-map;
+		};
+
+		/*
+			@8f300000";0x1e00000             pil_cdsp_mem = "/reserved-memory/cdsp_regions
+		*/
+                cdsp_mem: memory@8f300000 {
+                        reg = <0x0 0x8f300000 0x0 0x1e00000>;
+                        no-map;
+                };
+
+		/*
+			@91100000";0x2800000             pil_adsp_mem = "/reserved-memory/pil_adsp_region
+		*/
+                adsp_mem: memory@91100000 {
+                        reg = <0x0 0x91100000 0x0 0x2800000>;
+                        no-map;
+                };
+
+                /*
+                joyeuse:
+                        @93900000";0x200000             wlan_fw_mem = "/reserved-memory/wlan_fw_region
+                sc7180:
+                        reg = <0x0 0x94100000 0x0 0x200000>;
+                */
+                wlan_mem: memory@93900000 {
+                        reg = <0x0 0x93900000 0x0 0x200000>;
+                        no-map;
+                };
+
+		/*
+			@93b00000":0x10000             pil_ipa_fw_mem = "/reserved-memory/ipa_fw_region
+			@93b10000";0x5000             pil_ipa_gsi_mem = "/reserved-memory/ipa_gsi_region
+		sc7180:
+			memory@8b700000 (0x000000008b700000--0x000000008b710000)
+		*/
+		ipa_fw_mem: memory@93b00000 {
+                        reg = <0x0 0x93b00000 0x0 0x15000>;
+                        no-map;
+                };
+
+
+		/*
+			@93b15000";0x2000             pil_gpu_mem = "/reserved-memory/gpu_region
+		*/
+                gpu_mem: memory@93b15000 {
+                        reg = <0x0 0x93b15000 0x0 0x2000>;
+                        no-map;
+                };
+
+                //TODO:
+                mba_mem: memory@94400000 {
+                        reg = <0x0 0x94400000 0x0 0x200000>;
+                        no-map;
+                };
+
+		/*
+			@9c000000";0x1700000           cont_splash_memory = "/reserved-memory/cont_splash_region
+		*/
+		splash_mem: memory@9c000000 {
+                        reg = <0x0 0x9c000000 0x0 0x1700000>;
+                        no-map;
+                };
+
+		/*
+			@9d700000";0x100000             dfps_data_memory = "/reserved-memory/dfps_data_region
+		*/
+                dfps_data_mem: memory@9d700000 {
+                        reg = <0x0 0x9d700000 0x0 0x100000>;
+                        no-map;
+                };
+
+	        ramoops_mem: ramoops@9d800000 {
+			compatible = "ramoops";
+			reg = <0x0 0x9d800000 0x0 0x00400000>;
+
+			record-size = <0x80000>;
+	                pmsg-size = <0x200000>;
+			console-size = <0x100000>;
+			mem-type = <1>;
+	        };
+
+		/*
+			@9e000000";0x1400000             qseecom_mem = "/reserved-memory/qseecom_region
+		*/
+		qseecom_mem: memory@9e000000 {
+                        reg = <0x0 0x9e000000 0x0 0x1400000>;
+                        no-map;
+                };
+
+		/*
+			@9f400000";0x1e00000           cdsp_sec_mem = "/reserved-memory/cdsp_sec_regions
+		*/
+		cdsp_sec_mem: memory@9f400000 {
+                        reg = <0x0 0x9f400000 0x0 0x1e00000>;
+                        no-map;
+                };
+#if 0
+                protect_mem: memory@80000000 {
+                        reg = <0x0 0x80000000 0x0 0x21200000>;
+                        no-map;
+                };
+#endif
+	};
+};
+
+&apps_rsc {
+	pm6150-rpmh-regulators {
+		compatible = "qcom,pm6150-rpmh-regulators";
+		qcom,pmic-id = "a";
+
+		vreg_s1a_1p1: smps1 {
+			regulator-min-microvolt = <1128000>;
+			regulator-max-microvolt = <1128000>;
+		};
+
+		vreg_s4a_1p0: smps4 {
+			regulator-min-microvolt = <824000>;
+			regulator-max-microvolt = <1120000>;
+		};
+
+		vreg_s5a_2p0: smps5 {
+			regulator-min-microvolt = <1744000>;
+			regulator-max-microvolt = <2040000>;
+		};
+
+		vreg_l1a_1p2: ldo1 {
+			regulator-min-microvolt = <1178000>;
+			regulator-max-microvolt = <1256000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l2a_1p0: ldo2 {
+			regulator-min-microvolt = <944000>;
+			regulator-max-microvolt = <1056000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l3a_1p0: ldo3 {
+			regulator-min-microvolt = <968000>;
+			regulator-max-microvolt = <1064000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l4a_0p8: ldo4 {
+			regulator-min-microvolt = <824000>;
+			regulator-max-microvolt = <928000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l5a_2p7: ldo5 {
+			regulator-min-microvolt = <2496000>;
+			regulator-max-microvolt = <3000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l6a_0p6: ldo6 {
+			regulator-min-microvolt = <568000>;
+			regulator-max-microvolt = <648000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l9a_0p6: ldo9 {
+			regulator-min-microvolt = <488000>;
+			regulator-max-microvolt = <800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l10a_1p8: ldo10 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1832000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l11a_1p8: ldo11 {
+			regulator-min-microvolt = <1696000>;
+			regulator-max-microvolt = <1904000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l12a_1p8: ldo12 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l13a_1p8: ldo13 {
+			regulator-min-microvolt = <1696000>;
+			regulator-max-microvolt = <1904000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l14a_1p8: ldo14 {
+			regulator-min-microvolt = <1728000>;
+			regulator-max-microvolt = <1832000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l15a_1p8: ldo15 {
+			regulator-min-microvolt = <1696000>;
+			regulator-max-microvolt = <1904000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l16a_2p7: ldo16 {
+			regulator-min-microvolt = <2496000>;
+			regulator-max-microvolt = <3304000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l17a_3p0: ldo17 {
+			regulator-min-microvolt = <2920000>;
+			regulator-max-microvolt = <3232000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l18a_2p8: ldo18 {
+			regulator-min-microvolt = <2496000>;
+			regulator-max-microvolt = <3304000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l19a_2p9: ldo19 {
+			regulator-min-microvolt = <2960000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+
+	pm6150l-rpmh-regulators {
+		compatible = "qcom,pm6150l-rpmh-regulators";
+		qcom,pmic-id = "c";
+
+		vreg_s8c_1p3: smps8 {
+			regulator-min-microvolt = <1120000>;
+			regulator-max-microvolt = <1408000>;
+		};
+
+		vreg_l1c_1p8: ldo1 {
+			regulator-min-microvolt = <1616000>;
+			regulator-max-microvolt = <1984000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l2c_1p3: ldo2 {
+			regulator-min-microvolt = <1168000>;
+			regulator-max-microvolt = <1304000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l3c_1p2: ldo3 {
+			regulator-min-microvolt = <1144000>;
+			regulator-max-microvolt = <1304000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l4c_1p8: ldo4 {
+			regulator-min-microvolt = <1648000>;
+			regulator-max-microvolt = <3304000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l5c_1p8: ldo5 {
+			regulator-min-microvolt = <1648000>;
+			regulator-max-microvolt = <3304000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l6c_2p9: ldo6 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2950000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7c_3p0: ldo7 {
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3312000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l8c_1p8: ldo8 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1904000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l9c_2p9: ldo9 {
+			regulator-min-microvolt = <2960000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l10c_3p3: ldo10 {
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3400000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l11c_3p3: ldo11 {
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3400000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_bob: bob {
+			regulator-min-microvolt = <3008000>;
+			regulator-max-microvolt = <3960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_AUTO>;
+		};
+	};
+};
+
+&pm6150l_lsid5 {
+                pm6150l_labibb: labibb@dc00 {
+                        compatible = "qcom,pmi8998-lab-ibb";
+                        status = "okay";
+
+                        ibb: ibb@dc00 {
+                                interrupts = <0x5 0xdc 0x2 IRQ_TYPE_EDGE_RISING>,
+                                             <0x5 0xdc 0x0 IRQ_TYPE_LEVEL_HIGH>;
+                                interrupt-names = "sc-err", "ocp";
+                        };
+
+                        lab: lab@de00 {
+                                interrupts = <0x5 0xde 0x1 IRQ_TYPE_EDGE_RISING>,
+                                             <0x5 0xde 0x0 IRQ_TYPE_LEVEL_LOW>;
+                                interrupt-names = "sc-err", "ocp";
+                        };
+                };
+};
+
+/* copy from sdm845-xiaomi */
+&ibb {
+        regulator-min-microvolt = <4600000>;
+        regulator-max-microvolt = <6000000>;
+        regulator-over-current-protection;
+        regulator-pull-down;
+        regulator-soft-start;
+        qcom,discharge-resistor-kohms = <300>;
+};
+
+&lab {
+        regulator-min-microvolt = <4600000>;
+        regulator-max-microvolt = <6000000>;
+        regulator-over-current-protection;
+        regulator-pull-down;
+        regulator-soft-start;
+};
+
+&pm6150l_labibb {
+	status = "okay";
+};
+
+&pm6150l_wled {
+	/delete-property/ interrupts;
+	/delete-property/ interrupt-names;
+	status = "okay";	
+};
+
+&dsi0 {
+	status = "okay";
+
+	vdda-supply = <&vreg_l3c_1p2>;
+	vddio-supply = <&vreg_l18a_2p8>;
+	vdds-supply = <&vreg_l18a_2p8>;
+
+	panel0: panel@0 {
+		compatible = "mdss,nt36675-tianma", "xiaomi,nt36675-tianma-dummy", "mdss,nt36675-tianma-fhd";
+
+		reg = <0>;
+
+		vdda-supply = <&vreg_l8c_1p8>;
+		vdd3p3-supply = <&vreg_l18a_2p8>;
+		vddio-supply = <&vreg_l18a_2p8>;
+
+		/* display_sde.dtsi
+                vddio-supply = <&L13A>;
+                vdda-3p3-supply = <&L18A>;
+		*/
+
+                /* cust_sde.dtsi
+                /delete-property/ vdda-3p3-supply;
+                vddio-supply = <&L18A>;
+                */
+
+                lab-supply = <&lab>;
+                ibb-supply = <&ibb>;
+#if 1
+		pinctrl-names = "default";
+//		pinctrl-0 = <&te_gpio &disp_pins>;
+		pinctrl-0 = <&disp_pins>;
+
+		/* according to panel-nt36675-tianma.c this gpio is finally low */
+		reset-gpios = <&pm6150l_gpio 3 GPIO_ACTIVE_LOW>;
+//		disp-te-gpio = <&tlmm 10 GPIO_ACTIVE_LOW>;
+#endif
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+				reg = <0>;
+				panel0_in: endpoint {
+					remote-endpoint = <&dsi0_out>;
+				};
+			};
+		};
+	};
+/*
+	ports {
+		port@1 {
+			dsi0_out: endpoint {
+				remote-endpoint = <&panel0_in>;
+				data-lanes = <0 1 2 3>;
+			};
+		};
+	};
+*/
+};
+
+&dsi0_out {
+        remote-endpoint = <&panel0_in>;
+        data-lanes = <0 1 2 3>;
+};
+
+&dsi_phy {
+	status = "okay";
+	vdds-supply = <&vreg_l4a_0p8>;
+};
+
+&mdp {
+	memory-region = <&splash_mem>;
+	status = "okay";
+};
+
+&mdss {
+	/*
+		to add headless msm_drv platform_driver support.
+	*/
+	compatible = "qcom,sc7180-mdss", "qcom,mdss";
+                        reg = <0 0x0ae00000 0 0x1000>, <0 0x0ae00000 0 0x1000>;
+                        reg-names = "mdss", "mdss_phys";
+
+	memory-region = <&splash_mem>;
+	status = "okay";
+};
+
+&mdp {
+			//override lut clk s dummy
+                                clocks = <&gcc GCC_DISP_HF_AXI_CLK>,
+                                         <&dispcc DISP_CC_MDSS_AHB_CLK>,
+                                         <&dispcc DISP_CC_MDSS_ROT_CLK>,
+                                         <&dummy_clk>, /*<&dispcc DISP_CC_MDSS_MDP_LUT_CLK>,*/
+                                         <&dispcc DISP_CC_MDSS_MDP_CLK>,
+                                         <&dispcc DISP_CC_MDSS_VSYNC_CLK>;
+                                clock-names = "bus", "iface", "rot", "lut", "core",
+                                              "vsync";
+};
+
+&adreno_smmu {
+	status = "okay";
+};
+
+&gpu {
+	compatible = "qcom,adreno-618.0", "qcom,adreno";
+	status = "okay";
+	zap-shader {
+		//memory-region = <&gpu_mem>;
+		//firmware-name = "qcom/a630_zap.mbn";
+		//firmware-name = "qcom/a615_zap.mdt";
+	};
+};
+
+&gmu {
+/*
+        clocks = <&gpucc GPU_CC_AHB_CLK>,
+                 <&gpucc GPU_CC_CX_GMU_CLK>,
+                 <&gpucc GPU_CC_CXO_CLK>,
+                 <&gcc GCC_DDRSS_GPU_AXI_CLK>,
+                 <&gcc GCC_GPU_MEMNOC_GFX_CLK>;
+        clock-names = "ahb", "gmu", "cxo", "axi", "memnoc";
+*/
+        status = "okay";
+};
+
+&mdss_dp {
+        status = "okay";
+};
+
+&panel0 {
+        status = "okay";
+};
+
+&apps_smmu {
+	status = "okay";
+};
+
+/* override with sm7125 own addr */
+&qfprom {
+	status = "disabled";
+};
+
+&soc {
+	qfprom0: efuse@780000 {
+		compatible = "qcom,sm7125-qfprom", "qcom,qfprom";
+		reg = <0 0x00780000 0 0x6310>;
+		status = "okay";
+
+                clocks = <&gcc GCC_SEC_CTRL_CLK_SRC>;
+                clock-names = "core";
+                #address-cells = <1>;
+                #size-cells = <1>;
+
+                vcc-supply = <&vreg_l11a_1p8>;
+
+	        qusb2_hstx_trim_new: hstx-trim@258 {
+			reg = <0x258 0x1>;
+			bits = <25 3>;
+	        };
+
+		/* 0x780000 0x6300 */
+                gpu_speed_bin_new: gpu_speed_bin@6300 {
+			reg = <0x6015 0x1>;
+			bits = <0 8>;
+                };
+	};
+};
+
+/* reassign nvmem cell */
+&usb_1_hsphy {
+	status = "okay";
+	nvmem-cells = <&qusb2_hstx_trim_new>;
+}; 
+
+/* reassign nvmem cell */
+&gpu {
+        status = "okay";
+        nvmem-cells = <&gpu_speed_bin_new>;
+};	
+
+&qspi {
+	status = "okay";
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&qspi_clk &qspi_cs0 &qspi_data01>;
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+		spi-tx-bus-width = <2>;
+		spi-rx-bus-width = <2>;
+
+		status = "disabled";
+	};
+};
+
+&qupv3_id_0 {
+	status = "okay";
+};
+
+&qupv3_id_1 {
+	status = "okay";
+};
+
+&remoteproc_mpss {
+	status = "okay";
+	compatible = "qcom,sc7180-mss-pil";
+	iommus = <&apps_smmu 0x461 0x0>, <&apps_smmu 0x444 0x3>;
+	memory-region = <&mba_mem &mpss_mem>;
+};
+
+&sdhc_1 {
+	status = "disabled";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_on>;
+	pinctrl-1 = <&sdc1_off>;
+	vmmc-supply = <&vreg_l19a_2p9>;
+	vqmmc-supply = <&vreg_l12a_1p8>;
+};
+
+&sdhc_2 {
+	status = "disabled";
+
+	pinctrl-names = "default","sleep";
+	pinctrl-0 = <&sdc2_on>;
+	pinctrl-1 = <&sdc2_off>;
+	vmmc-supply = <&vreg_l9c_2p9>;
+	vqmmc-supply = <&vreg_l6c_2p9>;
+
+	cd-gpios = <&tlmm 69 GPIO_ACTIVE_LOW>;
+};
+
+&uart3 {
+	status = "okay";
+
+	/delete-property/interrupts;
+	interrupts-extended = <&intc GIC_SPI 604 IRQ_TYPE_LEVEL_HIGH>,
+				<&tlmm 41 IRQ_TYPE_EDGE_FALLING>;
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-1 = <&qup_uart3_sleep>;
+
+	bluetooth: wcn3990-bt {
+		compatible = "qcom,wcn3990-bt";
+		vddio-supply = <&vreg_l10a_1p8>;
+		vddxo-supply = <&vreg_l1c_1p8>;
+		vddrf-supply = <&vreg_l2c_1p3>;
+		vddch0-supply = <&vreg_l10c_3p3>;
+		max-speed = <3200000>;
+		status = "disabled";
+	};
+};
+
+&uart8 {
+	status = "okay";
+};
+
+&usb_1 {
+	status = "okay";
+	qcom,select-utmi-as-pipe-clk;
+};
+
+&usb_1_dwc3 {
+	/delete-property/ snps,dis_enblslpm_quirk;
+
+	status = "okay";
+
+	//dr_mode = "peripherial";
+	dr_mode = "peripheral";
+
+	snps,hird-threshold = /bits/ 8 <0x10>;
+	snps,usb2-gadget-lpm-disable;
+	snps,dis_u2_susphy_quirk;
+	snps,is-utmi-l1-suspend;
+	snps,dis-u1-entry-quirk;
+	snps,dis-u2-entry-quirk;
+	snps,usb3_lpm_capable;
+	snps,has-lpm-erratum;
+	tx-fifo-resize;
+
+
+        maximum-speed = "high-speed";
+
+};
+
+&usb_1_hsphy {
+	status = "okay";
+
+	vdd-supply = <&vreg_l4a_0p8>;
+	vdda-pll-supply = <&vreg_l11a_1p8>;
+	vdda-phy-dpdm-supply = <&vreg_l17a_3p0>;
+	qcom,imp-res-offset-value = <8>;
+	qcom,preemphasis-level = <QUSB2_V2_PREEMPHASIS_15_PERCENT>;
+	qcom,preemphasis-width = <QUSB2_V2_PREEMPHASIS_WIDTH_HALF_BIT>;
+	qcom,bias-ctrl-value = <0x22>;
+	qcom,charge-ctrl-value = <3>;
+	qcom,hsdisc-trim-value = <0>;
+};
+
+&usb_1_qmpphy {
+	status = "okay";
+	vdda-phy-supply = <&vreg_l3c_1p2>;
+	vdda-pll-supply = <&vreg_l4a_0p8>;
+};
+
+&venus {
+	status = "okay";
+	//status = "disabled";
+	memory-region = <&venus_mem>;
+
+	video-firmware {
+		iommus = <&apps_smmu 0x0c42 0x0>;
+	};
+};
+
+&wifi {
+	status = "okay";
+
+	vdd-0.8-cx-mx-supply = <&vreg_l9a_0p6>;
+	vdd-1.8-xo-supply = <&vreg_l1c_1p8>;
+	vdd-1.3-rfa-supply = <&vreg_l2c_1p3>;
+	vdd-3.3-ch0-supply = <&vreg_l10c_3p3>;
+	vdd-3.3-ch1-supply = <&vreg_l11c_3p3>;
+	wifi-firmware {
+		iommus = <&apps_smmu 0xc2 0x1>;
+	};
+};
+
+/* PINCTRL - additions to nodes defined in sc7180.dtsi */
+
+&pm6150l_gpio {
+	disp_pins: disp-state {
+		pinconf {
+			pins = "gpio3";
+			function = PMIC_GPIO_FUNC_FUNC1;
+			qcom,drive-strength = <PMIC_GPIO_STRENGTH_MED>;
+			power-source = <0>;
+			bias-disable;
+			output-low;
+		};
+	};
+/*
+        key_vol_up_default: key-vol-stat {
+                        pins = "gpio2";
+                        function = "normal";
+                        input-enable;
+                        bias-pull-up;
+                        power-source = <0>;
+                };
+        };
+*/
+};
+
+&qspi_clk {
+	pinconf {
+		pins = "gpio63";
+		bias-disable;
+	};
+};
+
+&qspi_cs0 {
+	pinconf {
+		pins = "gpio68";
+		bias-disable;
+	};
+};
+
+&qspi_data01 {
+	pinconf {
+		pins = "gpio64", "gpio65";
+
+		/* High-Z when no transfers; nice to park the lines */
+		bias-pull-up;
+	};
+};
+
+&qup_i2c2_default {
+	pinconf {
+		pins = "gpio15", "gpio16";
+		drive-strength = <2>;
+
+		/* Has external pullup */
+		bias-disable;
+	};
+};
+
+&qup_i2c4_default {
+	pinconf {
+		pins = "gpio115", "gpio116";
+		drive-strength = <2>;
+
+		/* Has external pullup */
+		bias-disable;
+	};
+};
+
+&qup_i2c7_default {
+	pinconf {
+		pins = "gpio6", "gpio7";
+		drive-strength = <2>;
+
+		/* Has external pullup */
+		bias-disable;
+	};
+};
+
+&qup_i2c9_default {
+	pinconf {
+		pins = "gpio46", "gpio47";
+		drive-strength = <2>;
+
+		/* Has external pullup */
+		bias-disable;
+	};
+};
+
+&qup_uart3_default {
+	pinconf-cts {
+		/*
+		 * Configure a pull-down on CTS to match the pull of
+		 * the Bluetooth module.
+		 */
+		pins = "gpio38";
+		bias-pull-down;
+	};
+
+	pinconf-rts {
+		/* We'll drive RTS, so no pull */
+		pins = "gpio39";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	pinconf-tx {
+		/* We'll drive TX, so no pull */
+		pins = "gpio40";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	pinconf-rx {
+		/*
+		 * Configure a pull-up on RX. This is needed to avoid
+		 * garbage data when the TX pin of the Bluetooth module is
+		 * in tri-state (module powered off or not driving the
+		 * signal yet).
+		 */
+		pins = "gpio41";
+		bias-pull-up;
+	};
+};
+
+&qup_uart8_default {
+	pinconf-tx {
+		pins = "gpio44";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	pinconf-rx {
+		pins = "gpio45";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+};
+
+&qup_spi0_default {
+	pinconf {
+		pins = "gpio34", "gpio35", "gpio36", "gpio37";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
+
+&qup_spi6_default {
+	pinconf {
+		pins = "gpio59", "gpio60", "gpio61", "gpio62";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
+
+&qup_spi10_default {
+	pinconf {
+		pins = "gpio86", "gpio87", "gpio88", "gpio89";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
+
+&tlmm {
+	qup_uart3_sleep: qup-uart3-sleep {
+		pinmux {
+			pins = "gpio38", "gpio39",
+			       "gpio40", "gpio41";
+			function = "gpio";
+		};
+
+		pinconf-cts {
+			/*
+			 * Configure a pull-down on CTS to match the pull of
+			 * the Bluetooth module.
+			 */
+			pins = "gpio38";
+			bias-pull-down;
+		};
+
+		pinconf-rts {
+			/*
+			 * Configure pull-down on RTS. As RTS is active low
+			 * signal, pull it low to indicate the BT SoC that it
+			 * can wakeup the system anytime from suspend state by
+			 * pulling RX low (by sending wakeup bytes).
+			 */
+			 pins = "gpio39";
+			 bias-pull-down;
+		};
+
+		pinconf-tx {
+			/*
+			 * Configure pull-up on TX when it isn't actively driven
+			 * to prevent BT SoC from receiving garbage during sleep.
+			 */
+			pins = "gpio40";
+			bias-pull-up;
+		};
+
+		pinconf-rx {
+			/*
+			 * Configure a pull-up on RX. This is needed to avoid
+			 * garbage data when the TX pin of the Bluetooth module
+			 * is floating which may cause spurious wakeups.
+			 */
+			pins = "gpio41";
+			bias-pull-up;
+		};
+	};
+
+	sdc1_on: sdc1-on {
+		pinconf-clk {
+			pins = "sdc1_clk";
+			bias-disable;
+			drive-strength = <16>;
+		};
+
+		pinconf-cmd {
+			pins = "sdc1_cmd";
+			bias-pull-up;
+			drive-strength = <10>;
+		};
+
+		pinconf-data {
+			pins = "sdc1_data";
+			bias-pull-up;
+			drive-strength = <10>;
+		};
+
+		pinconf-rclk {
+			pins = "sdc1_rclk";
+			bias-pull-down;
+		};
+	};
+
+	sdc1_off: sdc1-off {
+		pinconf-clk {
+			pins = "sdc1_clk";
+			bias-disable;
+			drive-strength = <2>;
+		};
+
+		pinconf-cmd {
+			pins = "sdc1_cmd";
+			bias-pull-up;
+			drive-strength = <2>;
+		};
+
+		pinconf-data {
+			pins = "sdc1_data";
+			bias-pull-up;
+			drive-strength = <2>;
+		};
+
+		pinconf-rclk {
+			pins = "sdc1_rclk";
+			bias-pull-down;
+		};
+	};
+
+	sdc2_on: sdc2-on {
+		pinconf-clk {
+			pins = "sdc2_clk";
+			bias-disable;
+			drive-strength = <16>;
+		};
+
+		pinconf-cmd {
+			pins = "sdc2_cmd";
+			bias-pull-up;
+			drive-strength = <10>;
+		};
+
+		pinconf-data {
+			pins = "sdc2_data";
+			bias-pull-up;
+			drive-strength = <10>;
+		};
+
+		pinconf-sd-cd {
+			pins = "gpio69";
+			bias-pull-up;
+			drive-strength = <2>;
+		};
+	};
+
+	sdc2_off: sdc2-off {
+		pinconf-clk {
+			pins = "sdc2_clk";
+			bias-disable;
+			drive-strength = <2>;
+		};
+
+		pinconf-cmd {
+			pins = "sdc2_cmd";
+			bias-pull-up;
+			drive-strength = <2>;
+		};
+
+		pinconf-data {
+			pins = "sdc2_data";
+			bias-pull-up;
+			drive-strength = <2>;
+		};
+
+		pinconf-sd-cd {
+			pins = "gpio69";
+			bias-pull-up;
+			drive-strength = <2>;
+		};
+	};
+
+	te_gpio: te-default {
+               //mux {
+                        pins = "gpio10";
+                        function = "mdp_vsync";
+                        drive-strength = <2>;   /* 2 mA */
+                        bias-pull-down;         /* PULL DOWN */
+                //};
+	};
+
+                pmx_ts_active {
+                        ts_active: ts_active {
+                                mux {
+                                        pins = "gpio8", "gpio9";
+                                        function = "gpio";
+                                };
+
+                                config {
+                                        pins = "gpio8", "gpio9";
+                                        drive-strength = <8>;
+                                        bias-pull-up;
+                                };
+                        };
+                };
+
+                pmx_ts_int_suspend {
+                        ts_int_suspend: ts_int_suspend {
+                                mux {
+                                        pins = "gpio9";
+                                        function = "gpio";
+                                };
+
+                                config {
+                                        pins = "gpio9";
+                                        drive-strength = <2>;
+                                        bias-disable;
+                                };
+                        };
+                };
+
+                pmx_ts_reset_suspend {
+                        ts_reset_suspend: ts_reset_suspend {
+                                mux {
+                                        pins = "gpio8";
+                                        function = "gpio";
+                                };
+
+                                config {
+                                        pins = "gpio8";
+                                        drive-strength = <2>;
+                                        bias-disable;
+                                };
+                        };
+                };
+
+                pmx_ts_release {
+                        ts_release: ts_release {
+                                mux {
+                                        pins = "gpio9", "gpio8";
+                                        function = "gpio";
+                                };
+
+                                config {
+                                        pins = "gpio9", "gpio8";
+                                        drive-strength = <2>;
+                                        bias-disable;
+                                };
+                        };
+                };
+
+};
+
+&ipa {
+        status = "okay";
+        modem-init;
+};
+
+&pm6150_pon {
+                        pm6150_volumekey: volumekey {
+                                compatible = "qcom,pm8941-pwrkey";
+                                interrupts = <0x0 0x8 1 IRQ_TYPE_EDGE_BOTH>;
+                                debounce = <15625>;
+                                bias-pull-up;
+                                linux,code = <KEY_VOLUMEDOWN>;
+                        };
+};
+
+&spi11 {
+	status = "okay";
+
+	//nt36xxx_touch: i2c@
+	touchscreen@0 {
+		compatible = "novatek,NVT-ts-spi", "novatek,NVT-ts-spi", "novatek,nt36675-spi";
+		reg = <0>;
+
+		spi-max-frequency = <8000000>;
+		novatek,reset-gpio = <&tlmm 8 0x00>;
+		novatek,irq-gpio = <&tlmm 9 0x2001>;
+
+		/* 672C */
+		novatek,swrst-n8-addr = <0x03F0FE>;
+		novatek,spi-rd-fast-addr = <0x03F310>;
+
+		status = "okay";
+	};
+};
+
+&qupv3_id_0 { status = "okay"; };
+&qupv3_id_1 { status = "okay"; };
+
+#if 0
+/* Below are one-liner control status */
+&spi0      { status = "disabled"; };
+&spi1      { status = "disabled"; };
+&spi3      { status = "disabled"; };
+&spi5      { status = "disabled"; };
+&spi6      { status = "disabled"; };
+&spi8      { status = "disabled"; };
+
+&i2c1      { status = "disabled"; };
+&i2c2      { status = "disabled"; };
+&i2c3      { status = "disabled"; };
+&i2c5      { status = "disabled"; };
+&i2c6      { status = "disabled"; };
+&i2c7      { status = "disabled"; };
+&i2c8      { status = "disabled"; };
+&i2c10     { status = "disabled"; };
+&i2c11     { status = "disabled"; };
+
+&uart0    { status = "disabled" ;};
+&uart1    { status = "disabled" ;};
+&uart2    { status = "disabled" ;};
+&uart3    { status = "disabled" ;}; //enabled default to bt
+&uart4    { status = "disabled" ;};
+&uart5    { status = "disabled" ;};
+&uart6    { status = "disabled" ;};
+&uart7    { status = "disabled" ;};
+&uart8    { status = "disabled" ;}; //enabled not sure for what
+&uart9    { status = "disabled" ;};
+&uart10   { status = "disabled" ;};
+&uart11   { status = "disabled" ;};
+#endif
+
+//&qspi { status = "disabled"; };
+//&qupv3_id_0 { status = "disabled"; };
+//&qupv3_id_1 { status = "disabled"; };
+
+///{ smp2p-mpss { status = "disabled" ;}; };
+///{ smp2p-lpass { status = "disabled" ;}; };
+///{ smp2p-cdsp { status = "disabled" ;}; };
+
+//&qfprom0 { status = "disabled" ;};
+//&soc { cpufreq@18323000 { status = "disabled" ;};      };
+
+//&dsi_phy { status = "disabled"; };
+//&mdp { status = "disabled"; };
+
+/* disable all ref to dp */
+//&mdp { ports { /delete-node/ port@2; }; }; 
+//&dp_in { /delete-property/ remote-endpoint; };
+
+//&mdss { status = "disabled"; };
+//&adreno_smmu { status = "disabled"; };
+//&gpu { status = "disabled"; };
+//&gmu { status = "disabled"; };
+//&apps_smmu { status = "disabled"; };
+&mdss_dp { status = "disabled"; };
+//&panel0 { status = "disabled"; };
+
+/* it stalls 30s for fw loading and prevent gpu fw loading afterward */
+&venus { status = "disabled"; };
+&framebuffer { status = "disabled"; };
+
+//&ipa { status = "disabled"; };
+/delete-node/ &rmtfs_mem ;
+//&wifi { status = "disabled"; };
+
+//&usb_1 {status = "disabled";};
+//&usb_1_dwc3 {status = "disabled";};
+//&usb_1_hsphy {status = "disabled"; };
+
+/* boot blocking obstacle, atoll soc does not handle this addr as clk */
+//&soc { clock-controller@63000000       { status = "disabled" ;};      };
+&lpass_hm { status = "disabled" ;}; //same as above
+/**************************/
+
+//&soc { clock-controller@62d00000       { status = "disabled" ;};      };
+//&soc { clock-controller@af00000        { status = "disabled" ;};      };
+
+//&soc { clock-controller@ad00000        { status = "disabled" ;};      };
+//&soc { clock-controller@ab00000        { status = "disabled" ;};      };
+//&soc { clock-controller@5090000        { status = "disabled" ;};      };
+//&soc { geniqup@ac0000                  { status = "disabled" ;};      };
+//&soc { geniqup@8c0000                  { status = "disabled" ;};      };
+
+&pm6150l_labibb { status = "disabled"; };
+//&pm6150l_wled { status = "disabled"; };
diff --git a/arch/arm64/configs/sm7150.config b/arch/arm64/configs/sm7150.config
new file mode 100644
index 000000000000..4c4749fc94aa
--- /dev/null
+++ b/arch/arm64/configs/sm7150.config
@@ -0,0 +1,830 @@
+# Qualcomm Snapdragon SM7150 config fragment
+CONFIG_LOCALVERSION="-sm7150"
+# CONFIG_LOCALVERSION_AUTO is not set
+
+# Xiaomi Mi 9T / Redmi K20
+CONFIG_DRM_PANEL_SAMSUNG_EA_F10=y
+
+# Xiaomi POCO X3 NFC
+CONFIG_DRM_PANEL_HUAXING_NT36672C=y
+CONFIG_SND_SOC_TAS2562=y
+CONFIG_TOUCHSCREEN_NT36672C_HOSTDL_SPI=y
+CONFIG_TYPEC_MUX_FSA4480=m
+
+# SOC
+CONFIG_NR_CPUS=8
+CONFIG_SCHED_CLUSTER=y
+CONFIG_SCSI_UFS_QCOM=y
+CONFIG_QCOM_LLCC=y
+CONFIG_QCOM_RMTFS_MEM=y
+CONFIG_QCOM_SOCINFO=y
+CONFIG_QCOM_APR=y
+CONFIG_POWER_RESET_QCOM_PON=y
+CONFIG_QCOM_SPMI_TEMP_ALARM=y
+CONFIG_QCOM_SPMI_ADC_TM5=y
+CONFIG_QCOM_GPI_DMA=y
+
+CONFIG_PINCTRL_SM7150=y
+CONFIG_SC_GPUCC_7180=y
+CONFIG_SM_DISPCC_7150=y
+CONFIG_SM_GCC_7150=y
+
+# Sound
+CONFIG_SND_SOC_LPASS_RX_MACRO=m
+CONFIG_SND_SOC_LPASS_TX_MACRO=m
+
+# Remoteproc
+CONFIG_SLIMBUS=y
+CONFIG_SLIM_QCOM_CTRL=y
+CONFIG_SLIM_QCOM_NGD_CTRL=y
+CONFIG_REMOTEPROC_CDEV=y
+
+# Graphics
+CONFIG_DRM=y
+CONFIG_FB_SIMPLE=y
+CONFIG_DRM_MSM=y
+
+# Power management
+CONFIG_PM_AUTOSLEEP=y
+CONFIG_PM_WAKELOCKS=y
+
+# Misc useful things
+CONFIG_SCSI_SCAN_ASYNC=y
+
+# Needed for mounting userdata on android
+CONFIG_QFMT_V2=y
+CONFIG_PSTORE=y
+CONFIG_PSTORE_CONSOLE=y
+CONFIG_PSTORE_RAM=y
+
+# HID/Input
+CONFIG_HID_GENERIC=m
+CONFIG_UHID=m
+CONFIG_USB_HID=m
+CONFIG_INPUT_EVDEV=y
+CONFIG_BT_HIDP=m
+CONFIG_INPUT_JOYDEV=m
+
+# USB
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_F_HID=y
+
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_ACTIVITY=y
+
+CONFIG_RPMSG_CHAR=y
+# Always load RFCOMM and BNEP as modules so they initialize properly
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HS=y
+CONFIG_BT_LE=y
+CONFIG_HID_BATTERY_STRENGTH=y
+CONFIG_HIDRAW=y
+CONFIG_QCOM_FASTRPC=m
+CONFIG_QCOM_SPMI_ADC5=y
+CONFIG_PHY_QCOM_QMP=y
+CONFIG_PHY_QCOM_QUSB2=y
+CONFIG_LEDS_CLASS_FLASH=y
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_TCP_CONG_WESTWOOD=y
+CONFIG_DEFAULT_WESTWOOD=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_F2FS_FS=y
+CONFIG_NLS_UTF8=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_FAT_DEFAULT_UTF8=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_SYN_COOKIES=y
+CONFIG_UEVENT_HELPER=y
+CONFIG_INPUT_UINPUT=m
+CONFIG_PSTORE_PMSG=y
+CONFIG_U_SERIAL_CONSOLE=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+# Anbox
+CONFIG_BRIDGE_NETFILTER=y
+CONFIG_CHECKPOINT_RESTORE=y
+CONFIG_PACKET_DIAG=y
+CONFIG_UNIX_DIAG=y
+CONFIG_NETLINK_DIAG=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_SQUASHFS_XATTR=y
+CONFIG_SQUASHFS_LZ4=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+
+# Waydroid
+CONFIG_PSI=y
+
+# WLAN debugging
+CONFIG_ATH10K_DEBUG=y
+CONFIG_ATH10K_DEBUGFS=y
+CONFIG_ATH10K_SPECTRAL=y
+
+CONFIG_NET_SCH_HTB=y
+CONFIG_NET_SCH_PRIO=y
+CONFIG_NET_SCH_MULTIQ=y
+
+# Debugging stuff
+CONFIG_STACKTRACE=y
+
+#pmOS Related
+CONFIG_VT=y
+CONFIG_CRYPTO_XTS=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_DM_CRYPT=y
+CONFIG_BINFMT_MISC=m
+
+CONFIG_NF_TABLES=m
+CONFIG_NF_TABLES_INET=y
+CONFIG_NFT_CT=m
+CONFIG_NFT_COUNTER=m
+CONFIG_NFT_LOG=m
+CONFIG_NFT_LIMIT=m
+CONFIG_NFT_MASQ=m
+CONFIG_NFT_NAT=m
+CONFIG_NFT_REJECT=m
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NF_TABLES_IPV6=y
+
+CONFIG_WIREGUARD=m
+CONFIG_DRM_GUD=m
+
+# pmos containers kconfig
+CONFIG_CGROUP_FREEZER=y
+CONFIG_NETFILTER_XT_MATCH_IPVS=m
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_DUMMY=m
+CONFIG_BLK_DEV_THROTTLING=y
+CONFIG_NET_CLS_CGROUP=m
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_IP_VS=m
+CONFIG_IP_VS_NFCT=y
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_IP_VS_RR=y
+CONFIG_EXT4_FS_SECURITY=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_DM_THIN_PROVISIONING=y
+CONFIG_VXLAN=m
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_IPVLAN=m
+
+# pmOS ZRAM kconfig
+CONFIG_ZSMALLOC=m
+CONFIG_ZSMALLOC_STAT=y
+CONFIG_ZRAM=m
+CONFIG_ZRAM_MEMORY_TRACKING=y
+CONFIG_CRYPTO_LZ4=m
+CONFIG_LZ4_COMPRESS=m
+CONFIG_CRYPTO_LZO=m
+CONFIG_CRYPTO_ZSTD=m
+
+# pmOS iwd kconfig
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_KEY_DH_OPERATIONS=y
+CONFIG_CRYPTO_KPP=y
+CONFIG_PKCS8_PRIVATE_KEY_PARSER=y
+
+# LEDs
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#Sony PlayStation controllers
+CONFIG_HID_SONY=m
+CONFIG_SONY_FF=y
+
+# Disable all unrelated stuffs afaik
+CONFIG_ACPI=n
+CONFIG_VIRTUALIZATION=n
+CONFIG_PSTORE_DEFLATE_COMPRESS=n
+CONFIG_HIBERNATION=n
+CONFIG_FW_LOADER_USER_HELPER=n
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=n
+CONFIG_BLK_DEV_NVME=n
+CONFIG_ATA=n
+CONFIG_MTD=n
+CONFIG_SRAM=n
+CONFIG_MEGARAID_SAS=n
+CONFIG_EEPROM_AT25=n
+CONFIG_SCSI_MPT3SAS=n
+CONFIG_BLK_DEV_MD=n
+CONFIG_DM_MIRROR=n
+CONFIG_DM_ZERO=n
+CONFIG_EXT2_FS=n
+CONFIG_EXT3_FS=n
+CONFIG_BTRFS_FS=n
+CONFIG_USB_DWC2=n
+CONFIG_USB_CHIPIDEA=n
+CONFIG_USB_MUSB_HDRC=n
+CONFIG_USB_ISP1760=n
+CONFIG_USB_HSIC_USB3503=n
+CONFIG_USB_NET_PLUSB=n
+CONFIG_TYPEC_FUSB302=n
+CONFIG_EXTCON_PTN5150=n
+CONFIG_REALTEK_PHY=n
+CONFIG_NET_VENDOR_NI=n
+CONFIG_NET_9P=n
+CONFIG_CAN=n
+CONFIG_BNX2X=n
+CONFIG_MACB=n
+CONFIG_IGB=n
+CONFIG_IGBVF=n
+CONFIG_SMC91X=n
+CONFIG_MLX4_EN=n
+CONFIG_MLX5_CORE=n
+CONFIG_STMMAC_ETH=n
+CONFIG_ATL1C=n
+CONFIG_BRCMFMAC=n
+CONFIG_WL18XX=n
+CONFIG_WLCORE=n
+CONFIG_ATH10K_PCI=n
+CONFIG_NET_SCH_CBS=n
+CONFIG_NET_SCH_ETF=n
+CONFIG_NET_SCH_TAPRIO=n
+CONFIG_NET_SCH_MQPRIO=n
+CONFIG_NET_CLS_BASIC=n
+CONFIG_NET_CLS_FLOWER=n
+CONFIG_NET_CLS_ACT=n
+CONFIG_NET_ACT_GACT=n
+CONFIG_NET_ACT_MIRRED=n
+CONFIG_NET_ACT_GATE=n
+CONFIG_MDIO_BUS_MUX_MMIOREG=n
+CONFIG_MDIO_BUS_MUX_MULTIPLEXER=n
+CONFIG_SND_SOC_ES7134=n
+CONFIG_SND_SOC_ES7241=n
+CONFIG_SND_SOC_TAS571X=n
+CONFIG_SND_SOC_SIMPLE_AMPLIFIER=n
+CONFIG_GPIO_DWAPB=n
+CONFIG_COMMON_CLK_XGENE=n
+CONFIG_SENSORS_ARM_SCPI=n
+CONFIG_TCG_TPM=n
+CONFIG_BATTERY_SBS=n
+CONFIG_REGULATOR_VCTRL=n
+CONFIG_SND_SOC_MAX98357A=n
+CONFIG_SND_SOC_RL6231=n
+CONFIG_THUNDER_NIC_BGX=n
+CONFIG_THUNDER_NIC_RGX=n
+CONFIG_MDIO_THUNDER=n
+CONFIG_CAVIUM_ERRATUM_22375=n
+CONFIG_CAVIUM_ERRATUM_23154=n
+CONFIG_CAVIUM_ERRATUM_27456=n
+CONFIG_CAVIUM_ERRATUM_30115=n
+CONFIG_CAVIUM_TX2_ERRATUM_219=n
+CONFIG_HW_RANDOM_CAVIUM=n
+CONFIG_EEPROM_AT24=n
+CONFIG_NET_DSA=n
+CONFIG_AQUANTIA_PHY=n
+CONFIG_MICROSEMI_PHY=n
+CONFIG_VITESSE_PHY=n
+CONFIG_I2C_MUX_PCA954x=n
+CONFIG_SND_SOC_PCM3168A_I2C=n
+CONFIG_SENSORS_LM90=n
+CONFIG_SENSORS_INA2XX=n
+CONFIG_RTC_DRV_DS3232=n
+CONFIG_SPI_NXP_FLEXSPI=n
+CONFIG_GPIO_MAX732X=n
+CONFIG_SENSORS_ISL29018=n
+CONFIG_MPL3115=n
+CONFIG_MFD_ROHM_BD718XX=n
+CONFIG_ARM_SBSA_WATCHDOG=n
+CONFIG_ARM_SMC_WATCHDOG=n
+CONFIG_REGULATOR_PCA9450=n
+CONFIG_REGULATOR_PFUZE100=n
+CONFIG_DRM_PANEL_RAYDIUM_RM67191=n
+CONFIG_DRM_PANEL_SITRONIX_ST7703=n
+CONFIG_PHY_MIXEL_MIPI_DPHY=n
+CONFIG_DRM_NWL_MIPI_DSI=n
+CONFIG_DRM_MXSFB=n
+CONFIG_SND_SOC_FSL_SAI=n
+CONFIG_SND_SOC_FSL_ASRC=n
+CONFIG_SND_SOC_FSL_MICFIL=n
+CONFIG_SND_SOC_FSL_AUDMIX=n
+CONFIG_SND_SOC_FSL_SPDIF=n
+CONFIG_SND_SOC_WM8904=n
+CONFIG_RTC_DRV_RV8803=n
+CONFIG_RTC_DRV_DS1307=n
+CONFIG_RTC_DRV_PCF85363=n
+CONFIG_RTC_DRV_PCF2127=n
+CONFIG_PHY_FSL_IMX8MQ_USB=n
+CONFIG_FUJITSU_ERRATUM_010001=n
+CONFIG_PCI_PASID=n
+CONFIG_UACCE=n
+CONFIG_SPI_CADENCE_QUADSPI=n
+CONFIG_DW_WATCHDOG=n
+CONFIG_NOP_USB_XCEIV=n
+CONFIG_SURFACE_PLATFORMS=n
+CONFIG_GPIO_PCA953X=n
+CONFIG_BACKLIGHT_LP855X=n
+CONFIG_MFD_MAX77620=n
+CONFIG_SENSORS_PWM_FAN=n
+CONFIG_SENSORS_INA3221=n
+CONFIG_REGULATOR_MAX8973=n
+CONFIG_USB_CONN_GPIO=n
+CONFIG_MICREL_PHY=n
+CONFIG_MFD_BD9571MWV=n
+CONFIG_DRM_PANEL_LVDS=n
+CONFIG_DRM_RCAR_LVDS=n
+CONFIG_COMMON_CLK_VC5=n
+CONFIG_CRYPTO_DEV_CCREE=n
+CONFIG_VIDEO_IMX219=n
+CONFIG_VIDEO_OV5645=n
+CONFIG_SND_SOC_AK4613=n
+CONFIG_SND_SIMPLE_CARD=n
+CONFIG_SND_SIMPLE_CARD_UTILS=n
+CONFIG_SND_AUDIO_GRAPH_CARD=n
+CONFIG_TYPEC_HD3SS3220=n
+CONFIG_RTC_DRV_RX8581=n
+CONFIG_COMMON_CLK_CS2000_CP=n
+CONFIG_KEYBOARD_ADC=n
+CONFIG_REGULATOR_FAN53555=n
+CONFIG_TOUCHSCREEN_ATMEL_MXT=n
+CONFIG_RTC_DRV_HYM8563=n
+CONFIG_MFD_SEC_CORE=n
+CONFIG_PL330_DMA=n
+CONFIG_GPIO_MB86S7X=n
+CONFIG_MMC_SDHCI_F_SDH30=n
+CONFIG_MMC_SDHCI_CADENCE=n
+CONFIG_SOCIONEXT_SYNQUACER_PREITS=n
+CONFIG_NET_VENDOR_SOCIONEXT=n
+CONFIG_ARCH_ACTIONS=n
+CONFIG_ARCH_AGILEX=n
+CONFIG_ARCH_N5X=n
+CONFIG_ARCH_SUNXI=n
+CONFIG_ARCH_ALPINE=n
+CONFIG_ARCH_APPLE=n
+CONFIG_ARCH_BCM2835=n
+CONFIG_ARCH_BCM4908=n
+CONFIG_ARCH_BCM_IPROC=n
+CONFIG_ARCH_BERLIN=n
+CONFIG_ARCH_BRCMSTB=n
+CONFIG_ARCH_EXYNOS=n
+CONFIG_ARCH_K3=n
+CONFIG_ARCH_LAYERSCAPE=n
+CONFIG_ARCH_LG1K=n
+CONFIG_ARCH_HISI=n
+CONFIG_ARCH_KEEMBAY=n
+CONFIG_ARCH_MEDIATEK=n
+CONFIG_ARCH_MESON=n
+CONFIG_ARCH_MVEBU=n
+CONFIG_ARCH_MXC=n
+CONFIG_ARCH_RENESAS=n
+CONFIG_ARCH_ROCKCHIP=n
+CONFIG_ARCH_S32=n
+CONFIG_ARCH_SEATTLE=n
+CONFIG_ARCH_INTEL_SOCFPGA=n
+CONFIG_ARCH_SYNQUACER=n
+CONFIG_ARCH_TEGRA=n
+CONFIG_ARCH_SPRD=n
+CONFIG_ARCH_THUNDER=n
+CONFIG_ARCH_THUNDER2=n
+CONFIG_ARCH_UNIPHIER=n
+CONFIG_ARCH_VEXPRESS=n
+CONFIG_ARCH_VISCONTI=n
+CONFIG_ARCH_XGENE=n
+CONFIG_ARCH_ZX=n
+CONFIG_ARCH_ZYNQMP=n
+CONFIG_ARM_ALLWINNER_SUN50I_CPUFREQ_NVMEM=n
+CONFIG_ARM_ARMADA_37XX_CPUFREQ=n
+CONFIG_ARM_IMX_CPUFREQ_DT=n
+CONFIG_ARM_RASPBERRYPI_CPUFREQ=n
+CONFIG_ARM_TEGRA186_CPUFREQ=n
+CONFIG_QORIQ_CPUFREQ=n
+CONFIG_RASPBERRYPI_FIRMWARE=n
+CONFIG_INTEL_STRATIX10_SERVICE=n
+CONFIG_INTEL_STRATIX10_RSU=n
+CONFIG_IMX_SCU=n
+CONFIG_IMX_SCU_PD=n
+CONFIG_CAN_RCAR=n
+CONFIG_CAN_RCAR_CANFD=n
+CONFIG_CAN_FLEXCAN=n
+CONFIG_PCI_AARDVARK=n
+CONFIG_PCI_TEGRA=n
+CONFIG_PCIE_RCAR_HOST=n
+CONFIG_PCIE_RCAR_EP=n
+CONFIG_PCI_XGENE=n
+CONFIG_PCIE_ALTERA=n
+CONFIG_PCIE_ALTERA_MSI=n
+CONFIG_PCI_HOST_THUNDER_PEM=n
+CONFIG_PCI_HOST_THUNDER_ECAM=n
+CONFIG_PCIE_ROCKCHIP_HOST=n
+CONFIG_PCIE_BRCMSTB=n
+CONFIG_PCI_IMX6=n
+CONFIG_PCI_LAYERSCAPE=n
+CONFIG_PCIE_LAYERSCAPE_GEN4=n
+CONFIG_PCI_HISI=n
+CONFIG_PCIE_ARMADA_8K=n
+CONFIG_PCIE_KIRIN=n
+CONFIG_PCIE_HISI_STB=n
+CONFIG_PCIE_TEGRA194_HOST=n
+CONFIG_HISILICON_LPC=n
+CONFIG_FSL_MC_BUS=n
+CONFIG_TEGRA_ACONNECT=n
+CONFIG_MTD_CFI_INTELEXT=n
+CONFIG_MTD_CFI_AMDSTD=n
+CONFIG_MTD_CFI_STAA=n
+CONFIG_MTD_SST25L=n
+CONFIG_MTD_NAND_DENALI_DT=n
+CONFIG_MTD_NAND_MARVELL=n
+CONFIG_MTD_NAND_FSL_IFC=n
+CONFIG_SCSI_HISI_SAS=n
+CONFIG_SCSI_HISI_SAS_PCI=n
+CONFIG_SCSI_UFS_HISI=n
+CONFIG_SCSI_UFS_EXYNOS=n
+CONFIG_AHCI_CEVA=n
+CONFIG_AHCI_MVEBU=n
+CONFIG_AHCI_XGENE=n
+CONFIG_AHCI_QORIQ=n
+CONFIG_SATA_SIL24=n
+CONFIG_SATA_RCAR=n
+CONFIG_FSL_FMAN=n
+CONFIG_FSL_DPAA_ETH=n
+CONFIG_FSL_DPAA2_ETH=n
+CONFIG_FSL_ENETC=n
+CONFIG_FSL_ENETC_VF=n
+CONFIG_FSL_ENETC_QOS=n
+CONFIG_HIX5HD2_GMAC=n
+CONFIG_HNS_DSAF=n
+CONFIG_HNS_ENET=n
+CONFIG_HNS3=n
+CONFIG_HNS3_HCLGE=n
+CONFIG_HNS3_ENET=n
+CONFIG_SERIAL_MESON=n
+CONFIG_SERIAL_MESON_CONSOLE=n
+CONFIG_SERIAL_SAMSUNG=n
+CONFIG_SERIAL_SAMSUNG_CONSOLE=n
+CONFIG_SERIAL_TEGRA=n
+CONFIG_SERIAL_TEGRA_TCU=n
+CONFIG_SERIAL_IMX=n
+CONFIG_SERIAL_IMX_CONSOLE=n
+CONFIG_SERIAL_XILINX_PS_UART=n
+CONFIG_SERIAL_XILINX_PS_UART_CONSOLE=n
+CONFIG_SERIAL_FSL_LPUART=n
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=n
+CONFIG_SERIAL_FSL_LINFLEXUART=n
+CONFIG_SERIAL_FSL_LINFLEXUART_CONSOLE=n
+CONFIG_SERIAL_MVEBU_UART=n
+CONFIG_SERIAL_OWL=n
+CONFIG_I2C_BCM2835=n
+CONFIG_I2C_DESIGNWARE_PLATFORM=n
+CONFIG_I2C_IMX=n
+CONFIG_I2C_IMX_LPI2C=n
+CONFIG_I2C_MESON=n
+CONFIG_I2C_MT65XX=n
+CONFIG_I2C_MV64XXX=n
+CONFIG_I2C_OMAP=n
+CONFIG_I2C_OWL=n
+CONFIG_I2C_PXA=n
+CONFIG_I2C_RK3X=n
+CONFIG_I2C_SH_MOBILE=n
+CONFIG_I2C_TEGRA=n
+CONFIG_I2C_UNIPHIER_F=n
+CONFIG_I2C_RCAR=n
+CONFIG_SPI_ARMADA_3700=n
+CONFIG_SPI_BCM2835=n
+CONFIG_SPI_BCM2835AUX=n
+CONFIG_SPI_DESIGNWARE=n
+CONFIG_SPI_DW_DMA=n
+CONFIG_SPI_DW_MMIO=n
+CONFIG_SPI_FSL_LPSPI=n
+CONFIG_SPI_FSL_QUADSPI=n
+CONFIG_SPI_IMX=n
+CONFIG_SPI_FSL_DSPI=n
+CONFIG_SPI_MESON_SPICC=n
+CONFIG_SPI_MESON_SPIFC=n
+CONFIG_SPI_ORION=n
+CONFIG_SPI_PL022=n
+CONFIG_SPI_ROCKCHIP=n
+CONFIG_SPI_RPCIF=n
+CONFIG_SPI_S3C64XX=n
+CONFIG_SPI_SH_MSIOF=n
+CONFIG_SPI_SUN6I=n
+CONFIG_PINCTRL_MAX77620=n
+CONFIG_PINCTRL_OWL=n
+CONFIG_PINCTRL_S700=n
+CONFIG_PINCTRL_S900=n
+CONFIG_PINCTRL_IMX8MM=n
+CONFIG_PINCTRL_IMX8MN=n
+CONFIG_PINCTRL_IMX8MP=n
+CONFIG_PINCTRL_IMX8MQ=n
+CONFIG_PINCTRL_IMX8QM=n
+CONFIG_PINCTRL_IMX8QXP=n
+CONFIG_PINCTRL_IMX8DXL=n
+CONFIG_GPIO_ALTERA=n
+CONFIG_GPIO_DAVINCI=n
+CONFIG_GPIO_MPC8XXX=n
+CONFIG_GPIO_MXC=n
+CONFIG_GPIO_PL061=n
+CONFIG_GPIO_RCAR=n
+CONFIG_GPIO_UNIPHIER=n
+CONFIG_GPIO_VISCONTI=n
+CONFIG_GPIO_XGENE=n
+CONFIG_GPIO_XGENE_SB=n
+CONFIG_GPIO_PCA953X_IRQ=n
+CONFIG_GPIO_BD9571MWV=n
+CONFIG_GPIO_MAX77620=n
+CONFIG_GPIO_SL28CPLD=n
+CONFIG_ROCKCHIP_IODOMAIN=n
+CONFIG_POWER_RESET_XGENE=n
+CONFIG_POWER_RESET_SYSCON=n
+CONFIG_GNSS_MTK_SERIAL=n
+CONFIG_SENSORS_RASPBERRYPI_HWMON=n
+CONFIG_SENSORS_SL28CPLD=n
+CONFIG_QORIQ_THERMAL=n
+CONFIG_SUN8I_THERMAL=n
+CONFIG_IMX_SC_THERMAL=n
+CONFIG_IMX8MM_THERMAL=n
+CONFIG_ROCKCHIP_THERMAL=n
+CONFIG_RCAR_THERMAL=n
+CONFIG_RCAR_GEN3_THERMAL=n
+CONFIG_ARMADA_THERMAL=n
+CONFIG_BCM2711_THERMAL=n
+CONFIG_BCM2835_THERMAL=n
+CONFIG_BRCMSTB_THERMAL=n
+CONFIG_EXYNOS_THERMAL=n
+CONFIG_TEGRA_BPMP_THERMAL=n
+CONFIG_TEGRA_SOCTHERM=n
+CONFIG_UNIPHIER_THERMAL=n
+CONFIG_SL28CPLD_WATCHDOG=n
+CONFIG_ARM_SP805_WATCHDOG=n
+CONFIG_S3C2410_WATCHDOG=n
+CONFIG_SUNXI_WATCHDOG=n
+CONFIG_IMX2_WDT=n
+CONFIG_IMX_SC_WDT=n
+CONFIG_MESON_GXBB_WATCHDOG=n
+CONFIG_MESON_WATCHDOG=n
+CONFIG_RENESAS_WDT=n
+CONFIG_UNIPHIER_WATCHDOG=n
+CONFIG_BCM2835_WDT=n
+CONFIG_MFD_ALTERA_SYSMGR=n
+CONFIG_MFD_AXP20X_I2C=n
+CONFIG_MFD_AXP20X_RSB=n
+CONFIG_MFD_EXYNOS_LPASS=n
+CONFIG_MFD_HI6421_PMIC=n
+CONFIG_MFD_HI655X_PMIC=n
+CONFIG_MFD_MT6397=n
+CONFIG_MFD_RK808=n
+CONFIG_MFD_SL28CPLD=n
+CONFIG_REGULATOR_AXP20X=n
+CONFIG_REGULATOR_BD718XX=n
+CONFIG_REGULATOR_BD9571MWV=n
+CONFIG_REGULATOR_HI6421V530=n
+CONFIG_REGULATOR_HI655X=n
+CONFIG_REGULATOR_MAX77620=n
+CONFIG_REGULATOR_MP8859=n
+CONFIG_REGULATOR_MT6358=n
+CONFIG_REGULATOR_MT6397=n
+CONFIG_REGULATOR_PF8X00=n
+CONFIG_REGULATOR_RK808=n
+CONFIG_REGULATOR_S2MPS11=n
+CONFIG_REGULATOR_TPS65132=n
+CONFIG_IR_MESON=n
+CONFIG_IR_SUNXI=n
+CONFIG_MEDIA_ANALOG_TV_SUPPORT=n
+CONFIG_MEDIA_DIGITAL_TV_SUPPORT=n
+CONFIG_MEDIA_SDR_SUPPORT=n
+CONFIG_VIDEO_RCAR_CSI2=n
+CONFIG_VIDEO_RCAR_VIN=n
+CONFIG_VIDEO_SUN6I_CSI=n
+CONFIG_VIDEO_SAMSUNG_S5P_JPEG=n
+CONFIG_VIDEO_SAMSUNG_S5P_MFC=n
+CONFIG_VIDEO_SAMSUNG_EXYNOS_GSC=n
+CONFIG_VIDEO_RENESAS_FDP1=n
+CONFIG_VIDEO_RENESAS_FCP=n
+CONFIG_VIDEO_RENESAS_VSP1=n
+CONFIG_SDR_PLATFORM_DRIVERS=n
+CONFIG_VIDEO_RCAR_DRIF=n
+CONFIG_DRM_I2C_NXP_TDA998X=n
+CONFIG_DRM_MALI_DISPLAY=n
+CONFIG_DRM_NOUVEAU=n
+CONFIG_DRM_EXYNOS=n
+CONFIG_DRM_EXYNOS5433_DECON=n
+CONFIG_DRM_EXYNOS7_DECON=n
+CONFIG_DRM_EXYNOS_DSI=n
+CONFIG_DRM_EXYNOS_HDMI=n
+CONFIG_DRM_EXYNOS_MIC=n
+CONFIG_DRM_ROCKCHIP=n
+CONFIG_ROCKCHIP_ANALOGIX_DP=n
+CONFIG_ROCKCHIP_CDN_DP=n
+CONFIG_ROCKCHIP_DW_HDMI=n
+CONFIG_ROCKCHIP_DW_MIPI_DSI=n
+CONFIG_ROCKCHIP_INNO_HDMI=n
+CONFIG_ROCKCHIP_LVDS=n
+CONFIG_DRM_RCAR_DU=n
+CONFIG_DRM_RCAR_DW_HDMI=n
+CONFIG_DRM_SUN4I=n
+CONFIG_DRM_SUN6I_DSI=n
+CONFIG_DRM_SUN8I_DW_HDMI=n
+CONFIG_DRM_SUN8I_MIXER=n
+CONFIG_DRM_TEGRA=n
+CONFIG_DRM_PARADE_PS8640=n
+CONFIG_DRM_SII902X=n
+CONFIG_DRM_THINE_THC63LVD1024=n
+CONFIG_DRM_TI_SN65DSI86=n
+CONFIG_DRM_VC4=n
+CONFIG_DRM_ETNAVIV=n
+CONFIG_DRM_HISI_HIBMC=n
+CONFIG_DRM_HISI_KIRIN=n
+CONFIG_DRM_MEDIATEK=n
+CONFIG_DRM_MEDIATEK_HDMI=n
+CONFIG_DRM_MESON=n
+CONFIG_DRM_PL111=n
+CONFIG_DRM_LIMA=n
+CONFIG_DRM_PANFROST=n
+CONFIG_SND_HDA_TEGRA=n
+CONFIG_SND_HDA_CODEC_HDMI=n
+CONFIG_SND_BCM2835_SOC_I2S=n
+CONFIG_SND_SOC_FSL_EASRC=n
+CONFIG_SND_IMX_SOC=n
+CONFIG_SND_SOC_IMX_SGTL5000=n
+CONFIG_SND_SOC_IMX_SPDIF=n
+CONFIG_SND_SOC_IMX_AUDMIX=n
+CONFIG_SND_SOC_FSL_ASOC_CARD=n
+CONFIG_SND_MESON_AXG_SOUND_CARD=n
+CONFIG_SND_MESON_GX_SOUND_CARD=n
+CONFIG_SND_SOC_ROCKCHIP=n
+CONFIG_SND_SOC_ROCKCHIP_SPDIF=n
+CONFIG_SND_SOC_ROCKCHIP_RT5645=n
+CONFIG_SND_SOC_RK3399_GRU_SOUND=n
+CONFIG_SND_SOC_SAMSUNG=n
+CONFIG_SND_SOC_RCAR=n
+CONFIG_SND_SUN4I_I2S=n
+CONFIG_SND_SUN4I_SPDIF=n
+CONFIG_SND_SOC_TEGRA=n
+CONFIG_SND_SOC_TEGRA210_AHUB=n
+CONFIG_SND_SOC_TEGRA210_DMIC=n
+CONFIG_SND_SOC_TEGRA210_I2S=n
+CONFIG_SND_SOC_TEGRA186_DSPK=n
+CONFIG_SND_SOC_TEGRA210_ADMAIF=n
+CONFIG_SND_SOC_TEGRA_AUDIO_GRAPH_CARD=n
+CONFIG_SND_SOC_GTM601=n
+CONFIG_SND_SOC_RT5659=n
+CONFIG_SND_SOC_WM8960=n
+CONFIG_SND_SOC_WM8962=n
+CONFIG_USB_XHCI_PCI_RENESAS=n
+CONFIG_USB_XHCI_TEGRA=n
+CONFIG_USB_EHCI_EXYNOS=n
+CONFIG_USB_OHCI_EXYNOS=n
+CONFIG_USB_RENESAS_USBHS_HCD=n
+CONFIG_USB_RENESAS_USBHS=n
+CONFIG_USB_CHIPIDEA_UDC=n
+CONFIG_USB_CHIPIDEA_HOST=n
+CONFIG_USB_RENESAS_USBHS_UDC=n
+CONFIG_USB_RENESAS_USB3=n
+CONFIG_USB_TEGRA_XUDC=n
+CONFIG_MMC_SDHCI_OF_ARASAN=n
+CONFIG_MMC_SDHCI_OF_ESDHC=n
+CONFIG_MMC_SDHCI_ESDHC_IMX=n
+CONFIG_MMC_SDHCI_TEGRA=n
+CONFIG_MMC_MESON_GX=n
+CONFIG_MMC_DW_EXYNOS=n
+CONFIG_MMC_DW_HI3798CV200=n
+CONFIG_MMC_DW_K3=n
+CONFIG_MMC_DW_ROCKCHIP=n
+CONFIG_MMC_SUNXI=n
+CONFIG_MMC_BCM2835=n
+CONFIG_MMC_MTK=n
+CONFIG_MMC_SDHCI_XENON=n
+CONFIG_MMC_SDHCI_AM654=n
+CONFIG_MMC_OWL=n
+CONFIG_RTC_DRV_MAX77686=n
+CONFIG_RTC_DRV_RK808=n
+CONFIG_RTC_DRV_M41T80=n
+CONFIG_RTC_DRV_RV3028=n
+CONFIG_RTC_DRV_S5M=n
+CONFIG_RTC_DRV_FSL_FTM_ALARM=n
+CONFIG_RTC_DRV_S3C=n
+CONFIG_RTC_DRV_PL031=n
+CONFIG_RTC_DRV_SUN6I=n
+CONFIG_RTC_DRV_ARMADA38X=n
+CONFIG_RTC_DRV_TEGRA=n
+CONFIG_RTC_DRV_SNVS=n
+CONFIG_RTC_DRV_IMX_SC=n
+CONFIG_RTC_DRV_XGENE=n
+CONFIG_DMA_BCM2835=n
+CONFIG_DMA_SUN6I=n
+CONFIG_FSL_EDMA=n
+CONFIG_IMX_SDMA=n
+CONFIG_K3_DMA=n
+CONFIG_MV_XOR=n
+CONFIG_MV_XOR_V2=n
+CONFIG_OWL_DMA=n
+CONFIG_TEGRA20_APB_DMA=n
+CONFIG_TEGRA210_ADMA=n
+CONFIG_RCAR_DMAC=n
+CONFIG_RENESAS_USB_DMAC=n
+CONFIG_TI_K3_UDMA=n
+CONFIG_TI_K3_UDMA_GLUE_LAYER=n
+CONFIG_COMMON_CLK_RK808=n
+CONFIG_COMMON_CLK_FSL_SAI=n
+CONFIG_COMMON_CLK_S2MPS11=n
+CONFIG_COMMON_CLK_ZYNQMP=n
+CONFIG_COMMON_CLK_BD718XX=n
+CONFIG_CLK_RASPBERRYPI=n
+CONFIG_CLK_IMX8MM=n
+CONFIG_CLK_IMX8MN=n
+CONFIG_CLK_IMX8MP=n
+CONFIG_CLK_IMX8MQ=n
+CONFIG_CLK_IMX8QXP=n
+CONFIG_TI_SCI_CLK=n
+CONFIG_IMX_MBOX=n
+CONFIG_BCM2835_MBOX=n
+CONFIG_ROCKCHIP_IOMMU=n
+CONFIG_TEGRA_IOMMU_SMMU=n
+CONFIG_MTK_IOMMU=n
+CONFIG_OWL_PM_DOMAINS=n
+CONFIG_RASPBERRYPI_POWER=n
+CONFIG_FSL_DPAA=n
+CONFIG_FSL_MC_DPIO=n
+CONFIG_FSL_RCPM=n
+CONFIG_MTK_PMIC_WRAP=n
+CONFIG_ARCH_R8A774A1=n
+CONFIG_ARCH_R8A774B1=n
+CONFIG_ARCH_R8A774C0=n
+CONFIG_ARCH_R8A774E1=n
+CONFIG_ARCH_R8A77950=n
+CONFIG_ARCH_R8A77951=n
+CONFIG_ARCH_R8A77960=n
+CONFIG_ARCH_R8A77961=n
+CONFIG_ARCH_R8A77965=n
+CONFIG_ARCH_R8A77970=n
+CONFIG_ARCH_R8A77980=n
+CONFIG_ARCH_R8A77990=n
+CONFIG_ARCH_R8A77995=n
+CONFIG_ARCH_R8A779A0=n
+CONFIG_ARCH_R9A07G044=n
+CONFIG_ROCKCHIP_PM_DOMAINS=n
+CONFIG_ARCH_TEGRA_132_SOC=n
+CONFIG_ARCH_TEGRA_210_SOC=n
+CONFIG_ARCH_TEGRA_186_SOC=n
+CONFIG_ARCH_TEGRA_194_SOC=n
+CONFIG_ARCH_TEGRA_234_SOC=n
+CONFIG_TI_SCI_PM_DOMAINS=n
+CONFIG_ARM_IMX_BUS_DEVFREQ=n
+CONFIG_ARM_IMX8M_DDRC_DEVFREQ=n
+CONFIG_RENESAS_RPCIF=n
+CONFIG_EXYNOS_ADC=n
+CONFIG_MAX9611=n
+CONFIG_ROCKCHIP_SARADC=n
+CONFIG_PWM_BCM2835=n
+CONFIG_PWM_IMX27=n
+CONFIG_PWM_MESON=n
+CONFIG_PWM_MTK_DISP=n
+CONFIG_PWM_MEDIATEK=n
+CONFIG_PWM_RCAR=n
+CONFIG_PWM_ROCKCHIP=n
+CONFIG_PWM_SAMSUNG=n
+CONFIG_PWM_SL28CPLD=n
+CONFIG_PWM_SUN4I=n
+CONFIG_PWM_TEGRA=n
+CONFIG_PWM_VISCONTI=n
+CONFIG_SL28CPLD_INTC=n
+CONFIG_RESET_IMX7=n
+CONFIG_RESET_TI_SCI=n
+CONFIG_PHY_XGENE=n
+CONFIG_PHY_SUN4I_USB=n
+CONFIG_PHY_HI6220_USB=n
+CONFIG_PHY_HISTB_COMBPHY=n
+CONFIG_PHY_HISI_INNO_USB2=n
+CONFIG_PHY_MVEBU_CP110_COMPHY=n
+CONFIG_PHY_MTK_TPHY=n
+CONFIG_PHY_RCAR_GEN3_PCIE=n
+CONFIG_PHY_RCAR_GEN3_USB2=n
+CONFIG_PHY_RCAR_GEN3_USB3=n
+CONFIG_PHY_ROCKCHIP_EMMC=n
+CONFIG_PHY_ROCKCHIP_INNO_HDMI=n
+CONFIG_PHY_ROCKCHIP_INNO_USB2=n
+CONFIG_PHY_ROCKCHIP_INNO_DSIDPHY=n
+CONFIG_PHY_ROCKCHIP_PCIE=n
+CONFIG_PHY_ROCKCHIP_TYPEC=n
+CONFIG_PHY_SAMSUNG_UFS=n
+CONFIG_PHY_UNIPHIER_USB2=n
+CONFIG_PHY_UNIPHIER_USB3=n
+CONFIG_PHY_TEGRA_XUSB=n
+CONFIG_FSL_IMX8_DDR_PMU=n
+CONFIG_HISI_PMU=n
+CONFIG_NVMEM_IMX_OCOTP=n
+CONFIG_NVMEM_IMX_OCOTP_SCU=n
+CONFIG_MTK_EFUSE=n
+CONFIG_ROCKCHIP_EFUSE=n
+CONFIG_NVMEM_SUNXI_SID=n
+CONFIG_UNIPHIER_EFUSE=n
+CONFIG_MESON_EFUSE=n
+CONFIG_NVMEM_RMEM=n
+CONFIG_FPGA=n
+CONFIG_FPGA_MGR_STRATIX10_SOC=n
+CONFIG_FPGA_BRIDGE=n
+CONFIG_ALTERA_FREEZE_BRIDGE=n
+CONFIG_FPGA_REGION=n
+CONFIG_OF_FPGA_REGION=n
+CONFIG_INTERCONNECT_IMX=n
+CONFIG_INTERCONNECT_IMX8MQ=n
diff --git a/drivers/clk/qcom/gcc-sdm660.c b/drivers/clk/qcom/gcc-sdm660.c
index 9b97425008ce..04b427b577a1 100644
--- a/drivers/clk/qcom/gcc-sdm660.c
+++ b/drivers/clk/qcom/gcc-sdm660.c
@@ -37,19 +37,6 @@ enum {
 	P_GPLL1_EARLY_DIV,
 };
 
-static struct clk_fixed_factor xo = {
-	.mult = 1,
-	.div = 1,
-	.hw.init = &(struct clk_init_data){
-		.name = "xo",
-		.parent_data = &(const struct clk_parent_data) {
-			.fw_name = "xo"
-		},
-		.num_parents = 1,
-		.ops = &clk_fixed_factor_ops,
-	},
-};
-
 static struct clk_alpha_pll gpll0_early = {
 	.offset = 0x0,
 	.regs = clk_alpha_pll_regs[CLK_ALPHA_PLL_TYPE_DEFAULT],
@@ -156,8 +143,7 @@ static struct clk_alpha_pll gpll4_early = {
 static struct clk_alpha_pll_postdiv gpll4 = {
 	.offset = 0x77000,
 	.regs = clk_alpha_pll_regs[CLK_ALPHA_PLL_TYPE_DEFAULT],
-	.clkr.hw.init = &(struct clk_init_data)
-	{
+	.clkr.hw.init = &(struct clk_init_data){
 		.name = "gpll4",
 		.parent_hws = (const struct clk_hw*[]){
 			&gpll4_early.clkr.hw,
@@ -757,7 +743,7 @@ static struct clk_rcg2 sdcc1_apps_clk_src = {
 		.name = "sdcc1_apps_clk_src",
 		.parent_data = gcc_parent_data_xo_gpll0_gpll4_gpll0_early_div,
 		.num_parents = ARRAY_SIZE(gcc_parent_data_xo_gpll0_gpll4_gpll0_early_div),
-		.ops = &clk_rcg2_ops,
+		.ops = &clk_rcg2_floor_ops,
 	},
 };
 
@@ -2281,7 +2267,6 @@ static struct gdsc pcie_0_gdsc = {
 };
 
 static struct clk_hw *gcc_sdm660_hws[] = {
-	&xo.hw,
 	&gpll0_early_div.hw,
 	&gpll1_early_div.hw,
 };
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index e7af358e6dda..13e5f7c381a5 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -17,7 +17,7 @@ drm-y       :=	drm_aperture.o drm_auth.o drm_cache.o \
 		drm_dumb_buffers.o drm_mode_config.o drm_vblank.o \
 		drm_syncobj.o drm_lease.o drm_writeback.o drm_client.o \
 		drm_client_modeset.o drm_atomic_uapi.o \
-		drm_managed.o drm_vblank_work.o
+		drm_managed.o drm_vblank_work.o msm_drm_notify.o
 drm-$(CONFIG_DRM_LEGACY) += drm_agpsupport.o drm_bufs.o drm_context.o drm_dma.o \
 			    drm_hashtab.o drm_irq.o drm_legacy_misc.o drm_lock.o \
 			    drm_memory.o drm_scatter.o drm_vm.o
diff --git a/drivers/gpu/drm/msm/adreno/a6xx_gpu.c b/drivers/gpu/drm/msm/adreno/a6xx_gpu.c
index 4d501100b9e4..ef22b847f9b1 100644
--- a/drivers/gpu/drm/msm/adreno/a6xx_gpu.c
+++ b/drivers/gpu/drm/msm/adreno/a6xx_gpu.c
@@ -1823,7 +1823,7 @@ static u32 a618_get_speed_bin(u32 fuse)
 	else if (fuse == 174)
 		return 2;
 
-	return UINT_MAX;
+	return 0;
 }
 
 static u32 a619_get_speed_bin(u32 fuse)
diff --git a/drivers/gpu/drm/msm/adreno/adreno_device.c b/drivers/gpu/drm/msm/adreno/adreno_device.c
index 24b489b6129a..ff6ad7024c35 100644
--- a/drivers/gpu/drm/msm/adreno/adreno_device.c
+++ b/drivers/gpu/drm/msm/adreno/adreno_device.c
@@ -264,6 +264,8 @@ static const struct adreno_info gpulist[] = {
 		.gmem = SZ_512K,
 		.inactive_period = DRM_MSM_INACTIVE_PERIOD,
 		.init = a6xx_gpu_init,
+                .zapfw = "a615_zap.mdt",
+                .hwcg = a615_hwcg,
 	}, {
 		.rev = ADRENO_REV(6, 1, 9, ANY_ID),
 		.revn = 619,
diff --git a/drivers/gpu/drm/msm/msm_drv.c b/drivers/gpu/drm/msm/msm_drv.c
index 16884db272de..949869929b3d 100644
--- a/drivers/gpu/drm/msm/msm_drv.c
+++ b/drivers/gpu/drm/msm/msm_drv.c
@@ -1128,10 +1128,40 @@ static int add_components_mdp(struct device *master_dev,
 		if (!intf)
 			continue;
 
-		if (of_device_is_available(intf))
+		if (of_device_is_available(intf)) {
+			struct platform_device *pdev = of_find_device_by_node(intf);
+			struct device_link *sup_link;
+			struct device *dev;
+
+			if (!pdev) {
+				of_node_put(intf);
+				return -EPROBE_DEFER;
+			}
+
+			dev = &pdev->dev;
+
+			if(!dev->driver) {
+				of_node_put(intf);
+				return -EPROBE_DEFER;
+			}
+
+			sup_link = device_link_add(master_dev, dev,
+						DL_FLAG_AUTOREMOVE_CONSUMER);
+
+			if (!sup_link) {
+				of_node_put(intf);
+				dev_err(dev, "sup_link is NULL\n");
+				return -EPROBE_DEFER;
+			}
+
+			if (sup_link->supplier->links.status != DL_DEV_DRIVER_BOUND) {
+				of_node_put(intf);
+				return -EPROBE_DEFER;
+			}
+
 			drm_of_component_match_add(master_dev, matchptr,
 						   component_compare_of, intf);
-
+		}
 		of_node_put(intf);
 	}
 
@@ -1202,12 +1232,12 @@ int msm_drv_probe(struct device *master_dev,
 		ret = add_components_mdp(master_dev, &match);
 		if (ret)
 			return ret;
-	}
-
-	ret = add_gpu_components(master_dev, &match);
-	if (ret)
-		return ret;
+	} else {
 
+		ret = add_gpu_components(master_dev, &match);
+		if (ret)
+			return ret;
+	}
 	/* on all devices that I am aware of, iommu's which can map
 	 * any address the cpu can see are used:
 	 */
diff --git a/drivers/gpu/drm/msm_drm_notify.c b/drivers/gpu/drm/msm_drm_notify.c
new file mode 100644
index 000000000000..96295f834867
--- /dev/null
+++ b/drivers/gpu/drm/msm_drm_notify.c
@@ -0,0 +1,55 @@
+/* Copyright (c) 2020, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/notifier.h>
+
+static BLOCKING_NOTIFIER_HEAD(msm_drm_notifier_list);
+
+/**
+ * msm_drm_register_client - register a client notifier
+ * @nb: notifier block to callback on events
+ *
+ * This function registers a notifier callback function
+ * to msm_drm_notifier_list, which would be called when
+ * received unblank/power down event.
+ */
+int msm_drm_register_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&msm_drm_notifier_list, nb);
+}
+EXPORT_SYMBOL(msm_drm_register_client);
+
+/**
+ * msm_drm_unregister_client - unregister a client notifier
+ * @nb: notifier block to callback on events
+ *
+ * This function unregisters the callback function from
+ * msm_drm_notifier_list.
+ */
+int msm_drm_unregister_client(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&msm_drm_notifier_list, nb);
+}
+EXPORT_SYMBOL(msm_drm_unregister_client);
+
+/**
+ * msm_drm_notifier_call_chain - notify clients of drm_events
+ * @val: event MSM_DRM_EARLY_EVENT_BLANK or MSM_DRM_EVENT_BLANK
+ * @v: notifier data, inculde display id and display blank
+ *     event(unblank or power down).
+ */
+int msm_drm_notifier_call_chain(unsigned long val, void *v)
+{
+	return blocking_notifier_call_chain(&msm_drm_notifier_list, val, v);
+}
+EXPORT_SYMBOL(msm_drm_notifier_call_chain);
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 34e717382dbb..5d489e5a19c9 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -8,6 +8,9 @@ obj-$(CONFIG_DRM_PANEL_BOE_TV101WUM_NL6) += panel-boe-tv101wum-nl6.o
 obj-$(CONFIG_DRM_PANEL_DSI_CM) += panel-dsi-cm.o
 obj-$(CONFIG_DRM_PANEL_LVDS) += panel-lvds.o
 obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-simple.o
+obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-nt36675-tianma.o
+obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-k9d-36-02-0a-dsc.o
+obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-s6d6ft0-tianma-fhd.o
 obj-$(CONFIG_DRM_PANEL_EDP) += panel-edp.o
 obj-$(CONFIG_DRM_PANEL_EBBG_FT8719) += panel-ebbg-ft8719.o
 obj-$(CONFIG_DRM_PANEL_ELIDA_KD35T133) += panel-elida-kd35t133.o
diff --git a/drivers/gpu/drm/panel/panel-k9d-36-02-0a-dsc.c b/drivers/gpu/drm/panel/panel-k9d-36-02-0a-dsc.c
new file mode 100644
index 000000000000..cfe3e8221e8a
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-k9d-36-02-0a-dsc.c
@@ -0,0 +1,483 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2022 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct k9d_36_02_0a_dsc {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline
+struct k9d_36_02_0a_dsc *to_k9d_36_02_0a_dsc(struct drm_panel *panel)
+{
+	return container_of(panel, struct k9d_36_02_0a_dsc, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void k9d_36_02_0a_dsc_reset(struct k9d_36_02_0a_dsc *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(11000, 12000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(11000, 12000);
+}
+
+static int k9d_36_02_0a_dsc_on(struct k9d_36_02_0a_dsc *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	dsi_dcs_write_seq(dsi, 0xba,
+			  0x01, 0xe6, 0x00, 0x10, 0x00, 0x30, 0x00, 0x01);
+	dsi_dcs_write_seq(dsi, 0xb2, 0x58);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x02);
+	dsi_dcs_write_seq(dsi, 0xb2, 0x0c, 0x0c);
+	dsi_dcs_write_seq(dsi, 0xbe, 0x0e, 0x0b, 0x14, 0x13);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x05);
+	dsi_dcs_write_seq(dsi, 0xbe, 0x8a);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x66);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x08);
+	dsi_dcs_write_seq(dsi, 0xb5, 0x32);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x07);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x01);
+	dsi_dcs_write_seq(dsi, 0xc1,
+			  0x30, 0x0f, 0x04, 0xc9, 0x0f, 0x81, 0xee, 0xc6, 0x3f,
+			  0xfb, 0xb3, 0x6a, 0x3f, 0xf6, 0xd1, 0x42, 0x80, 0x00,
+			  0xf7, 0x33, 0xb1, 0x00, 0x18, 0x00, 0x00, 0x8b, 0x23,
+			  0x33, 0xc0, 0x0f, 0xb9, 0x0f, 0xdd, 0x8d, 0x00, 0x00,
+			  0x00, 0x0d, 0x08, 0x00, 0x17, 0x23, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc2,
+			  0x38, 0x0f, 0x0b, 0x64, 0x02, 0x11, 0xf6, 0x4c, 0x3f,
+			  0xfa, 0xe2, 0x14, 0xff, 0xfe, 0x41, 0xa8, 0x00, 0x00,
+			  0x5e, 0x26, 0x90, 0x00, 0x00, 0x24, 0x00, 0x17, 0x90,
+			  0x33, 0xc0, 0x09, 0xb4, 0x0f, 0x94, 0xe9, 0x00, 0x00,
+			  0x90, 0x0d, 0x3c, 0x90, 0x17, 0x57, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc3,
+			  0x3c, 0x00, 0x04, 0xc9, 0x0f, 0x81, 0x11, 0x3a, 0x3f,
+			  0xf9, 0x58, 0x7c, 0x00, 0x04, 0xf1, 0x78, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x90, 0x18, 0x3c, 0x90, 0x8b, 0x5f,
+			  0x33, 0x60, 0x00, 0x00, 0x0c, 0xdd, 0x73, 0x00, 0x00,
+			  0x04, 0x20, 0x08, 0x04, 0x2a, 0x23, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc4,
+			  0x3c, 0x00, 0x0b, 0x64, 0x02, 0x11, 0x09, 0xb4, 0x3f,
+			  0xf6, 0xca, 0x24, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x80, 0x00, 0xcf, 0x90, 0x17, 0x3b,
+			  0x33, 0xc0, 0x00, 0x00, 0x0c, 0x94, 0x17, 0x00, 0x00,
+			  0x94, 0x20, 0x3c, 0x94, 0x2a, 0x57, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc5,
+			  0x26, 0x00, 0x04, 0xc9, 0x0f, 0x81, 0x11, 0x3a, 0x00,
+			  0x00, 0x00, 0x00, 0x3f, 0xef, 0x14, 0x34, 0x80, 0x00,
+			  0x00, 0x00, 0x00, 0x03, 0xac, 0x00, 0x04, 0x1f, 0x23,
+			  0x33, 0xc0, 0x00, 0x00, 0x03, 0x23, 0x8d, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc6,
+			  0x2e, 0x00, 0x0b, 0x64, 0x02, 0x11, 0x09, 0xb4, 0x00,
+			  0x03, 0x11, 0xf4, 0xff, 0xfd, 0x62, 0x7c, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x04, 0x20, 0x24, 0x04, 0x37, 0x90,
+			  0x33, 0xc0, 0x00, 0x00, 0x03, 0x6c, 0xe9, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc7,
+			  0x2a, 0x0f, 0x04, 0xc9, 0x0f, 0x81, 0xee, 0xc6, 0x00,
+			  0x02, 0x5a, 0xee, 0x00, 0x0c, 0xae, 0x86, 0x7f, 0xfd,
+			  0xf9, 0xf3, 0x65, 0x93, 0xac, 0x3c, 0x94, 0x1f, 0x5f,
+			  0x33, 0x6f, 0xf0, 0x47, 0x00, 0x23, 0x73, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc8,
+			  0x2a, 0x0f, 0x0b, 0x64, 0x02, 0x11, 0xf6, 0x4c, 0x00,
+			  0x07, 0x29, 0xe4, 0xc0, 0x00, 0xdf, 0x2c, 0x7f, 0xff,
+			  0x43, 0xb2, 0xe0, 0x84, 0x20, 0xcf, 0x94, 0x37, 0x3b,
+			  0x33, 0xcf, 0xf6, 0x4c, 0x00, 0x6c, 0x17, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc9,
+			  0x27, 0x00, 0x03, 0xc1, 0x04, 0x41, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x3f, 0xfe, 0xf8, 0x42, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x63, 0x24, 0x00, 0x84, 0x43,
+			  0x33, 0x90, 0x00, 0x00, 0x03, 0x1f, 0xdf, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xca,
+			  0x21, 0x00, 0x03, 0xc1, 0x04, 0x00, 0x00, 0x00, 0x3f,
+			  0xff, 0x0f, 0xc0, 0x3f, 0xff, 0x08, 0x00, 0x00, 0x00,
+			  0x0f, 0x04, 0x00, 0x00, 0x42, 0x24, 0x00, 0x62, 0x43,
+			  0x33, 0x90, 0x03, 0xe0, 0x0f, 0xe1, 0xe0, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xcb,
+			  0x2d, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3f,
+			  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x42, 0x44, 0x00, 0x62, 0x64,
+			  0x33, 0x60, 0x00, 0x00, 0x0c, 0xe0, 0x20, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xcc,
+			  0x2b, 0x00, 0x04, 0x00, 0x04, 0x41, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
+			  0xee, 0xfc, 0x00, 0x00, 0x63, 0x44, 0x00, 0x84, 0x64,
+			  0x33, 0x6f, 0xfb, 0xe0, 0x00, 0x20, 0x21, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xb4, 0xc0);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x01);
+	dsi_dcs_write_seq(dsi, 0xb4, 0x00, 0x80, 0x80);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x01);
+	dsi_dcs_write_seq(dsi, 0xd2, 0x00, 0x00, 0x11);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x06);
+	dsi_dcs_write_seq(dsi, 0xd2, 0x05);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x0f);
+	dsi_dcs_write_seq(dsi, 0xd2, 0x00);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x09);
+	dsi_dcs_write_seq(dsi, 0xd2, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xce, 0x00);
+	dsi_dcs_write_seq(dsi, 0xff, 0xaa, 0x55, 0xa5, 0x80);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x61);
+	dsi_dcs_write_seq(dsi, 0xf3, 0x80);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x46);
+	dsi_dcs_write_seq(dsi, 0xbe, 0x0e, 0x0b);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x05);
+	dsi_dcs_write_seq(dsi, 0xbe, 0x88);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x08);
+	dsi_dcs_write_seq(dsi, 0xb5, 0x32);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x0b);
+	dsi_dcs_write_seq(dsi, 0xb5, 0x33, 0x23, 0x2b);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	dsi_dcs_write_seq(dsi, 0xd1, 0x07, 0x00, 0x04);
+	dsi_dcs_write_seq(dsi, 0x3b, 0x00, 0x10, 0x00, 0x30);
+	dsi_dcs_write_seq(dsi, 0xd9, 0xc8);
+	dsi_dcs_write_seq(dsi, 0x90, 0x01);
+	dsi_dcs_write_seq(dsi, 0x91,
+			  0xab, 0x28, 0x00, 0x0c, 0xc2, 0x00, 0x03, 0x1c, 0x01,
+			  0x7e, 0x00, 0x0f, 0x08, 0xbb, 0x04, 0x3d, 0x10, 0xf0);
+	dsi_dcs_write_seq(dsi, 0x03, 0x01);
+	dsi_dcs_write_seq(dsi, 0x51, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x20);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_column_address(dsi, 0x0000, 0x0437);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set column address: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_page_address(dsi, 0x0000, 0x095f);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set page address: %d\n", ret);
+		return ret;
+	}
+
+	dsi_dcs_write_seq(dsi, 0x2f, 0x02);
+	dsi_dcs_write_seq(dsi, 0xff, 0xaa, 0x55, 0xa5, 0x81);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x0f);
+	dsi_dcs_write_seq(dsi, 0xfd, 0x01, 0x5a);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x04);
+	dsi_dcs_write_seq(dsi, 0xfd, 0x5f);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x1a);
+	dsi_dcs_write_seq(dsi, 0xfd, 0x5f);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_MEMORY_START);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	dsi_dcs_write_seq(dsi, 0xca, 0x12, 0x00, 0x92, 0x02);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x02);
+	dsi_dcs_write_seq(dsi, 0xec, 0x80, 0x10);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	dsi_dcs_write_seq(dsi, 0xcd, 0x05, 0x31);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x10);
+	dsi_dcs_write_seq(dsi, 0xd8, 0x0c);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	dsi_dcs_write_seq(dsi, 0xb3, 0x86, 0x80);
+	dsi_dcs_write_seq(dsi, 0xb5, 0x85, 0x81);
+	dsi_dcs_write_seq(dsi, 0xb7, 0x85, 0x00, 0x00, 0x81);
+	dsi_dcs_write_seq(dsi, 0xb8, 0x05, 0x00, 0x00, 0x81);
+	dsi_dcs_write_seq(dsi, 0xec, 0x0d, 0x11);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x02);
+	dsi_dcs_write_seq(dsi, 0xec,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x08);
+	dsi_dcs_write_seq(dsi, 0xb5, 0x32);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x0b);
+	dsi_dcs_write_seq(dsi, 0xb5, 0x33, 0x23, 0x2b);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	dsi_dcs_write_seq(dsi, 0xce, 0x00);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	dsi_dcs_write_seq(dsi, 0xc3, 0x94, 0x01, 0x97, 0xd0, 0x22, 0x02, 0x00);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(16000, 17000);
+
+	return 0;
+}
+
+static int k9d_36_02_0a_dsc_off(struct k9d_36_02_0a_dsc *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(80);
+
+	return 0;
+}
+
+static int k9d_36_02_0a_dsc_prepare(struct drm_panel *panel)
+{
+	struct k9d_36_02_0a_dsc *ctx = to_k9d_36_02_0a_dsc(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	k9d_36_02_0a_dsc_reset(ctx);
+
+	ret = k9d_36_02_0a_dsc_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int k9d_36_02_0a_dsc_unprepare(struct drm_panel *panel)
+{
+	struct k9d_36_02_0a_dsc *ctx = to_k9d_36_02_0a_dsc(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = k9d_36_02_0a_dsc_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode k9d_36_02_0a_dsc_mode = {
+	.clock = (1080 + 16 + 8 + 8) * (2400 + 1212 + 4 + 8) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 16,
+	.hsync_end = 1080 + 16 + 8,
+	.htotal = 1080 + 16 + 8 + 8,
+	.vdisplay = 2400,
+	.vsync_start = 2400 + 1212,
+	.vsync_end = 2400 + 1212 + 4,
+	.vtotal = 2400 + 1212 + 4 + 8,
+	.width_mm = 683,
+	.height_mm = 1517,
+};
+
+static int k9d_36_02_0a_dsc_get_modes(struct drm_panel *panel,
+				      struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &k9d_36_02_0a_dsc_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs k9d_36_02_0a_dsc_panel_funcs = {
+	.prepare = k9d_36_02_0a_dsc_prepare,
+	.unprepare = k9d_36_02_0a_dsc_unprepare,
+	.get_modes = k9d_36_02_0a_dsc_get_modes,
+};
+
+static int k9d_36_02_0a_dsc_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+// TODO: Check if /sys/class/backlight/.../actual_brightness actually returns
+// correct values. If not, remove this function.
+static int k9d_36_02_0a_dsc_bl_get_brightness(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_get_display_brightness(dsi, &brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return brightness;
+}
+
+static const struct backlight_ops k9d_36_02_0a_dsc_bl_ops = {
+	.update_status = k9d_36_02_0a_dsc_bl_update_status,
+	.get_brightness = k9d_36_02_0a_dsc_bl_get_brightness,
+};
+
+static struct backlight_device *
+k9d_36_02_0a_dsc_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 4095,
+		.max_brightness = 4095,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &k9d_36_02_0a_dsc_bl_ops, &props);
+}
+
+static int k9d_36_02_0a_dsc_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct k9d_36_02_0a_dsc *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &k9d_36_02_0a_dsc_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ctx->panel.backlight = k9d_36_02_0a_dsc_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int k9d_36_02_0a_dsc_remove(struct mipi_dsi_device *dsi)
+{
+	struct k9d_36_02_0a_dsc *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id k9d_36_02_0a_dsc_of_match[] = {
+	{ .compatible = "mdss,k9d-36-02-0a-dsc" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, k9d_36_02_0a_dsc_of_match);
+
+static struct mipi_dsi_driver k9d_36_02_0a_dsc_driver = {
+	.probe = k9d_36_02_0a_dsc_probe,
+	.remove = k9d_36_02_0a_dsc_remove,
+	.driver = {
+		.name = "panel-k9d-36-02-0a-dsc",
+		.of_match_table = k9d_36_02_0a_dsc_of_match,
+	},
+};
+module_mipi_dsi_driver(k9d_36_02_0a_dsc_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for xiaomi 36 02 0a cmd mode dsc dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-nt36675-tianma.c b/drivers/gpu/drm/panel/panel-nt36675-tianma.c
new file mode 100644
index 000000000000..6bb3b9065a53
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-nt36675-tianma.c
@@ -0,0 +1,384 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2022 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/regulator/consumer.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#define NT36675_VREG_MAX                3
+
+struct nt36675_tianma {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct gpio_desc *reset_gpio;
+	struct regulator_bulk_data vregs[NT36675_VREG_MAX];
+	bool prepared;
+};
+
+static inline struct nt36675_tianma *to_nt36675_tianma(struct drm_panel *panel)
+{
+	return container_of(panel, struct nt36675_tianma, panel);
+}
+
+#ifdef ENABLE_REGULATOR
+static int nt36675_tianma_init_vregs(struct nt36675_tianma *nt, struct device *dev)
+{
+        int ret;
+
+        nt->vregs[0].supply = "vddio";
+        nt->vregs[1].supply = "lab";
+        nt->vregs[2].supply = "ibb";
+        ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(nt->vregs),
+                                      nt->vregs);
+        if (ret < 0)
+                return ret;
+
+	/* vddio */
+        ret = regulator_is_supported_voltage(nt->vregs[0].consumer,
+                                             1800000, 1904000);
+        if (!ret)
+                return -EINVAL;
+
+	/* lab */
+        ret = regulator_is_supported_voltage(nt->vregs[1].consumer,
+                                             4600000, 6000000);
+        if (!ret)
+                return -EINVAL;
+
+	/* ibb */
+        ret = regulator_is_supported_voltage(nt->vregs[2].consumer,
+                                             4600000, 6000000);
+        if (!ret)
+                return -EINVAL;
+
+        return 0;
+}
+#endif
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void nt36675_tianma_reset(struct nt36675_tianma *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+        gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+        usleep_range(10000, 11000);
+}
+
+static int nt36675_tianma_on(struct nt36675_tianma *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0xff, 0x10);
+	dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	dsi_dcs_write_seq(dsi, 0x3b, 0x03, 0x1e, 0x0a, 0x04, 0x04);
+	dsi_dcs_write_seq(dsi, 0xb0, 0x00);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x00b8);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+	dsi_dcs_write_seq(dsi, 0xff, 0x27);
+	dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	dsi_dcs_write_seq(dsi, 0x07, 0x01);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_VSYNC_TIMING, 0x25);
+	dsi_dcs_write_seq(dsi, 0xff, 0x23);
+	dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	dsi_dcs_write_seq(dsi, 0x0a, 0x20);
+	dsi_dcs_write_seq(dsi, 0x0b, 0x20);
+	dsi_dcs_write_seq(dsi, 0x0c, 0x20);
+	dsi_dcs_write_seq(dsi, 0x0d, 0x2a);
+	dsi_dcs_write_seq(dsi, 0x10, 0x50);
+	dsi_dcs_write_seq(dsi, 0x11, 0x01);
+	dsi_dcs_write_seq(dsi, 0x12, 0x95);
+	dsi_dcs_write_seq(dsi, 0x15, 0x68);
+	dsi_dcs_write_seq(dsi, 0x16, 0x0b);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_ROWS, 0xff);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_COLUMNS, 0xff);
+	dsi_dcs_write_seq(dsi, 0x32, 0xff);
+	dsi_dcs_write_seq(dsi, 0x33, 0xfe);
+	dsi_dcs_write_seq(dsi, 0x34, 0xfd);
+	dsi_dcs_write_seq(dsi, 0x35, 0xfa);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0xf6);
+	dsi_dcs_write_seq(dsi, 0x37, 0xf2);
+	dsi_dcs_write_seq(dsi, 0x38, 0xf0);
+	dsi_dcs_write_seq(dsi, 0x39, 0xee);
+
+	ret = mipi_dsi_dcs_set_pixel_format(dsi, 0xec);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set pixel format: %d\n", ret);
+		return ret;
+	}
+
+	dsi_dcs_write_seq(dsi, 0x3b, 0xea);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_3D_CONTROL, 0xe8);
+	dsi_dcs_write_seq(dsi, 0x3f, 0xe7);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_VSYNC_TIMING, 0xe6);
+	dsi_dcs_write_seq(dsi, 0x41, 0xe5);
+	dsi_dcs_write_seq(dsi, 0xa0, 0x11);
+	dsi_dcs_write_seq(dsi, 0xff, 0x10);
+	dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(80);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(5000, 6000);
+
+	dsi_dcs_write_seq(dsi, 0xff, 0x27);
+	dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	dsi_dcs_write_seq(dsi, 0x3f, 0x01);
+	dsi_dcs_write_seq(dsi, 0x43, 0x08);
+	dsi_dcs_write_seq(dsi, 0xff, 0x10);
+
+	return 0;
+}
+
+static int nt36675_tianma_off(struct nt36675_tianma *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0xff, 0x10);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(140);
+
+	return 0;
+}
+
+static int nt36675_tianma_prepare(struct drm_panel *panel)
+{
+	struct nt36675_tianma *ctx = to_nt36675_tianma(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+#ifdef ENABLE_REGULATOR
+	//TODO: change value
+        ret = regulator_enable(ctx->vregs[0].consumer);
+        if (ret)
+                return ret;
+        usleep_range(2000, 5000);
+
+        ret = regulator_enable(ctx->vregs[1].consumer);
+        if (ret)
+                goto end;
+
+        ret = regulator_enable(ctx->vregs[2].consumer);
+        if (ret)
+                goto end;
+#endif
+	nt36675_tianma_reset(ctx);
+
+	ret = nt36675_tianma_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+
+end:
+	regulator_disable(ctx->vregs[0].consumer);
+	return ret;
+}
+
+static int nt36675_tianma_unprepare(struct drm_panel *panel)
+{
+	struct nt36675_tianma *ctx = to_nt36675_tianma(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = nt36675_tianma_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode nt36675_tianma_mode = {
+	.clock = (1080 + 20 + 4 + 22) * (2400 + 10 + 2 + 30) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 20,
+	.hsync_end = 1080 + 20 + 4,
+	.htotal = 1080 + 20 + 4 + 22,
+	.vdisplay = 2400,
+	.vsync_start = 2400 + 10,
+	.vsync_end = 2400 + 10 + 2,
+	.vtotal = 2400 + 10 + 2 + 30,
+	.width_mm = 69,
+	.height_mm = 154,
+};
+
+static int nt36675_tianma_get_modes(struct drm_panel *panel,
+				    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &nt36675_tianma_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs nt36675_tianma_panel_funcs = {
+	.prepare = nt36675_tianma_prepare,
+	.unprepare = nt36675_tianma_unprepare,
+	.get_modes = nt36675_tianma_get_modes,
+};
+
+static int nt36675_tianma_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct nt36675_tianma *ctx;
+	int ret;
+
+	dev_info(dev, "%s", __func__);
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+#ifdef ENABLE_REGULATOR
+        ret = nt36675_tianma_init_vregs(ctx, dev);
+        if (ret)
+                return dev_err_probe(dev, ret, "Regulator init failure.\n");
+#endif
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &nt36675_tianma_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	pr_info("nt36675_tianma_probe ok!\n");
+	return 0;
+}
+
+static int nt36675_tianma_remove(struct mipi_dsi_device *dsi)
+{
+	struct nt36675_tianma *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id nt36675_tianma_of_match[] = {
+	{ .compatible = "mdss,nt36675-tianma" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, nt36675_tianma_of_match);
+
+static struct mipi_dsi_driver nt36675_tianma_driver = {
+	.probe = nt36675_tianma_probe,
+	.remove = nt36675_tianma_remove,
+	.driver = {
+		.name = "panel-nt36675-tianma",
+		.of_match_table = nt36675_tianma_of_match,
+	},
+};
+module_mipi_dsi_driver(nt36675_tianma_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for nt36675 video mode dsi tianma panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-s6d6ft0-tianma-fhd.c b/drivers/gpu/drm/panel/panel-s6d6ft0-tianma-fhd.c
new file mode 100644
index 000000000000..0648d2d45762
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-s6d6ft0-tianma-fhd.c
@@ -0,0 +1,276 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2022 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct s6d6ft0_tianma_fhd {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline
+struct s6d6ft0_tianma_fhd *to_s6d6ft0_tianma_fhd(struct drm_panel *panel)
+{
+	return container_of(panel, struct s6d6ft0_tianma_fhd, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void s6d6ft0_tianma_fhd_reset(struct s6d6ft0_tianma_fhd *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(40);
+}
+
+static int s6d6ft0_tianma_fhd_on(struct s6d6ft0_tianma_fhd *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_dcs_write_seq(dsi, 0x9f, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	dsi_dcs_write_seq(dsi, 0x55);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0x73, 0x94);
+	dsi_dcs_write_seq(dsi, 0xea,
+			  0x00, 0x73, 0x11, 0x1b, 0x23, 0x2a, 0x40, 0x59, 0x70,
+			  0x6e, 0xa1, 0x86, 0x92, 0x9f, 0xab, 0xb8, 0x4d, 0x59,
+			  0x65, 0x7f, 0x00, 0x73, 0x11, 0x1b, 0x23, 0x2a, 0x40,
+			  0x59, 0x70, 0x6e, 0xa1, 0x86, 0x92, 0x9f, 0xab, 0xb8,
+			  0x4d, 0x59, 0x65, 0x7f, 0x00, 0x73, 0x11, 0x1b, 0x23,
+			  0x2a, 0x40, 0x59, 0x70, 0x6e, 0xa1, 0x86, 0x92, 0x9f,
+			  0xab, 0xb8, 0x4d, 0x59, 0x65, 0x7f);
+	dsi_dcs_write_seq(dsi, 0xeb,
+			  0x00, 0x73, 0x11, 0x1b, 0x23, 0x2a, 0x40, 0x59, 0x70,
+			  0x6e, 0xa1, 0x86, 0x92, 0x9f, 0xab, 0xb8, 0x4d, 0x59,
+			  0x65, 0x7f, 0x00, 0x73, 0x11, 0x1b, 0x23, 0x2a, 0x40,
+			  0x59, 0x70, 0x6e, 0xa1, 0x86, 0x92, 0x9f, 0xab, 0xb8,
+			  0x4d, 0x59, 0x65, 0x7f, 0x00, 0x73, 0x11, 0x1b, 0x23,
+			  0x2a, 0x40, 0x59, 0x70, 0x6e, 0xa1, 0x86, 0x92, 0x9f,
+			  0xab, 0xb8, 0x4d, 0x59, 0x65, 0x7f);
+	dsi_dcs_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	dsi_dcs_write_seq(dsi, 0x9f, 0x5a, 0x5a);
+
+	return 0;
+}
+
+static int s6d6ft0_tianma_fhd_off(struct s6d6ft0_tianma_fhd *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_dcs_write_seq(dsi, 0x9f, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(80);
+
+	dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0x73, 0x90);
+	dsi_dcs_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+	dsi_dcs_write_seq(dsi, 0x24);
+	dsi_dcs_write_seq(dsi, 0x9f, 0x5a, 0x5a);
+
+	return 0;
+}
+
+static int s6d6ft0_tianma_fhd_prepare(struct drm_panel *panel)
+{
+	struct s6d6ft0_tianma_fhd *ctx = to_s6d6ft0_tianma_fhd(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	s6d6ft0_tianma_fhd_reset(ctx);
+
+	ret = s6d6ft0_tianma_fhd_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int s6d6ft0_tianma_fhd_unprepare(struct drm_panel *panel)
+{
+	struct s6d6ft0_tianma_fhd *ctx = to_s6d6ft0_tianma_fhd(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = s6d6ft0_tianma_fhd_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode s6d6ft0_tianma_fhd_mode = {
+	.clock = (1080 + 229 + 4 + 4) * (2160 + 8 + 2 + 6) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 229,
+	.hsync_end = 1080 + 229 + 4,
+	.htotal = 1080 + 229 + 4 + 4,
+	.vdisplay = 2160,
+	.vsync_start = 2160 + 8,
+	.vsync_end = 2160 + 8 + 2,
+	.vtotal = 2160 + 8 + 2 + 6,
+	.width_mm = 0,
+	.height_mm = 0,
+};
+
+static int s6d6ft0_tianma_fhd_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &s6d6ft0_tianma_fhd_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs s6d6ft0_tianma_fhd_panel_funcs = {
+	.prepare = s6d6ft0_tianma_fhd_prepare,
+	.unprepare = s6d6ft0_tianma_fhd_unprepare,
+	.get_modes = s6d6ft0_tianma_fhd_get_modes,
+};
+
+static int s6d6ft0_tianma_fhd_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct s6d6ft0_tianma_fhd *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST;
+
+	drm_panel_init(&ctx->panel, dev, &s6d6ft0_tianma_fhd_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6d6ft0_tianma_fhd_remove(struct mipi_dsi_device *dsi)
+{
+	struct s6d6ft0_tianma_fhd *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id s6d6ft0_tianma_fhd_of_match[] = {
+	{ .compatible = "mdss,s6d6ft0-tianma-fhd" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s6d6ft0_tianma_fhd_of_match);
+
+static struct mipi_dsi_driver s6d6ft0_tianma_fhd_driver = {
+	.probe = s6d6ft0_tianma_fhd_probe,
+	//.remove = s6d6ft0_tianma_fhd_remove,
+	.driver = {
+		.name = "panel-s6d6ft0-tianma-fhd",
+		.of_match_table = s6d6ft0_tianma_fhd_of_match,
+	},
+};
+module_mipi_dsi_driver(s6d6ft0_tianma_fhd_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for s6d6ff0 tianma fhd video mode dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-simple-k9d-36-02-0a-dsc.c b/drivers/gpu/drm/panel/panel-simple-k9d-36-02-0a-dsc.c
new file mode 100644
index 000000000000..fecf02026369
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-simple-k9d-36-02-0a-dsc.c
@@ -0,0 +1,33 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2013, The Linux Foundation. All rights reserved.
+
+static const struct drm_display_mode k9d_36_02_0a_dsc_mode = {
+	.clock = (1080 + 16 + 8 + 8) * (2400 + 1212 + 4 + 8) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 16,
+	.hsync_end = 1080 + 16 + 8,
+	.htotal = 1080 + 16 + 8 + 8,
+	.vdisplay = 2400,
+	.vsync_start = 2400 + 1212,
+	.vsync_end = 2400 + 1212 + 4,
+	.vtotal = 2400 + 1212 + 4 + 8,
+	.width_mm = 683,
+	.height_mm = 1517,
+};
+
+static const struct panel_desc_dsi k9d_36_02_0a_dsc = {
+	.desc = {
+		.modes = &k9d_36_02_0a_dsc_mode,
+		.num_modes = 1,
+		.bpc = 10,
+		.size = {
+			.width = 683,
+			.height = 1517,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO_BURST | MIPI_DSI_CLOCK_NON_CONTINUOUS |
+		 MIPI_DSI_MODE_LPM,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
diff --git a/drivers/gpu/drm/panel/panel-simple-nt36675-tianma.c b/drivers/gpu/drm/panel/panel-simple-nt36675-tianma.c
new file mode 100644
index 000000000000..13e2db2a0dfb
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-simple-nt36675-tianma.c
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2013, The Linux Foundation. All rights reserved.
+
+static const struct drm_display_mode nt36675_tianma_mode_simple = {
+	.clock = (1080 + 20 + 4 + 22) * (2400 + 10 + 2 + 30) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 20,
+	.hsync_end = 1080 + 20 + 4,
+	.htotal = 1080 + 20 + 4 + 22,
+	.vdisplay = 2400,
+	.vsync_start = 2400 + 10,
+	.vsync_end = 2400 + 10 + 2,
+	.vtotal = 2400 + 10 + 2 + 30,
+	.width_mm = 69,
+	.height_mm = 154,
+};
+
+static const struct panel_desc_dsi nt36675_tianma_simple = {
+	.desc = {
+		.modes = &nt36675_tianma_mode_simple,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 69,
+			.height = 154,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
diff --git a/drivers/gpu/drm/panel/panel-simple-s6d6ft0-tianma-fhd.c b/drivers/gpu/drm/panel/panel-simple-s6d6ft0-tianma-fhd.c
new file mode 100644
index 000000000000..9bd5edb848be
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-simple-s6d6ft0-tianma-fhd.c
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2013, The Linux Foundation. All rights reserved.
+
+static const struct drm_display_mode s6d6ft0_tianma_fhd_mode = {
+	.clock = (1080 + 229 + 4 + 4) * (2160 + 8 + 2 + 6) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 229,
+	.hsync_end = 1080 + 229 + 4,
+	.htotal = 1080 + 229 + 4 + 4,
+	.vdisplay = 2160,
+	.vsync_start = 2160 + 8,
+	.vsync_end = 2160 + 8 + 2,
+	.vtotal = 2160 + 8 + 2 + 6,
+	.width_mm = 0,
+	.height_mm = 0,
+};
+
+static const struct panel_desc_dsi s6d6ft0_tianma_fhd = {
+	.desc = {
+		.modes = &s6d6ft0_tianma_fhd_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 0,
+			.height = 0,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 1e716c23019a..19bae1c6e6fd 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -4508,6 +4508,71 @@ static const struct panel_desc_dsi osd101t2045_53ts = {
 	.lanes = 4,
 };
 
+#include "panel-simple-s6d6ft0-tianma-fhd.c"
+#include "panel-simple-nt36675-tianma.c"
+
+static const struct drm_display_mode sony_kirin_nt36672a_truly_mode = {
+	.clock = (1080 + 25 + 12 + 120) * (2520 + 12 + 4 + 10) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 25,
+	.hsync_end = 1080 + 25 + 12,
+	.htotal = 1080 + 25 + 12 + 120,
+	.vdisplay = 2520,
+	.vsync_start = 2520 + 12,
+	.vsync_end = 2520 + 12 + 4,
+	.vtotal = 2520 + 12 + 4 + 10,
+	.width_mm = 60,
+	.height_mm = 139,
+};
+
+static const struct panel_desc_dsi sony_kirin_nt36672a_truly = {
+	.desc = {
+		.modes = &sony_kirin_nt36672a_truly_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 60,
+			.height = 139,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+		 MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode sony_mermaid_nt36672a_tianma_mode = {
+	.clock = (1080 + 102 + 20 + 40) * (2520 + 10 + 2 + 8) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 102,
+	.hsync_end = 1080 + 102 + 20,
+	.htotal = 1080 + 102 + 20 + 40,
+	.vdisplay = 2520,
+	.vsync_start = 2520 + 10,
+	.vsync_end = 2520 + 10 + 2,
+	.vtotal = 2520 + 10 + 2 + 8,
+	.width_mm = 65,
+	.height_mm = 151,
+};
+
+static const struct panel_desc_dsi sony_mermaid_nt36672a_tianma = {
+	.desc = {
+		.modes = &sony_mermaid_nt36672a_tianma_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 65,
+			.height = 151,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+		 MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
 static const struct of_device_id dsi_of_match[] = {
 	{
 		.compatible = "auo,b080uan01",
@@ -4530,6 +4595,18 @@ static const struct of_device_id dsi_of_match[] = {
 	}, {
 		.compatible = "osddisplays,osd101t2045-53ts",
 		.data = &osd101t2045_53ts
+        }, {
+                .compatible = "meizu,s6d6ft0-tianma-fhd",
+                .data = &s6d6ft0_tianma_fhd,
+	}, {
+                .compatible = "xiaomi,nt36675-tianma",
+                .data = &nt36675_tianma_simple,
+        }, {
+		.compatible = "sony,kirin-nt36672a-truly",
+		.data = &sony_kirin_nt36672a_truly
+	}, {
+		.compatible = "sony,mermaid-nt36672a-tianma",
+		.data = &sony_mermaid_nt36672a_tianma
 	}, {
 		/* sentinel */
 	}
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 2d70c945b20a..d095ad5c17b7 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -12,6 +12,9 @@ menuconfig INPUT_TOUCHSCREEN
 
 if INPUT_TOUCHSCREEN
 
+source "drivers/input/touchscreen/nt36672c/Kconfig"
+source "drivers/input/touchscreen/nt36xxx_spi/Kconfig"
+
 config TOUCHSCREEN_88PM860X
 	tristate "Marvell 88PM860x touchscreen"
 	depends on MFD_88PM860X
@@ -648,6 +651,18 @@ config TOUCHSCREEN_IMAGIS
 	  To compile this driver as a module, choose M here: the
 	  module will be called imagis.
 
+config TOUCHSCREEN_NT36XXX
+	tristate "Novatek NT36XXX In-Cell I2C touchscreen controller"
+	depends on I2C
+	help
+	  Say Y here if you have a Novatek NT36xxx series In-Cell
+	  touchscreen connected to your system over I2C.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called nt36xxx.
+
 config TOUCHSCREEN_IMX6UL_TSC
 	tristate "Freescale i.MX6UL touchscreen controller"
 	depends on ((OF && GPIOLIB) || COMPILE_TEST) && HAS_IOMEM
@@ -1380,3 +1395,5 @@ config TOUCHSCREEN_ZINITIX
 	  module will be called zinitix.
 
 endif
+
+source "drivers/input/touchscreen/sec_ts/Kconfig"
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 557f84fd2075..bfa811b429c8 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -65,6 +65,7 @@ obj-$(CONFIG_TOUCHSCREEN_MMS114)	+= mms114.o
 obj-$(CONFIG_TOUCHSCREEN_MSG2638)	+= msg2638.o
 obj-$(CONFIG_TOUCHSCREEN_MTOUCH)	+= mtouch.o
 obj-$(CONFIG_TOUCHSCREEN_MK712)		+= mk712.o
+obj-$(CONFIG_TOUCHSCREEN_NT36XXX)	+= nt36xxx.o
 obj-$(CONFIG_TOUCHSCREEN_HP600)		+= hp680_ts_input.o
 obj-$(CONFIG_TOUCHSCREEN_HP7XX)		+= jornada720_ts.o
 obj-$(CONFIG_TOUCHSCREEN_IPAQ_MICRO)	+= ipaq-micro-ts.o
@@ -116,3 +117,8 @@ obj-$(CONFIG_TOUCHSCREEN_ROHM_BU21023)	+= rohm_bu21023.o
 obj-$(CONFIG_TOUCHSCREEN_RASPBERRYPI_FW)	+= raspberrypi-ts.o
 obj-$(CONFIG_TOUCHSCREEN_IQS5XX)	+= iqs5xx.o
 obj-$(CONFIG_TOUCHSCREEN_ZINITIX)	+= zinitix.o
+
+obj-y += sec_ts/
+obj-$(CONFIG_TOUCHSCREEN_NT36672C_HOSTDL_SPI)	+= nt36672c/
+#obj-$(CONFIG_TOUCHSCREEN_NT36672C_HOSTDL_SPI)   += nt36xxx_spi/
+obj-$(CONFIG_TOUCHSCREEN_NT36xxx_HOSTDL_SPI) += nt36xxx_spi/
diff --git a/drivers/input/touchscreen/nt36672c/Kconfig b/drivers/input/touchscreen/nt36672c/Kconfig
new file mode 100644
index 000000000000..2313cb9b34b3
--- /dev/null
+++ b/drivers/input/touchscreen/nt36672c/Kconfig
@@ -0,0 +1,12 @@
+#
+# Novatek NT36672C touchscreen driver configuration
+#
+config TOUCHSCREEN_NT36672C_HOSTDL_SPI
+	tristate "Novatek NT36672C host download SPI driver"
+	depends on SPI
+	default y
+	help
+	  Say Y here if you have a Novatek NT36672C no flash touchscreen connected
+	  to your system by SPI bus.
+
+	  If unsure, say N.
diff --git a/drivers/input/touchscreen/nt36672c/Makefile b/drivers/input/touchscreen/nt36672c/Makefile
new file mode 100644
index 000000000000..0c94939e110c
--- /dev/null
+++ b/drivers/input/touchscreen/nt36672c/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the Novatek NT36xxx touchscreen driver.
+#
+
+# Each configuration option enables a list of files.
+
+#ccflags-y = -fdirectives-only -E -fno-canonical-system-headers -dN -dI -dU
+#ccflags-y = -E
+
+obj-$(CONFIG_TOUCHSCREEN_NT36672C_HOSTDL_SPI) += nt36672c.o
+nt36672c-objs += nt36xxx.o nt36xxx_fw_update.o nt36xxx_ext_proc.o
diff --git a/drivers/input/touchscreen/nt36672c/nt36xxx.c b/drivers/input/touchscreen/nt36672c/nt36xxx.c
new file mode 100644
index 000000000000..f219021c44dc
--- /dev/null
+++ b/drivers/input/touchscreen/nt36672c/nt36xxx.c
@@ -0,0 +1,2533 @@
+/*
+ * Copyright (C) 2010 - 2018 Novatek, Inc.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ * $Revision: 43560 $
+ * $Date: 2019-04-19 11:34:19 +0800 (週五, 19 四月 2019) $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/proc_fs.h>
+#include <linux/input/mt.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/pm_runtime.h>
+
+#include "nt36xxx.h"
+
+#if defined(CONFIG_FB)
+#ifdef CONFIG_DRM_MSM
+#include <drm/msm_drm_notify.h>
+#endif
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
+
+//#include <linux/spi/spi-geni-qcom.h>
+#if NVT_TOUCH_ESD_PROTECT
+#include <linux/jiffies.h>
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+#ifdef CHECK_TOUCH_VENDOR
+extern char *saved_command_line;
+static uint8_t touch_vendor_id;
+#endif
+
+#if NVT_TOUCH_ESD_PROTECT
+static struct delayed_work nvt_esd_check_work;
+static struct workqueue_struct *nvt_esd_check_wq;
+static unsigned long irq_timer;
+uint8_t esd_check;
+uint8_t esd_retry;
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+#if NVT_TOUCH_EXT_PROC
+extern int32_t nvt_extra_proc_init(void);
+extern void nvt_extra_proc_deinit(void);
+#endif
+
+struct nvt_ts_data *ts;
+//static struct device *spi_geni_master_dev;
+
+#if BOOT_UPDATE_FIRMWARE
+static struct workqueue_struct *nvt_fwu_wq;
+extern void Boot_Update_Firmware(struct work_struct *work);
+#endif
+
+#if defined(CONFIG_FB)
+static void nvt_ts_resume_work(struct work_struct *work);
+#ifdef _MSM_DRM_NOTIFY_H_
+static int nvt_drm_notifier_callback(struct notifier_block *self, unsigned long event, void *data);
+#else
+static int nvt_fb_notifier_callback(struct notifier_block *self, unsigned long event, void *data);
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+static void nvt_ts_early_suspend(struct early_suspend *h);
+static void nvt_ts_late_resume(struct early_suspend *h);
+#endif
+
+#if WAKEUP_GESTURE
+extern void set_lcd_reset_gpio_keep_high(bool en);
+static int lct_nvt_tp_gesture_callback(bool flag);
+#endif
+
+uint32_t ENG_RST_ADDR  = 0x7FFF80;
+uint32_t SWRST_N8_ADDR; //read from dtsi
+uint32_t SPI_RD_FAST_ADDR;	//read from dtsi
+
+#if TOUCH_KEY_NUM > 0
+const uint16_t touch_key_array[TOUCH_KEY_NUM] = {
+	KEY_BACK,
+	KEY_HOME,
+	KEY_MENU
+};
+#endif
+
+#if WAKEUP_GESTURE
+const uint16_t gesture_key_array[] = {
+	KEY_WAKEUP,  //GESTURE_WORD_C
+	KEY_WAKEUP,  //GESTURE_WORD_W
+	KEY_WAKEUP,  //GESTURE_WORD_V
+	KEY_WAKEUP,  //GESTURE_DOUBLE_CLICK
+	KEY_WAKEUP,  //GESTURE_WORD_Z
+	KEY_WAKEUP,  //GESTURE_WORD_M
+	KEY_WAKEUP,  //GESTURE_WORD_O
+	KEY_WAKEUP,  //GESTURE_WORD_e
+	KEY_WAKEUP,  //GESTURE_WORD_S
+	KEY_WAKEUP,  //GESTURE_SLIDE_UP
+	KEY_WAKEUP,  //GESTURE_SLIDE_DOWN
+	KEY_WAKEUP,  //GESTURE_SLIDE_LEFT
+	KEY_WAKEUP,  //GESTURE_SLIDE_RIGHT
+	KEY_POWER,	 //FOR PALM USING ONLY
+};
+#endif
+
+static uint8_t bTouchIsAwake;
+
+#if WAKEUP_GESTURE
+#define WAKEUP_OFF 4
+#define WAKEUP_ON 5
+int nvt_gesture_switch(struct input_dev *dev, unsigned int type, unsigned int code, int value)
+{
+	NVT_LOG("Enter. type = %u, code = %u, value = %d\n", type, code, value);
+	if (type == EV_SYN && code == SYN_CONFIG) {
+		if (value == WAKEUP_OFF)
+			lct_nvt_tp_gesture_callback(false);
+		else if (value == WAKEUP_ON)
+			lct_nvt_tp_gesture_callback(true);
+	}
+	NVT_LOG("Exit\n");
+	return 0;
+}
+
+#endif
+
+/*******************************************************
+Description:
+	Novatek touchscreen irq enable/disable function.
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_irq_enable(bool enable)
+{
+	struct irq_desc *desc;
+
+	if (enable) {
+		if (!ts->irq_enabled) {
+			enable_irq(ts->client->irq);
+			ts->irq_enabled = true;
+		}
+	} else {
+		if (ts->irq_enabled) {
+			disable_irq(ts->client->irq);
+			ts->irq_enabled = false;
+		}
+	}
+
+	desc = irq_data_to_desc(irq_get_irq_data(ts->client->irq));
+	NVT_LOG("enable=%d, desc->depth=%d\n", enable, desc->depth);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen spi read/write core function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static inline int32_t spi_read_write(struct spi_device *client, uint8_t *buf, size_t len, NVT_SPI_RW rw)
+{
+	struct spi_message m;
+	struct spi_transfer t = {
+		.len    = len,
+	};
+
+	memcpy(ts->xbuf, buf, len);
+
+	switch (rw) {
+	case NVTREAD:
+		t.tx_buf = ts->xbuf;
+		t.rx_buf = ts->rbuf;
+		t.len    = (len + DUMMY_BYTES);
+		break;
+
+	case NVTWRITE:
+		t.tx_buf = ts->xbuf;
+		break;
+	}
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	return spi_sync(client, &m);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen spi read function.
+
+return:
+	Executive outcomes. 2---succeed. -5---I/O error
+*******************************************************/
+int32_t CTP_SPI_READ(struct spi_device *client, uint8_t *buf, uint16_t len)
+{
+	int32_t ret = -1;
+	int32_t retries = 0;
+
+	mutex_lock(&ts->xbuf_lock);
+
+	buf[0] = SPI_READ_MASK(buf[0]);
+
+	while (retries < 5) {
+		ret = spi_read_write(client, buf, len, NVTREAD);
+		if (ret == 0)
+			break;
+		retries++;
+	}
+
+	if (unlikely(retries == 5)) {
+		NVT_ERR("read error, ret=%d\n", ret);
+		ret = -EIO;
+	} else {
+		memcpy((buf+1), (ts->rbuf+2), (len-1));
+	}
+
+	mutex_unlock(&ts->xbuf_lock);
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen spi write function.
+
+return:
+	Executive outcomes. 1---succeed. -5---I/O error
+*******************************************************/
+int32_t CTP_SPI_WRITE(struct spi_device *client, uint8_t *buf, uint16_t len)
+{
+	int32_t ret = -1;
+	int32_t retries = 0;
+
+	mutex_lock(&ts->xbuf_lock);
+
+	buf[0] = SPI_WRITE_MASK(buf[0]);
+
+	while (retries < 5) {
+		ret = spi_read_write(client, buf, len, NVTWRITE);
+		if (ret == 0)
+			break;
+		retries++;
+	}
+
+	if (unlikely(retries == 5)) {
+		NVT_ERR("error, ret=%d\n", ret);
+		ret = -EIO;
+	}
+
+	mutex_unlock(&ts->xbuf_lock);
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen set index/page/addr address.
+
+return:
+	Executive outcomes. 0---succeed. -5---access fail.
+*******************************************************/
+int32_t nvt_set_page(uint32_t addr)
+{
+	uint8_t buf[4] = {0};
+
+	buf[0] = 0xFF;	//set index/page/addr command
+	buf[1] = (addr >> 15) & 0xFF;
+	buf[2] = (addr >> 7) & 0xFF;
+
+	return CTP_SPI_WRITE(ts->client, buf, 3);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen write data to specify address.
+
+return:
+	Executive outcomes. 0---succeed. -5---access fail.
+*******************************************************/
+int32_t nvt_write_addr(uint32_t addr, uint8_t data)
+{
+	int32_t ret = 0;
+	uint8_t buf[4] = {0};
+
+	//---set xdata index---
+	buf[0] = 0xFF;	//set index/page/addr command
+	buf[1] = (addr >> 15) & 0xFF;
+	buf[2] = (addr >> 7) & 0xFF;
+	ret = CTP_SPI_WRITE(ts->client, buf, 3);
+	if (ret) {
+		NVT_ERR("set page 0x%06X failed, ret = %d\n", addr, ret);
+		return ret;
+	}
+
+	//---write data to index---
+	buf[0] = addr & (0x7F);
+	buf[1] = data;
+	ret = CTP_SPI_WRITE(ts->client, buf, 2);
+	if (ret) {
+		NVT_ERR("write data to 0x%06X failed, ret = %d\n", addr, ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen enable hw bld crc function.
+
+return:
+	N/A.
+*******************************************************/
+void nvt_bld_crc_enable(void)
+{
+	uint8_t buf[2] = {0};
+
+	//---set xdata index to BLD_CRC_EN_ADDR---
+	nvt_set_page(ts->mmap->BLD_CRC_EN_ADDR);
+
+	//---read data from index---
+	buf[0] = ts->mmap->BLD_CRC_EN_ADDR & (0x7F);
+	buf[1] = 0xFF;
+	CTP_SPI_READ(ts->client, buf, 2);
+
+	//---write data to index---
+	buf[0] = ts->mmap->BLD_CRC_EN_ADDR & (0x7F);
+	buf[1] = buf[1] | (0x01 << 7);
+	CTP_SPI_WRITE(ts->client, buf, 2);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen clear status & enable fw crc function.
+
+return:
+	N/A.
+*******************************************************/
+void nvt_fw_crc_enable(void)
+{
+	uint8_t buf[2] = {0};
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR);
+
+	//---clear fw reset status---
+	buf[0] = EVENT_MAP_RESET_COMPLETE & (0x7F);
+	buf[1] = 0x00;
+	CTP_SPI_WRITE(ts->client, buf, 2);
+
+	//---enable fw crc---
+	buf[0] = EVENT_MAP_HOST_CMD & (0x7F);
+	buf[1] = 0xAE;	//enable fw crc command
+	CTP_SPI_WRITE(ts->client, buf, 2);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen set boot ready function.
+
+return:
+	N/A.
+*******************************************************/
+void nvt_boot_ready(void)
+{
+	//---write BOOT_RDY status cmds---
+	nvt_write_addr(ts->mmap->BOOT_RDY_ADDR, 1);
+
+	mdelay(5);
+
+	if (!ts->hw_crc) {
+		//---write BOOT_RDY status cmds---
+		nvt_write_addr(ts->mmap->BOOT_RDY_ADDR, 0);
+
+		//---write POR_CD cmds---
+		nvt_write_addr(ts->mmap->POR_CD_ADDR, 0xA0);
+	}
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen eng reset cmd
+    function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_eng_reset(void)
+{
+	//---eng reset cmds to ENG_RST_ADDR---
+	nvt_write_addr(ENG_RST_ADDR, 0x5A);
+
+	mdelay(1);	//wait tMCU_Idle2TP_REX_Hi after TP_RST
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen reset MCU
+    function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_sw_reset(void)
+{
+	//---software reset cmds to SWRST_N8_ADDR---
+	nvt_write_addr(SWRST_N8_ADDR, 0x55);
+
+	msleep(10);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen reset MCU then into idle mode
+    function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_sw_reset_idle(void)
+{
+	//---MCU idle cmds to SWRST_N8_ADDR---
+	nvt_write_addr(SWRST_N8_ADDR, 0xAA);
+
+	msleep(15);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen reset MCU (boot) function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_bootloader_reset(void)
+{
+	//---reset cmds to SWRST_N8_ADDR---
+	nvt_write_addr(SWRST_N8_ADDR, 0x69);
+
+	mdelay(5);	//wait tBRST2FR after Bootload RST
+
+	if (SPI_RD_FAST_ADDR) {
+		/* disable SPI_RD_FAST */
+		nvt_write_addr(SPI_RD_FAST_ADDR, 0x00);
+	}
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen clear FW status function.
+
+return:
+	Executive outcomes. 0---succeed. -1---fail.
+*******************************************************/
+int32_t nvt_clear_fw_status(void)
+{
+	uint8_t buf[8] = {0};
+	int32_t i = 0;
+	const int32_t retry = 20;
+
+	for (i = 0; i < retry; i++) {
+		//---set xdata index to EVENT BUF ADDR---
+		nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE);
+
+		//---clear fw status---
+		buf[0] = EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE;
+		buf[1] = 0x00;
+		CTP_SPI_WRITE(ts->client, buf, 2);
+
+		//---read fw status---
+		buf[0] = EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE;
+		buf[1] = 0xFF;
+		CTP_SPI_READ(ts->client, buf, 2);
+
+		if (buf[1] == 0x00)
+			break;
+
+		usleep_range(10000, 10000);
+	}
+
+	if (i >= retry) {
+		NVT_ERR("failed, i=%d, buf[1]=0x%02X\n", i, buf[1]);
+		return -EPERM;
+	} else {
+		return 0;
+	}
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen check FW status function.
+
+return:
+	Executive outcomes. 0---succeed. -1---failed.
+*******************************************************/
+int32_t nvt_check_fw_status(void)
+{
+	uint8_t buf[8] = {0};
+	int32_t i = 0;
+	const int32_t retry = 50;
+
+	for (i = 0; i < retry; i++) {
+		//---set xdata index to EVENT BUF ADDR---
+		nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE);
+
+		//---read fw status---
+		buf[0] = EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE;
+		buf[1] = 0x00;
+		CTP_SPI_READ(ts->client, buf, 2);
+
+		if ((buf[1] & 0xF0) == 0xA0)
+			break;
+
+		usleep_range(10000, 10000);
+	}
+
+	if (i >= retry) {
+		NVT_ERR("failed, i=%d, buf[1]=0x%02X\n", i, buf[1]);
+		return -EPERM;
+	} else {
+		return 0;
+	}
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen check FW reset state function.
+
+return:
+	Executive outcomes. 0---succeed. -1---failed.
+*******************************************************/
+int32_t nvt_check_fw_reset_state(RST_COMPLETE_STATE check_reset_state)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+	int32_t retry = 0;
+	int32_t retry_max = (check_reset_state == RESET_STATE_INIT) ? 10 : 50;
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_RESET_COMPLETE);
+
+	while (1) {
+		//---read reset state---
+		buf[0] = EVENT_MAP_RESET_COMPLETE;
+		buf[1] = 0x00;
+		CTP_SPI_READ(ts->client, buf, 6);
+
+		if ((buf[1] >= check_reset_state) && (buf[1] <= RESET_STATE_MAX)) {
+			ret = 0;
+			break;
+		}
+
+		retry++;
+		if (unlikely(retry > retry_max)) {
+			NVT_ERR("error, retry=%d, buf[1]=0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X\n",
+				retry, buf[1], buf[2], buf[3], buf[4], buf[5]);
+			ret = -1;
+			break;
+		}
+
+		usleep_range(10000, 10000);
+	}
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen get novatek project id information
+	function.
+
+return:
+	Executive outcomes. 0---success. -1---fail.
+*******************************************************/
+int32_t nvt_read_pid(void)
+{
+	uint8_t buf[3] = {0};
+	int32_t ret = 0;
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_PROJECTID);
+
+	//---read project id---
+	buf[0] = EVENT_MAP_PROJECTID;
+	buf[1] = 0x00;
+	buf[2] = 0x00;
+	CTP_SPI_READ(ts->client, buf, 3);
+
+	ts->nvt_pid = (buf[2] << 8) + buf[1];
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR);
+
+	NVT_LOG("PID=%04X\n", ts->nvt_pid);
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen get firmware related information
+	function.
+
+return:
+	Executive outcomes. 0---success. -1---fail.
+*******************************************************/
+int32_t nvt_get_fw_info(void)
+{
+	uint8_t buf[64] = {0};
+	uint8_t tp_info_buf[64] = {0};
+	uint32_t retry_count = 0;
+	int32_t ret = 0;
+
+info_retry:
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_FWINFO);
+
+	//---read fw info---
+	buf[0] = EVENT_MAP_FWINFO;
+	CTP_SPI_READ(ts->client, buf, 17);
+	ts->fw_ver = buf[1];
+	ts->x_num = buf[3];
+	ts->y_num = buf[4];
+	ts->abs_x_max = (uint16_t)((buf[5] << 8) | buf[6]);
+	ts->abs_y_max = (uint16_t)((buf[7] << 8) | buf[8]);
+	ts->max_button_num = buf[11];
+
+	//---clear x_num, y_num if fw info is broken---
+	if ((buf[1] + buf[2]) != 0xFF) {
+		NVT_ERR("FW info is broken! fw_ver=0x%02X, ~fw_ver=0x%02X\n", buf[1], buf[2]);
+		ts->fw_ver = 0;
+		ts->x_num = 18;
+		ts->y_num = 32;
+		ts->abs_x_max = TOUCH_DEFAULT_MAX_WIDTH;
+		ts->abs_y_max = TOUCH_DEFAULT_MAX_HEIGHT;
+		ts->max_button_num = TOUCH_KEY_NUM;
+
+		if (retry_count < 3) {
+			retry_count++;
+			NVT_ERR("retry_count=%d\n", retry_count);
+			goto info_retry;
+		} else {
+			NVT_ERR("Set default fw_ver=%d, x_num=%d, y_num=%d, "
+					"abs_x_max=%d, abs_y_max=%d, max_button_num=%d!\n",
+					ts->fw_ver, ts->x_num, ts->y_num,
+					ts->abs_x_max, ts->abs_y_max, ts->max_button_num);
+			ret = -1;
+		}
+	} else {
+		ret = 0;
+	}
+
+	NVT_LOG("fw_ver = 0x%02X, fw_type = 0x%02X\n", ts->fw_ver, buf[14]);
+
+#ifdef CHECK_TOUCH_VENDOR
+	switch (ts->touch_vendor_id) {
+	case TP_VENDOR_HUAXING:
+		snprintf(tp_info_buf, sizeof(tp_info_buf), "[Vendor]huaxing,[FW]0x%02x,[IC]nt36672c\n", ts->fw_ver);
+		break;
+	case TP_VENDOR_TIANMA:
+		snprintf(tp_info_buf, sizeof(tp_info_buf), "[Vendor]tianma,[FW]0x%02x,[IC]nt36672c\n", ts->fw_ver);
+		break;
+	}
+#else
+	snprintf(tp_info_buf, PAGE_SIZE, "[Vendor]unknown,[FW]0x%02x,[IC]nt36672c\n", ts->fw_ver);
+#endif
+
+	//---Get Novatek PID---
+	nvt_read_pid();
+
+	return ret;
+}
+
+/*******************************************************
+  Create Device Node (Proc Entry)
+*******************************************************/
+#if NVT_TOUCH_PROC
+static struct proc_dir_entry *NVT_proc_entry;
+#define DEVICE_NAME	"NVTSPI"
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/NVTSPI read function.
+
+return:
+	Executive outcomes. 2---succeed. -5,-14---failed.
+*******************************************************/
+static ssize_t nvt_flash_read(struct file *file, char __user *buff, size_t count, loff_t *offp)
+{
+	uint8_t *str = NULL;
+	int32_t ret = 0;
+	int32_t retries = 0;
+	int8_t spi_wr = 0;
+	uint8_t *buf;
+
+	if ((count > NVT_TRANSFER_LEN + 3) || (count < 3)) {
+		NVT_ERR("invalid transfer len!\n");
+		return -EFAULT;
+	}
+
+	/* allocate buffer for spi transfer */
+	str = (uint8_t *)kzalloc((count), GFP_KERNEL);
+	if (str == NULL) {
+		NVT_ERR("kzalloc for buf failed!\n");
+		ret = -ENOMEM;
+		goto kzalloc_failed;
+	}
+
+	buf = (uint8_t *)kzalloc((count), GFP_KERNEL | GFP_DMA);
+	if (buf == NULL) {
+		NVT_ERR("kzalloc for buf failed!\n");
+		ret = -ENOMEM;
+		kfree(str);
+		str = NULL;
+		goto kzalloc_failed;
+	}
+
+	if (copy_from_user(str, buff, count)) {
+		NVT_ERR("copy from user error\n");
+		ret = -EFAULT;
+		goto out;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	/*
+	 * stop esd check work to avoid case that 0x77 report righ after here to enable esd check again
+	 * finally lead to trigger esd recovery bootloader reset
+	 */
+	cancel_delayed_work_sync(&nvt_esd_check_work);
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	spi_wr = str[0] >> 7;
+	memcpy(buf, str+2, ((str[0] & 0x7F) << 8) | str[1]);
+
+	if (spi_wr == NVTWRITE) {	//SPI write
+		while (retries < 20) {
+			ret = CTP_SPI_WRITE(ts->client, buf, ((str[0] & 0x7F) << 8) | str[1]);
+			if (!ret)
+				break;
+			else
+				NVT_ERR("error, retries=%d, ret=%d\n", retries, ret);
+
+			retries++;
+		}
+
+		if (unlikely(retries == 20)) {
+			NVT_ERR("error, ret = %d\n", ret);
+			ret = -EIO;
+			goto out;
+		}
+	} else if (spi_wr == NVTREAD) {	//SPI read
+		while (retries < 20) {
+			ret = CTP_SPI_READ(ts->client, buf, ((str[0] & 0x7F) << 8) | str[1]);
+			if (!ret)
+				break;
+			else
+				NVT_ERR("error, retries=%d, ret=%d\n", retries, ret);
+
+			retries++;
+		}
+
+		memcpy(str+2, buf, ((str[0] & 0x7F) << 8) | str[1]);
+		// copy buff to user if spi transfer
+		if (retries < 20) {
+			if (copy_to_user(buff, str, count)) {
+				ret = -EFAULT;
+				goto out;
+			}
+		}
+
+		if (unlikely(retries == 20)) {
+			NVT_ERR("error, ret = %d\n", ret);
+			ret = -EIO;
+			goto out;
+		}
+	} else {
+		NVT_ERR("Call error, str[0]=%d\n", str[0]);
+		ret = -EFAULT;
+		goto out;
+	}
+
+out:
+	kfree(str);
+    kfree(buf);
+kzalloc_failed:
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/NVTSPI open function.
+
+return:
+	Executive outcomes. 0---succeed. -12---failed.
+*******************************************************/
+static int32_t nvt_flash_open(struct inode *inode, struct file *file)
+{
+	struct nvt_flash_data *dev;
+
+	dev = kmalloc(sizeof(struct nvt_flash_data), GFP_KERNEL);
+	if (dev == NULL) {
+		NVT_ERR("Failed to allocate memory for nvt flash data\n");
+		return -ENOMEM;
+	}
+
+	rwlock_init(&dev->lock);
+	file->private_data = dev;
+
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/NVTSPI close function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t nvt_flash_close(struct inode *inode, struct file *file)
+{
+	struct nvt_flash_data *dev = file->private_data;
+
+	//if (dev)
+		kfree(dev);
+
+	return 0;
+}
+
+static const struct proc_ops nvt_flash_fops = {
+	.proc_open = nvt_flash_open,
+	.proc_release = nvt_flash_close,
+	.proc_read = nvt_flash_read,
+};
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/NVTSPI initial function.
+
+return:
+	Executive outcomes. 0---succeed. -12---failed.
+*******************************************************/
+static int32_t nvt_flash_proc_init(void)
+{
+	NVT_proc_entry = proc_create(DEVICE_NAME, 0444, NULL, &nvt_flash_fops);
+	if (NVT_proc_entry == NULL) {
+		NVT_ERR("Failed!\n");
+		return -ENOMEM;
+	} else {
+		NVT_LOG("Succeeded!\n");
+	}
+
+	NVT_LOG("============================================================\n");
+	NVT_LOG("Create /proc/%s\n", DEVICE_NAME);
+	NVT_LOG("============================================================\n");
+
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/NVTSPI deinitial function.
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_flash_proc_deinit(void)
+{
+	if (NVT_proc_entry != NULL) {
+		remove_proc_entry(DEVICE_NAME, NULL);
+		NVT_proc_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", DEVICE_NAME);
+	}
+}
+#endif
+
+#if WAKEUP_GESTURE
+#define GESTURE_WORD_C          12
+#define GESTURE_WORD_W          13
+#define GESTURE_WORD_V          14
+#define GESTURE_DOUBLE_CLICK    15
+#define GESTURE_WORD_Z          16
+#define GESTURE_WORD_M          17
+#define GESTURE_WORD_O          18
+#define GESTURE_WORD_e          19
+#define GESTURE_WORD_S          20
+#define GESTURE_SLIDE_UP        21
+#define GESTURE_SLIDE_DOWN      22
+#define GESTURE_SLIDE_LEFT      23
+#define GESTURE_SLIDE_RIGHT     24
+/* customized gesture id */
+#define DATA_PROTOCOL           30
+
+/* function page definition */
+#define FUNCPAGE_GESTURE         1
+
+/*******************************************************
+Description:
+	Novatek touchscreen wake up gesture key report function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_ts_wakeup_gesture_report(uint8_t gesture_id, uint8_t *data)
+{
+	uint32_t keycode = 0;
+	uint8_t func_type = data[2];
+	uint8_t func_id = data[3];
+
+	/* support fw specifal data protocol */
+	if ((gesture_id == DATA_PROTOCOL) && (func_type == FUNCPAGE_GESTURE)) {
+		gesture_id = func_id;
+	} else if (gesture_id > DATA_PROTOCOL) {
+		NVT_ERR("gesture_id %d is invalid, func_type=%d, func_id=%d\n", gesture_id, func_type, func_id);
+		return;
+	}
+
+	NVT_LOG("gesture_id = %d\n", gesture_id);
+
+	switch (gesture_id) {
+	case GESTURE_WORD_C:
+		NVT_LOG("Gesture : Word-C.\n");
+		keycode = gesture_key_array[0];
+		break;
+	case GESTURE_WORD_W:
+		NVT_LOG("Gesture : Word-W.\n");
+		keycode = gesture_key_array[1];
+		break;
+	case GESTURE_WORD_V:
+		NVT_LOG("Gesture : Word-V.\n");
+		keycode = gesture_key_array[2];
+		break;
+	case GESTURE_DOUBLE_CLICK:
+		NVT_LOG("Gesture : Double Click.\n");
+		keycode = gesture_key_array[3];
+		break;
+	case GESTURE_WORD_Z:
+		NVT_LOG("Gesture : Word-Z.\n");
+		keycode = gesture_key_array[4];
+		break;
+	case GESTURE_WORD_M:
+		NVT_LOG("Gesture : Word-M.\n");
+		keycode = gesture_key_array[5];
+		break;
+	case GESTURE_WORD_O:
+		NVT_LOG("Gesture : Word-O.\n");
+		keycode = gesture_key_array[6];
+		break;
+	case GESTURE_WORD_e:
+		NVT_LOG("Gesture : Word-e.\n");
+		keycode = gesture_key_array[7];
+		break;
+	case GESTURE_WORD_S:
+		NVT_LOG("Gesture : Word-S.\n");
+		keycode = gesture_key_array[8];
+		break;
+	case GESTURE_SLIDE_UP:
+		NVT_LOG("Gesture : Slide UP.\n");
+		keycode = gesture_key_array[9];
+		break;
+	case GESTURE_SLIDE_DOWN:
+		NVT_LOG("Gesture : Slide DOWN.\n");
+		keycode = gesture_key_array[10];
+		break;
+	case GESTURE_SLIDE_LEFT:
+		NVT_LOG("Gesture : Slide LEFT.\n");
+		keycode = gesture_key_array[11];
+		break;
+	case GESTURE_SLIDE_RIGHT:
+		NVT_LOG("Gesture : Slide RIGHT.\n");
+		keycode = gesture_key_array[12];
+		break;
+	default:
+		break;
+	}
+
+	if (keycode > 0) {
+		input_report_key(ts->input_dev, keycode, 1);
+		input_sync(ts->input_dev);
+		input_report_key(ts->input_dev, keycode, 0);
+		input_sync(ts->input_dev);
+	}
+}
+#endif
+
+/*******************************************************
+Description:
+	Novatek touchscreen parse device tree function.
+
+return:
+	n.a.
+*******************************************************/
+#ifdef CONFIG_OF
+static int32_t nvt_parse_dt(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	int32_t ret = 0;
+
+#if NVT_TOUCH_SUPPORT_HW_RST
+	ts->reset_gpio = of_get_named_gpio_flags(np, "novatek,reset-gpio", 0, &ts->reset_flags);
+	NVT_LOG("novatek,reset-gpio=%d\n", ts->reset_gpio);
+#endif
+	ts->irq_gpio = of_get_named_gpio_flags(np, "novatek,irq-gpio", 0, &ts->irq_flags);
+	NVT_LOG("novatek,irq-gpio=%d\n", ts->irq_gpio);
+
+	ret = of_property_read_u32(np, "novatek,swrst-n8-addr", &SWRST_N8_ADDR);
+	if (ret) {
+		NVT_ERR("error reading novatek,swrst-n8-addr. ret=%d\n", ret);
+		return ret;
+	} else {
+		NVT_LOG("SWRST_N8_ADDR=0x%06X\n", SWRST_N8_ADDR);
+	}
+
+	ret = of_property_read_u32(np, "novatek,spi-rd-fast-addr", &SPI_RD_FAST_ADDR);
+	if (ret) {
+		NVT_LOG("not support novatek,spi-rd-fast-addr\n");
+		SPI_RD_FAST_ADDR = 0;
+		ret = 0;
+	} else {
+		NVT_LOG("SPI_RD_FAST_ADDR=0x%06X\n", SPI_RD_FAST_ADDR);
+	}
+
+	return ret;
+}
+#else
+static int32_t nvt_parse_dt(struct device *dev)
+{
+#if NVT_TOUCH_SUPPORT_HW_RST
+	ts->reset_gpio = NVTTOUCH_RST_PIN;
+#endif
+	ts->irq_gpio = NVTTOUCH_INT_PIN;
+	return 0;
+}
+#endif
+
+/*******************************************************
+Description:
+	Novatek touchscreen config and request gpio
+
+return:
+	Executive outcomes. 0---succeed. not 0---failed.
+*******************************************************/
+static int nvt_gpio_config(struct nvt_ts_data *ts)
+{
+	int32_t ret = 0;
+
+#if NVT_TOUCH_SUPPORT_HW_RST
+	/* request RST-pin (Output/High) */
+	if (gpio_is_valid(ts->reset_gpio)) {
+		ret = gpio_request_one(ts->reset_gpio, GPIOF_OUT_INIT_LOW, "NVT-tp-rst");
+		if (ret) {
+			NVT_ERR("Failed to request NVT-tp-rst GPIO\n");
+			goto err_request_reset_gpio;
+		}
+	}
+#endif
+
+	/* request INT-pin (Input) */
+	if (gpio_is_valid(ts->irq_gpio)) {
+		ret = gpio_request_one(ts->irq_gpio, GPIOF_IN, "NVT-int");
+		if (ret) {
+			NVT_ERR("Failed to request NVT-int GPIO\n");
+			goto err_request_irq_gpio;
+		}
+	}
+
+	return ret;
+
+err_request_irq_gpio:
+#if NVT_TOUCH_SUPPORT_HW_RST
+	gpio_free(ts->reset_gpio);
+err_request_reset_gpio:
+#endif
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen deconfig gpio
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_gpio_deconfig(struct nvt_ts_data *ts)
+{
+	if (gpio_is_valid(ts->irq_gpio))
+		gpio_free(ts->irq_gpio);
+#if NVT_TOUCH_SUPPORT_HW_RST
+	if (gpio_is_valid(ts->reset_gpio))
+		gpio_free(ts->reset_gpio);
+#endif
+}
+
+#if NVT_TOUCH_ESD_PROTECT
+void nvt_esd_check_enable(uint8_t enable)
+{
+	/* update interrupt timer */
+	irq_timer = jiffies;
+	/* clear esd_retry counter, if protect function is enabled */
+	esd_retry = enable ? 0 : esd_retry;
+	/* enable/disable esd check flag */
+	esd_check = enable;
+}
+
+static uint8_t nvt_fw_recovery(uint8_t *point_data)
+{
+	uint8_t i = 0;
+	uint8_t detected = true;
+
+	/* check pattern */
+	for (i = 1 ; i < 7 ; i++) {
+		if (point_data[i] != 0x77) {
+			detected = false;
+			break;
+		}
+	}
+
+	return detected;
+}
+
+static void nvt_esd_check_func(struct work_struct *work)
+{
+	unsigned int timer = jiffies_to_msecs(jiffies - irq_timer);
+
+	//NVT_LOG("esd_check = %d (retry %d)\n", esd_check, esd_retry);	//DEBUG
+
+	if ((timer > NVT_TOUCH_ESD_CHECK_PERIOD) && esd_check) {
+		mutex_lock(&ts->lock);
+		NVT_ERR("do ESD recovery, timer = %d, retry = %d\n", timer, esd_retry);
+		/* do esd recovery, reload fw */
+		nvt_update_firmware(ts->boot_update_firmware_name);
+		mutex_unlock(&ts->lock);
+		/* update interrupt timer */
+		irq_timer = jiffies;
+		/* update esd_retry counter */
+		esd_retry++;
+	}
+
+	queue_delayed_work(nvt_esd_check_wq, &nvt_esd_check_work,
+			msecs_to_jiffies(NVT_TOUCH_ESD_CHECK_PERIOD));
+}
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+#if NVT_TOUCH_WDT_RECOVERY
+static uint8_t recovery_cnt;
+static uint8_t nvt_wdt_fw_recovery(uint8_t *point_data)
+{
+   uint32_t recovery_cnt_max = 10;
+   uint8_t recovery_enable = false;
+   uint8_t i = 0;
+
+   recovery_cnt++;
+
+   /* check pattern */
+   for (i = 1 ; i < 7 ; i++) {
+		if ((point_data[i] != 0xFD) && (point_data[i] != 0xFE)) {
+			recovery_cnt = 0;
+			break;
+       }
+   }
+
+   if (recovery_cnt > recovery_cnt_max) {
+       recovery_enable = true;
+       recovery_cnt = 0;
+   }
+
+   return recovery_enable;
+}
+#endif	/* #if NVT_TOUCH_WDT_RECOVERY */
+
+#define POINT_DATA_LEN 65
+/*******************************************************
+Description:
+	Novatek touchscreen work function.
+
+return:
+	n.a.
+*******************************************************/
+static irqreturn_t nvt_ts_work_func(int irq, void *data)
+{
+	int32_t ret = -1;
+	uint8_t point_data[POINT_DATA_LEN + 1 + DUMMY_BYTES] = {0};
+	uint32_t position = 0;
+	uint32_t input_x = 0;
+	uint32_t input_y = 0;
+	uint32_t input_w = 0;
+	uint32_t input_p = 0;
+	uint8_t input_id = 0;
+#if MT_PROTOCOL_B
+	uint8_t press_id[TOUCH_MAX_FINGER_NUM] = {0};
+#endif /* MT_PROTOCOL_B */
+	int32_t i = 0;
+	int32_t finger_cnt = 0;
+
+#if WAKEUP_GESTURE
+#ifdef CONFIG_PM
+	if (ts->dev_pm_suspend && ts->is_gesture_mode) {
+		ret = wait_for_completion_timeout(&ts->dev_pm_suspend_completion, msecs_to_jiffies(700));
+		if (!ret) {
+			NVT_ERR("system(spi bus) can't finished resuming procedure, skip it");
+			return IRQ_HANDLED;
+		}
+	}
+#endif
+#endif
+
+	mutex_lock(&ts->lock);
+
+	ret = CTP_SPI_READ(ts->client, point_data, POINT_DATA_LEN + 1);
+	if (ret < 0) {
+		NVT_ERR("CTP_SPI_READ failed.(%d)\n", ret);
+		goto XFER_ERROR;
+	}
+
+/*
+	//--- dump SPI buf ---
+	for (i = 0; i < 10; i++) {
+		printk("%02X %02X %02X %02X %02X %02X  ",
+			point_data[1+i*6], point_data[2+i*6], point_data[3+i*6],
+			point_data[4+i*6], point_data[5+i*6], point_data[6+i*6]);
+	}
+	printk("\n");
+*/
+
+#if NVT_TOUCH_WDT_RECOVERY
+   /* ESD protect by WDT */
+   if (nvt_wdt_fw_recovery(point_data)) {
+       NVT_ERR("Recover for fw reset, %02X\n", point_data[1]);
+       nvt_update_firmware(ts->boot_update_firmware_name);
+       goto XFER_ERROR;
+   }
+#endif /* #if NVT_TOUCH_WDT_RECOVERY */
+
+#if NVT_TOUCH_ESD_PROTECT
+	/* ESD protect by FW handshake */
+	if (nvt_fw_recovery(point_data)) {
+		nvt_esd_check_enable(true);
+		goto XFER_ERROR;
+	}
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	input_id = (uint8_t)(point_data[1] >> 3);
+#if WAKEUP_GESTURE
+	if (bTouchIsAwake == 0) {
+		//input_id = (uint8_t)(point_data[1] >> 3);
+		nvt_ts_wakeup_gesture_report(input_id, point_data);
+		mutex_unlock(&ts->lock);
+		return IRQ_HANDLED;
+	}
+#endif
+	finger_cnt = 0;
+
+	for (i = 0; i < ts->max_touch_num; i++) {
+		position = 1 + 6 * i;
+		input_id = (uint8_t)(point_data[position + 0] >> 3);
+		if ((input_id == 0) || (input_id > ts->max_touch_num))
+			continue;
+
+		if (((point_data[position] & 0x07) == 0x01) || ((point_data[position] & 0x07) == 0x02)) {
+			//finger down (enter & moving)
+#if NVT_TOUCH_ESD_PROTECT
+			/* update interrupt timer */
+			irq_timer = jiffies;
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+			input_x = (uint32_t)(point_data[position + 1] << 4) + (uint32_t) (point_data[position + 3] >> 4);
+			input_y = (uint32_t)(point_data[position + 2] << 4) + (uint32_t) (point_data[position + 3] & 0x0F);
+			if ((input_x < 0) || (input_y < 0))
+				continue;
+			if ((input_x > ts->abs_x_max) || (input_y > ts->abs_y_max))
+				continue;
+			input_w = (uint32_t)(point_data[position + 4]);
+			if (input_w == 0)
+				input_w = 1;
+			if (i < 2) {
+				input_p = (uint32_t)(point_data[position + 5]) + (uint32_t)(point_data[i + 63] << 8);
+				if (input_p > TOUCH_FORCE_NUM)
+					input_p = TOUCH_FORCE_NUM;
+			} else {
+				input_p = (uint32_t)(point_data[position + 5]);
+			}
+			if (input_p == 0)
+				input_p = 1;
+
+#if MT_PROTOCOL_B
+			press_id[input_id - 1] = 1;
+			input_mt_slot(ts->input_dev, input_id - 1);
+			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
+#else /* MT_PROTOCOL_B */
+			input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, input_id - 1);
+			input_report_key(ts->input_dev, BTN_TOUCH, 1);
+#endif /* MT_PROTOCOL_B */
+
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_X, input_x);
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, input_y);
+			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, input_w);
+			input_report_abs(ts->input_dev, ABS_MT_PRESSURE, input_p);
+
+#if MT_PROTOCOL_B
+#else /* MT_PROTOCOL_B */
+			input_mt_sync(ts->input_dev);
+#endif /* MT_PROTOCOL_B */
+
+			finger_cnt++;
+		}
+	}
+
+#if MT_PROTOCOL_B
+	for (i = 0; i < ts->max_touch_num; i++) {
+		if (press_id[i] != 1) {
+			input_mt_slot(ts->input_dev, i);
+			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+			input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 0);
+			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+		}
+	}
+
+	input_report_key(ts->input_dev, BTN_TOUCH, (finger_cnt > 0));
+#else /* MT_PROTOCOL_B */
+	if (finger_cnt == 0) {
+		input_report_key(ts->input_dev, BTN_TOUCH, 0);
+		input_mt_sync(ts->input_dev);
+	}
+#endif /* MT_PROTOCOL_B */
+
+#if TOUCH_KEY_NUM > 0
+	if (point_data[61] == 0xF8) {
+#if NVT_TOUCH_ESD_PROTECT
+		/* update interrupt timer */
+		irq_timer = jiffies;
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+		for (i = 0; i < ts->max_button_num; i++) {
+			input_report_key(ts->input_dev, touch_key_array[i], ((point_data[62] >> i) & 0x01));
+		}
+	} else {
+		for (i = 0; i < ts->max_button_num; i++) {
+			input_report_key(ts->input_dev, touch_key_array[i], 0);
+		}
+	}
+#endif
+
+	input_sync(ts->input_dev);
+
+XFER_ERROR:
+
+	mutex_unlock(&ts->lock);
+
+	return IRQ_HANDLED;
+}
+
+
+/*******************************************************
+Description:
+	Novatek touchscreen check chip version trim function.
+
+return:
+	Executive outcomes. 0---NVT IC. -1---not NVT IC.
+*******************************************************/
+static int8_t nvt_ts_check_chip_ver_trim(void)
+{
+	uint8_t buf[8] = {0};
+	int32_t retry = 0;
+	int32_t list = 0;
+	int32_t i = 0;
+	int32_t found_nvt_chip = 0;
+	int32_t ret = -1;
+
+	//---Check for 5 times---
+	for (retry = 5; retry > 0; retry--) {
+
+		nvt_bootloader_reset();
+
+		//---set xdata index to 0x1F64E---
+		nvt_set_page(0x1F64E);
+
+		buf[0] = 0x4E;
+		buf[1] = 0x00;
+		buf[2] = 0x00;
+		buf[3] = 0x00;
+		buf[4] = 0x00;
+		buf[5] = 0x00;
+		buf[6] = 0x00;
+		CTP_SPI_READ(ts->client, buf, 7);
+		NVT_LOG("buf[1]=0x%02X, buf[2]=0x%02X, buf[3]=0x%02X, buf[4]=0x%02X, buf[5]=0x%02X, buf[6]=0x%02X\n",
+			buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
+
+		// compare read chip id on supported list
+		for (list = 0; list < (sizeof(trim_id_table) / sizeof(struct nvt_ts_trim_id_table)); list++) {
+			found_nvt_chip = 0;
+
+			// compare each byte
+			for (i = 0; i < NVT_ID_BYTE_MAX; i++) {
+				if (trim_id_table[list].mask[i]) {
+					if (buf[i + 1] != trim_id_table[list].id[i])
+						break;
+				}
+			}
+
+			if (i == NVT_ID_BYTE_MAX) {
+				found_nvt_chip = 1;
+			}
+
+			if (found_nvt_chip) {
+				NVT_LOG("This is NVT touch IC\n");
+				ts->mmap = trim_id_table[list].mmap;
+				ts->carrier_system = trim_id_table[list].hwinfo->carrier_system;
+				ts->hw_crc = trim_id_table[list].hwinfo->hw_crc;
+				ret = 0;
+				goto out;
+			} else {
+				ts->mmap = NULL;
+				ret = -1;
+			}
+		}
+
+		msleep(10);
+	}
+
+out:
+	return ret;
+}
+
+#if WAKEUP_GESTURE
+/*******************************************************
+Description:
+	Novatek touchscreen driver get regulator function.
+
+return:
+	Executive outcomes. 0---succeed. negative---failed
+*******************************************************/
+static int32_t nvt_ts_get_regulator(bool get)
+{
+	int32_t ret = 0;
+
+	NVT_LOG("get/put regulator : %d \n", get);
+
+	if (!get) {
+		goto put_regulator;
+	}
+
+	ts->pwr_vdd = regulator_get(&ts->client->dev, "touch_vddio");
+	if (IS_ERR_OR_NULL(ts->pwr_vdd)) {
+		ret = PTR_ERR(ts->pwr_vdd);
+		NVT_ERR("Failed to get vdd regulator");
+		goto put_regulator;
+	} else {
+		if (regulator_count_voltages(ts->pwr_vdd) > 0) {
+			ret = regulator_set_voltage(ts->pwr_vdd,
+										1800000,
+										1800000);
+		if (ret) {
+				NVT_ERR("vddio regulator set_vtg failed,ret=%d", ret);
+				goto put_regulator;
+			}
+		}
+	}
+
+	ts->pwr_lab = regulator_get(&ts->client->dev, "touch_lab");
+	if (IS_ERR_OR_NULL(ts->pwr_lab)) {
+		ret = PTR_ERR(ts->pwr_lab);
+		NVT_ERR("Failed to get lab regulator");
+		goto put_regulator;
+	}
+
+	ts->pwr_ibb = regulator_get(&ts->client->dev, "touch_ibb");
+	if (IS_ERR_OR_NULL(ts->pwr_ibb)) {
+		ret = PTR_ERR(ts->pwr_ibb);
+		NVT_ERR("Failed to get ibb regulator");
+		goto put_regulator;
+	}
+
+	return 0;
+
+put_regulator:
+	if (ts->pwr_vdd) {
+		regulator_put(ts->pwr_vdd);
+		ts->pwr_vdd = NULL;
+	}
+
+	if (ts->pwr_lab) {
+		regulator_put(ts->pwr_lab);
+		ts->pwr_lab = NULL;
+	}
+
+	if (ts->pwr_ibb) {
+		regulator_put(ts->pwr_ibb);
+		ts->pwr_ibb = NULL;
+	}
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen driver enable regulator function.
+
+return:
+	Executive outcomes. 0---succeed. negative---failed
+*******************************************************/
+static int32_t nvt_ts_enable_regulator(bool en)
+{
+	static bool status;
+	int32_t ret = 0;
+
+	if (status == en) {
+		NVT_LOG("Already %s touch regulator", en?"enable":"disable");
+		return 0;
+	}
+	status = en;
+	NVT_LOG("%s touch regulator", en?"enable":"disable");
+
+	if (!en) {
+		goto disable_ibb_regulator;
+	}
+
+	if (ts->pwr_vdd) {
+		ret = regulator_enable(ts->pwr_vdd);
+		if (ret < 0) {
+			NVT_ERR("Failed to enable vdd regulator");
+			goto exit;
+		}
+	}
+
+	if (ts->pwr_lab) {
+		ret = regulator_enable(ts->pwr_lab);
+		if (ret < 0) {
+			NVT_ERR("Failed to enable lab regulator");
+			goto disable_vdd_regulator;
+		}
+	}
+
+	if (ts->pwr_ibb) {
+		ret = regulator_enable(ts->pwr_ibb);
+		if (ret < 0) {
+			NVT_ERR("Failed to enable ibb regulator");
+			goto disable_lab_regulator;
+		}
+	}
+
+	return 0;
+
+disable_ibb_regulator:
+	if (ts->pwr_ibb)
+		regulator_disable(ts->pwr_ibb);
+
+disable_lab_regulator:
+	if (ts->pwr_lab)
+		regulator_disable(ts->pwr_lab);
+
+disable_vdd_regulator:
+	if (ts->pwr_vdd)
+		regulator_disable(ts->pwr_vdd);
+
+exit:
+	return ret;
+}
+#endif
+
+/*******************************************************
+Description:
+	Novatek touchscreen driver probe function.
+
+return:
+	Executive outcomes. 0---succeed. negative---failed
+*******************************************************/
+static int32_t nvt_ts_probe(struct spi_device *client)
+{
+	int32_t ret = 0;
+#if ((TOUCH_KEY_NUM > 0) || WAKEUP_GESTURE)
+	int32_t retry = 0;
+#endif
+
+	NVT_LOG("start\n");
+
+	//spi_geni_master_dev = NULL;
+
+	ts = kzalloc(sizeof(struct nvt_ts_data), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(ts)) {
+		NVT_ERR("failed to allocated memory for nvt ts data\n");
+		return -ENOMEM;
+	}
+
+	ts->xbuf = (uint8_t *)kzalloc((NVT_TRANSFER_LEN+1), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(ts->xbuf)) {
+		NVT_ERR("kzalloc for xbuf failed!\n");
+		//if (ts) {
+			kfree(ts);
+			ts = NULL;
+		//}
+		return -ENOMEM;
+	}
+
+#ifdef CHECK_TOUCH_VENDOR
+	ts->touch_vendor_id = touch_vendor_id;
+	switch (ts->touch_vendor_id) {
+	case TP_VENDOR_HUAXING:
+		memcpy(ts->boot_update_firmware_name, BOOT_UPDATE_HUAXING_FIRMWARE_NAME,
+				sizeof(BOOT_UPDATE_HUAXING_FIRMWARE_NAME));
+		memcpy(ts->mp_update_firmware_name, MP_UPDATE_HUAXING_FIRMWARE_NAME, sizeof(MP_UPDATE_HUAXING_FIRMWARE_NAME));
+		break;
+	case TP_VENDOR_TIANMA:
+		memcpy(ts->boot_update_firmware_name, BOOT_UPDATE_TIANMA_FIRMWARE_NAME,
+				sizeof(BOOT_UPDATE_TIANMA_FIRMWARE_NAME));
+		memcpy(ts->mp_update_firmware_name, MP_UPDATE_TIANMA_FIRMWARE_NAME, sizeof(MP_UPDATE_TIANMA_FIRMWARE_NAME));
+		break;
+	default:
+		goto err_vendor_check;
+	}
+#else
+	memcpy(ts->boot_update_firmware_name, BOOT_UPDATE_FIRMWARE_NAME, sizeof(BOOT_UPDATE_FIRMWARE_NAME));
+	memcpy(ts->mp_update_firmware_name, MP_UPDATE_FIRMWARE_NAME, sizeof(MP_UPDATE_FIRMWARE_NAME));
+#endif
+
+	ts->client = client;
+	spi_set_drvdata(client, ts);
+
+	//---prepare for spi parameter---
+	if (ts->client->master->flags & SPI_MASTER_HALF_DUPLEX) {
+		NVT_ERR("Full duplex not supported by master\n");
+		ret = -EIO;
+		goto err_ckeck_full_duplex;
+	}
+	ts->client->bits_per_word = 8;
+	ts->client->mode = SPI_MODE_0;
+
+	ret = spi_setup(ts->client);
+	if (ret < 0) {
+		NVT_ERR("Failed to perform SPI setup\n");
+		goto err_spi_setup;
+	}
+
+	NVT_LOG("mode=%d, max_speed_hz=%d\n", ts->client->mode, ts->client->max_speed_hz);
+
+	//---parse dts---
+	ret = nvt_parse_dt(&client->dev);
+	if (ret) {
+		NVT_ERR("parse dt error\n");
+		goto err_spi_setup;
+	}
+
+	//---config regulator---
+#if WAKEUP_GESTURE
+	ret = nvt_ts_get_regulator(true);
+	if (ret < 0) {
+		NVT_ERR("Failed to get register\n");
+		goto err_get_regulator;
+	}
+
+	ret = nvt_ts_enable_regulator(true);
+	if (ret < 0) {
+		NVT_ERR("Failed to enable regulator\n");
+		goto err_enable_regulator;
+	}
+#endif
+
+	//---request and config GPIOs---
+	ret = nvt_gpio_config(ts);
+	if (ret) {
+		NVT_ERR("gpio config error!\n");
+		goto err_gpio_config_failed;
+	}
+
+	mutex_init(&ts->lock);
+	mutex_init(&ts->xbuf_lock);
+	mutex_init(&ts->reg_lock);
+
+	//---eng reset before TP_RESX high
+	nvt_eng_reset();
+
+#if NVT_TOUCH_SUPPORT_HW_RST
+	gpio_set_value(ts->reset_gpio, 1);
+#endif
+
+	// need 10ms delay after POR(power on reset)
+	msleep(10);
+
+	//---check chip version trim---
+	ret = nvt_ts_check_chip_ver_trim();
+	if (ret) {
+		NVT_ERR("chip is not identified\n");
+		ret = -EINVAL;
+		goto err_chipvertrim_failed;
+	}
+
+	ts->abs_x_max = TOUCH_DEFAULT_MAX_WIDTH;
+	ts->abs_y_max = TOUCH_DEFAULT_MAX_HEIGHT;
+
+	//---allocate input device---
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) {
+		NVT_ERR("allocate input device failed\n");
+		ret = -ENOMEM;
+		goto err_input_dev_alloc_failed;
+	}
+
+	ts->max_touch_num = TOUCH_MAX_FINGER_NUM;
+
+#if TOUCH_KEY_NUM > 0
+	ts->max_button_num = TOUCH_KEY_NUM;
+#endif
+
+	ts->int_trigger_type = INT_TRIGGER_TYPE;
+
+
+	//---set input device info.---
+	ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
+	ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	ts->input_dev->propbit[0] = BIT(INPUT_PROP_DIRECT);
+
+#if MT_PROTOCOL_B
+	input_mt_init_slots(ts->input_dev, ts->max_touch_num, 0);
+#endif
+
+	input_set_abs_params(ts->input_dev, ABS_MT_PRESSURE, 0, TOUCH_FORCE_NUM, 0, 0);    //pressure = TOUCH_FORCE_NUM
+
+#if TOUCH_MAX_FINGER_NUM > 1
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);    //area = 255
+
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, ts->abs_x_max - 1, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, ts->abs_y_max - 1, 0, 0);
+#if MT_PROTOCOL_B
+	// no need to set ABS_MT_TRACKING_ID, input_mt_init_slots() already set it
+#else
+	input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID, 0, ts->max_touch_num, 0, 0);
+#endif //MT_PROTOCOL_B
+#endif //TOUCH_MAX_FINGER_NUM > 1
+
+#if TOUCH_KEY_NUM > 0
+	for (retry = 0; retry < ts->max_button_num; retry++) {
+		input_set_capability(ts->input_dev, EV_KEY, touch_key_array[retry]);
+	}
+#endif
+
+#if WAKEUP_GESTURE
+	ts->input_dev->event = nvt_gesture_switch;
+	for (retry = 0; retry < (sizeof(gesture_key_array) / sizeof(gesture_key_array[0])); retry++) {
+		input_set_capability(ts->input_dev, EV_KEY, gesture_key_array[retry]);
+	}
+#endif
+
+	snprintf(ts->phys, PAGE_SIZE, "input/ts");
+	ts->input_dev->name = NVT_TS_NAME;
+	ts->input_dev->phys = ts->phys;
+	ts->input_dev->id.bustype = BUS_SPI;
+
+	//---register input device---
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		NVT_ERR("register input device (%s) failed. ret=%d\n", ts->input_dev->name, ret);
+		goto err_input_register_device_failed;
+	}
+
+	//---set int-pin & request irq---
+	client->irq = gpio_to_irq(ts->irq_gpio);
+	if (client->irq) {
+		NVT_LOG("int_trigger_type=%d\n", ts->int_trigger_type);
+		ts->irq_enabled = true;
+		ret = request_threaded_irq(client->irq, NULL, nvt_ts_work_func,
+				ts->int_trigger_type | IRQF_ONESHOT, NVT_SPI_NAME, ts);
+		if (ret != 0) {
+			NVT_ERR("request irq failed. ret=%d\n", ret);
+			goto err_int_request_failed;
+		} else {
+			nvt_irq_enable(false);
+			NVT_LOG("request irq %d succeed\n", client->irq);
+		}
+	}
+
+#if WAKEUP_GESTURE
+	device_init_wakeup(&ts->input_dev->dev, 1);
+#endif
+
+#if BOOT_UPDATE_FIRMWARE
+	nvt_fwu_wq = alloc_workqueue("nvt_fwu_wq", WQ_UNBOUND | WQ_MEM_RECLAIM, 1);
+	if (!nvt_fwu_wq) {
+		NVT_ERR("nvt_fwu_wq create workqueue failed\n");
+		ret = -ENOMEM;
+		goto err_create_nvt_fwu_wq_failed;
+	}
+	INIT_DELAYED_WORK(&ts->nvt_fwu_work, Boot_Update_Firmware);
+	// please make sure boot update start after display reset(RESX) sequence
+	queue_delayed_work(nvt_fwu_wq, &ts->nvt_fwu_work, msecs_to_jiffies(5000));
+#endif
+
+	NVT_LOG("NVT_TOUCH_ESD_PROTECT is %d\n", NVT_TOUCH_ESD_PROTECT);
+#if NVT_TOUCH_ESD_PROTECT
+	INIT_DELAYED_WORK(&nvt_esd_check_work, nvt_esd_check_func);
+	nvt_esd_check_wq = alloc_workqueue("nvt_esd_check_wq", WQ_MEM_RECLAIM, 1);
+	if (!nvt_esd_check_wq) {
+		NVT_ERR("nvt_esd_check_wq create workqueue failed\n");
+		ret = -ENOMEM;
+		goto err_create_nvt_esd_check_wq_failed;
+	}
+	queue_delayed_work(nvt_esd_check_wq, &nvt_esd_check_work,
+			msecs_to_jiffies(NVT_TOUCH_ESD_CHECK_PERIOD));
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	//---set device node---
+#if NVT_TOUCH_PROC
+	ret = nvt_flash_proc_init();
+	if (ret != 0) {
+		NVT_ERR("nvt flash proc init failed. ret=%d\n", ret);
+		goto err_flash_proc_init_failed;
+	}
+#endif
+
+#if NVT_TOUCH_EXT_PROC
+	ret = nvt_extra_proc_init();
+	if (ret != 0) {
+		NVT_ERR("nvt extra proc init failed. ret=%d\n", ret);
+		goto err_extra_proc_init_failed;
+	}
+#endif
+
+#if defined(CONFIG_FB)
+	ts->workqueue = create_singlethread_workqueue("nvt_ts_workqueue");
+	if (!ts->workqueue) {
+		NVT_ERR("create nvt_ts_workqueue fail");
+		ret = -ENOMEM;
+		goto err_create_nvt_ts_workqueue_failed;
+	}
+	INIT_WORK(&ts->resume_work, nvt_ts_resume_work);
+#ifdef _MSM_DRM_NOTIFY_H_
+	ts->drm_notif.notifier_call = nvt_drm_notifier_callback;
+	//ret = drm_register_client(&ts->drm_notif);
+	ret = msm_drm_register_client(&ts->drm_notif);
+	if (ret) {
+		NVT_ERR("register drm_notifier failed. ret=%d\n", ret);
+		goto err_register_drm_notif_failed;
+	}
+#else
+	ts->fb_notif.notifier_call = nvt_fb_notifier_callback;
+	ret = fb_register_client(&ts->fb_notif);
+	if (ret) {
+		NVT_ERR("register fb_notifier failed. ret=%d\n", ret);
+		goto err_register_fb_notif_failed;
+	}
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ts->early_suspend.suspend = nvt_ts_early_suspend;
+	ts->early_suspend.resume = nvt_ts_late_resume;
+	ret = register_early_suspend(&ts->early_suspend);
+	if (ret) {
+		NVT_ERR("register early suspend failed. ret=%d\n", ret);
+		goto err_register_early_suspend_failed;
+	}
+#endif
+
+	/* 2019.12.16 longcheer taocheng add (xiaomi game mode) start */
+	/*function description*/
+	if (ts->nvt_tp_class == NULL) {
+		if (ts->nvt_tp_class) {
+			ts->nvt_touch_dev = device_create(ts->nvt_tp_class, NULL, 0x38, ts, "tp_dev");
+			if (IS_ERR(ts->nvt_touch_dev)) {
+				NVT_ERR("Failed to create device !\n");
+				goto err_class_create;
+			}
+			dev_set_drvdata(ts->nvt_touch_dev, ts);
+		}
+	}
+	/* 2019.12.16 longcheer taocheng add (xiaomi game mode) end */
+
+	bTouchIsAwake = 1;
+	NVT_LOG("end\n");
+
+	nvt_irq_enable(true);
+
+#ifdef CONFIG_PM
+	ts->dev_pm_suspend = false;
+	init_completion(&ts->dev_pm_suspend_completion);
+#endif
+
+	pm_runtime_enable(&ts->client->dev);
+
+#if 0
+	//spi bus pm_runtime_get
+	spi_geni_master_dev = lct_get_spi_geni_master_dev(ts->client->master);
+	if (spi_geni_master_dev) {
+		if (pm_runtime_get(spi_geni_master_dev))
+			NVT_ERR("pm_runtime_get fail!\n");
+	}
+#endif
+
+	return 0;
+
+//2019.12.16 longcheer taocheng add (xiaomi game mode)
+err_class_create:
+	class_destroy(ts->nvt_tp_class);
+	ts->nvt_tp_class = NULL;
+
+#if defined(CONFIG_FB)
+err_create_nvt_ts_workqueue_failed:
+	if (ts->workqueue)
+		destroy_workqueue(ts->workqueue);
+#ifdef _MSM_DRM_NOTIFY_H_
+	//if (drm_unregister_client(&ts->drm_notif))
+	//	NVT_ERR("Error occurred while unregistering drm_notifier.\n");
+	if (msm_drm_unregister_client(&ts->drm_notif))
+		NVT_ERR("Error occurred while unregistering drm_notifier.\n");
+err_register_drm_notif_failed:
+#else
+	if (fb_unregister_client(&ts->fb_notif))
+		NVT_ERR("Error occurred while unregistering fb_notifier.\n");
+err_register_fb_notif_failed:
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	unregister_early_suspend(&ts->early_suspend);
+err_register_early_suspend_failed:
+#endif
+#if NVT_TOUCH_EXT_PROC
+nvt_extra_proc_deinit();
+err_extra_proc_init_failed:
+#endif
+#if NVT_TOUCH_PROC
+nvt_flash_proc_deinit();
+err_flash_proc_init_failed:
+#endif
+#if NVT_TOUCH_ESD_PROTECT
+	if (nvt_esd_check_wq) {
+		cancel_delayed_work_sync(&nvt_esd_check_work);
+		destroy_workqueue(nvt_esd_check_wq);
+		nvt_esd_check_wq = NULL;
+	}
+err_create_nvt_esd_check_wq_failed:
+#endif
+#if BOOT_UPDATE_FIRMWARE
+	if (nvt_fwu_wq) {
+		cancel_delayed_work_sync(&ts->nvt_fwu_work);
+		destroy_workqueue(nvt_fwu_wq);
+		nvt_fwu_wq = NULL;
+	}
+err_create_nvt_fwu_wq_failed:
+#endif
+#if WAKEUP_GESTURE
+	device_init_wakeup(&ts->input_dev->dev, 0);
+#endif
+	free_irq(client->irq, ts);
+err_int_request_failed:
+	input_unregister_device(ts->input_dev);
+	ts->input_dev = NULL;
+err_input_register_device_failed:
+	if (ts->input_dev) {
+		input_free_device(ts->input_dev);
+		ts->input_dev = NULL;
+	}
+err_input_dev_alloc_failed:
+err_chipvertrim_failed:
+	mutex_destroy(&ts->xbuf_lock);
+	mutex_destroy(&ts->lock);
+	nvt_gpio_deconfig(ts);
+err_gpio_config_failed:
+#if WAKEUP_GESTURE
+	nvt_ts_enable_regulator(false);
+err_enable_regulator:
+	nvt_ts_get_regulator(false);
+err_get_regulator:
+#endif
+err_spi_setup:
+err_ckeck_full_duplex:
+	spi_set_drvdata(client, NULL);
+#ifdef CHECK_TOUCH_VENDOR
+err_vendor_check:
+#endif
+	//if (ts->xbuf) {
+		kfree(ts->xbuf);
+		ts->xbuf = NULL;
+	//}
+	//if (ts) {
+		kfree(ts);
+		ts = NULL;
+	//}
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen driver release function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static void nvt_ts_remove(struct spi_device *client)
+{
+	NVT_LOG("Removing driver...\n");
+
+#if defined(CONFIG_FB)
+	if (ts->workqueue)
+		destroy_workqueue(ts->workqueue);
+#ifdef _MSM_DRM_NOTIFY_H_
+	//if (drm_unregister_client(&ts->drm_notif))
+	//	NVT_ERR("Error occurred while unregistering drm_notifier.\n");
+	if (msm_drm_unregister_client(&ts->drm_notif))
+		NVT_ERR("Error occurred while unregistering drm_notifier.\n");
+#else
+	if (fb_unregister_client(&ts->fb_notif))
+		NVT_ERR("Error occurred while unregistering fb_notifier.\n");
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	unregister_early_suspend(&ts->early_suspend);
+#endif
+
+#if NVT_TOUCH_EXT_PROC
+	nvt_extra_proc_deinit();
+#endif
+#if NVT_TOUCH_PROC
+	nvt_flash_proc_deinit();
+#endif
+
+#if NVT_TOUCH_ESD_PROTECT
+	if (nvt_esd_check_wq) {
+		cancel_delayed_work_sync(&nvt_esd_check_work);
+		nvt_esd_check_enable(false);
+		destroy_workqueue(nvt_esd_check_wq);
+		nvt_esd_check_wq = NULL;
+	}
+#endif
+
+#if BOOT_UPDATE_FIRMWARE
+	if (nvt_fwu_wq) {
+		cancel_delayed_work_sync(&ts->nvt_fwu_work);
+		destroy_workqueue(nvt_fwu_wq);
+		nvt_fwu_wq = NULL;
+	}
+#endif
+
+#if WAKEUP_GESTURE
+	device_init_wakeup(&ts->input_dev->dev, 0);
+#endif
+
+	nvt_irq_enable(false);
+	free_irq(client->irq, ts);
+
+	mutex_destroy(&ts->xbuf_lock);
+	mutex_destroy(&ts->lock);
+
+#if WAKEUP_GESTURE
+	nvt_ts_enable_regulator(false);
+	nvt_ts_get_regulator(false);
+#endif
+
+	nvt_gpio_deconfig(ts);
+
+	if (ts->input_dev) {
+		input_unregister_device(ts->input_dev);
+		ts->input_dev = NULL;
+	}
+
+	spi_set_drvdata(client, NULL);
+
+	//if (ts->xbuf) {
+		kfree(ts->xbuf);
+		ts->xbuf = NULL;
+	//}
+
+	//if (ts) {
+		kfree(ts);
+		ts = NULL;
+	//}
+
+	//return 0;
+}
+
+static void nvt_ts_shutdown(struct spi_device *client)
+{
+	NVT_LOG("Shutdown driver...\n");
+
+	nvt_irq_enable(false);
+
+#if defined(CONFIG_FB)
+	if (ts->workqueue)
+		destroy_workqueue(ts->workqueue);
+#ifdef _MSM_DRM_NOTIFY_H_
+	//if (drm_unregister_client(&ts->drm_notif))
+	//	NVT_ERR("Error occurred while unregistering drm_notifier.\n");
+	if (msm_drm_unregister_client(&ts->drm_notif))
+		NVT_ERR("Error occurred while unregistering drm_notifier.\n");
+#else
+	if (fb_unregister_client(&ts->fb_notif))
+		NVT_ERR("Error occurred while unregistering fb_notifier.\n");
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	unregister_early_suspend(&ts->early_suspend);
+#endif
+
+#if NVT_TOUCH_EXT_PROC
+	nvt_extra_proc_deinit();
+#endif
+#if NVT_TOUCH_PROC
+	nvt_flash_proc_deinit();
+#endif
+
+#if NVT_TOUCH_ESD_PROTECT
+	if (nvt_esd_check_wq) {
+		cancel_delayed_work_sync(&nvt_esd_check_work);
+		nvt_esd_check_enable(false);
+		destroy_workqueue(nvt_esd_check_wq);
+		nvt_esd_check_wq = NULL;
+	}
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+#if BOOT_UPDATE_FIRMWARE
+	if (nvt_fwu_wq) {
+		cancel_delayed_work_sync(&ts->nvt_fwu_work);
+		destroy_workqueue(nvt_fwu_wq);
+		nvt_fwu_wq = NULL;
+	}
+#endif
+
+#if WAKEUP_GESTURE
+	device_init_wakeup(&ts->input_dev->dev, 0);
+#endif
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen driver suspend function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t nvt_ts_suspend(struct device *dev)
+{
+	uint8_t buf[4] = {0};
+#if MT_PROTOCOL_B
+	uint32_t i = 0;
+#endif
+
+	if (!bTouchIsAwake) {
+		NVT_LOG("Touch is already suspend\n");
+		return 0;
+	}
+
+#if WAKEUP_GESTURE
+	if (!ts->is_gesture_mode) {
+		nvt_irq_enable(false);
+#if 0
+		//spi bus pm_runtime_get
+		if (spi_geni_master_dev) {
+			if (pm_runtime_put(spi_geni_master_dev))
+				NVT_ERR("pm_runtime_put fail!\n");
+		}
+#endif
+	}
+#else
+	nvt_irq_enable(false);
+#endif
+
+#if NVT_TOUCH_ESD_PROTECT
+	NVT_LOG("cancel delayed work sync\n");
+	cancel_delayed_work_sync(&nvt_esd_check_work);
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	mutex_lock(&ts->lock);
+
+	NVT_LOG("start\n");
+
+	bTouchIsAwake = 0;
+
+#if WAKEUP_GESTURE
+	if (ts->is_gesture_mode) {
+		//---write command to enter "wakeup gesture mode"---
+		buf[0] = EVENT_MAP_HOST_CMD;
+		buf[1] = 0x13;
+		CTP_SPI_WRITE(ts->client, buf, 2);
+		enable_irq_wake(ts->client->irq);
+		NVT_LOG("Enabled touch wakeup gesture\n");
+	} else {
+		//---write command to enter "deep sleep mode"---
+		//buf[0] = EVENT_MAP_HOST_CMD;
+		//buf[1] = 0x11;
+		//CTP_SPI_WRITE(ts->client, buf, 2);
+		NVT_LOG("power off, enter sleep mode\n");
+	}
+#else // WAKEUP_GESTURE
+	//---write command to enter "deep sleep mode"---
+	buf[0] = EVENT_MAP_HOST_CMD;
+	buf[1] = 0x11;
+	CTP_SPI_WRITE(ts->client, buf, 2);
+#endif // WAKEUP_GESTURE
+
+	mutex_unlock(&ts->lock);
+
+	/* release all touches */
+#if MT_PROTOCOL_B
+	for (i = 0; i < ts->max_touch_num; i++) {
+		input_mt_slot(ts->input_dev, i);
+		input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+		input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 0);
+		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
+	}
+#endif
+	input_report_key(ts->input_dev, BTN_TOUCH, 0);
+#if !MT_PROTOCOL_B
+	input_mt_sync(ts->input_dev);
+#endif
+	input_sync(ts->input_dev);
+
+	msleep(50);
+
+	NVT_LOG("end\n");
+
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen driver resume function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t nvt_ts_resume(struct device *dev)
+{
+	if (bTouchIsAwake) {
+		NVT_LOG("Touch is already resume\n");
+#if NVT_TOUCH_WDT_RECOVERY
+		mutex_lock(&ts->lock);
+		nvt_update_firmware(ts->boot_update_firmware_name);
+		mutex_unlock(&ts->lock);
+#endif /* #if NVT_TOUCH_WDT_RECOVERY */
+		return 0;
+	}
+
+	mutex_lock(&ts->lock);
+
+	NVT_LOG("start\n");
+
+	// please make sure display reset(RESX) sequence and mipi dsi cmds sent before this
+#if NVT_TOUCH_SUPPORT_HW_RST
+	gpio_set_value(ts->reset_gpio, 1);
+#endif
+	if (nvt_update_firmware(ts->boot_update_firmware_name)) {
+		NVT_ERR("download firmware failed, ignore check fw state\n");
+	} else {
+		nvt_check_fw_reset_state(RESET_STATE_REK);
+	}
+
+#if WAKEUP_GESTURE
+	if (!ts->is_gesture_mode) {
+		nvt_irq_enable(true);
+#if 0
+		//spi bus pm_runtime_get
+		if (spi_geni_master_dev) {
+			if (pm_runtime_get(spi_geni_master_dev))
+				NVT_ERR("pm_runtime_get fail!\n");
+		}
+#endif
+	}
+#else
+	nvt_irq_enable(true);
+#endif
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+	queue_delayed_work(nvt_esd_check_wq, &nvt_esd_check_work,
+			msecs_to_jiffies(NVT_TOUCH_ESD_CHECK_PERIOD));
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	bTouchIsAwake = 1;
+	NVT_LOG("bTouchIsAwake = 1\n");
+	mutex_unlock(&ts->lock);
+
+#if WAKEUP_GESTURE
+	if (ts->delay_gesture) {
+		lct_nvt_tp_gesture_callback(!ts->is_gesture_mode);
+		ts->delay_gesture = false;
+	}
+#endif
+
+	NVT_LOG("end\n");
+
+	return 0;
+}
+
+#if WAKEUP_GESTURE
+int lct_nvt_tp_gesture_callback(bool flag)
+{
+	if (!bTouchIsAwake) {
+		ts->delay_gesture = true;
+		NVT_LOG("The gesture mode will be %s the next time you wakes up.\n", flag?"enabled":"disbaled");
+		return 0;
+	}
+	if (flag) {
+		ts->is_gesture_mode = true;
+		if (nvt_ts_enable_regulator(true) < 0) {
+			NVT_ERR("Failed to enable regulator\n");
+			//set_lcd_reset_gpio_keep_high(true);
+		}
+		NVT_LOG("enable gesture mode\n");
+	} else {
+		ts->is_gesture_mode = false;
+		if (nvt_ts_enable_regulator(false) < 0) {
+			NVT_ERR("Failed to disable regulator\n");
+			//set_lcd_reset_gpio_keep_high(false);
+		}
+		NVT_LOG("disable gesture mode\n");
+	}
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_FB)
+static void nvt_ts_resume_work(struct work_struct *work)
+{
+	nvt_ts_resume(&ts->client->dev);
+}
+#ifdef _MSM_DRM_NOTIFY_H_
+static int nvt_drm_notifier_callback(struct notifier_block *self, unsigned long event, void *data)
+{
+	struct msm_drm_notifier *evdata = data;
+	int blank;
+	struct nvt_ts_data *ts =
+		container_of(self, struct nvt_ts_data, drm_notif);
+
+	if (!evdata || (evdata->id != 0))
+		return 0;
+
+	if (evdata->data && ts) {
+		blank = evdata->data;
+		if (event == DRM_EARLY_EVENT_BLANK) {
+			if (blank == DRM_BLANK_POWERDOWN) {
+				NVT_LOG("event=%lu, blank=%d\n", event, blank);
+				cancel_work_sync(&ts->resume_work);
+				nvt_ts_suspend(&ts->client->dev);
+			}
+		} else if (event == DRM_EVENT_BLANK) {
+			if (blank == DRM_BLANK_UNBLANK) {
+				NVT_LOG("event=%lu, blank=%d\n", event, blank);
+				//nvt_ts_resume(&ts->client->dev);
+				queue_work(ts->workqueue, &ts->resume_work);
+			}
+		}
+	}
+
+	return 0;
+}
+#else
+static int nvt_fb_notifier_callback(struct notifier_block *self, unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+	struct nvt_ts_data *ts =
+		container_of(self, struct nvt_ts_data, fb_notif);
+
+	if (evdata && evdata->data && event == FB_EARLY_EVENT_BLANK) {
+		blank = evdata->data;
+		if (*blank == FB_BLANK_POWERDOWN) {
+			NVT_LOG("event=%lu, *blank=%d\n", event, *blank);
+			nvt_ts_suspend(&ts->client->dev);
+		}
+	} else if (evdata && evdata->data && event == FB_EVENT_BLANK) {
+		blank = evdata->data;
+		if (*blank == FB_BLANK_UNBLANK) {
+			NVT_LOG("event=%lu, *blank=%d\n", event, *blank);
+			nvt_ts_resume(&ts->client->dev);
+		}
+	}
+
+	return 0;
+}
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+/*******************************************************
+Description:
+	Novatek touchscreen driver early suspend function.
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_ts_early_suspend(struct early_suspend *h)
+{
+	nvt_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen driver late resume function.
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_ts_late_resume(struct early_suspend *h)
+{
+	nvt_ts_resume(ts->client);
+}
+#endif
+
+#ifdef CONFIG_PM
+static int nvt_pm_suspend(struct device *dev)
+{
+	struct nvt_ts_data *ts = dev_get_drvdata(dev);
+
+	ts->dev_pm_suspend = true;
+	reinit_completion(&ts->dev_pm_suspend_completion);
+	NVT_LOG("pm suspend");
+
+	return 0;
+}
+
+static int nvt_pm_resume(struct device *dev)
+{
+	struct nvt_ts_data *ts = dev_get_drvdata(dev);
+
+	ts->dev_pm_suspend = false;
+	complete(&ts->dev_pm_suspend_completion);
+	NVT_LOG("pm resume");
+
+	return 0;
+}
+
+static const struct dev_pm_ops nvt_dev_pm_ops = {
+	.suspend = nvt_pm_suspend,
+	.resume = nvt_pm_resume,
+};
+#endif
+
+static const struct spi_device_id nvt_ts_id[] = {
+	{ NVT_SPI_NAME, 0x62 },
+	{ }
+};
+
+#ifdef CONFIG_OF
+static struct of_device_id nvt_match_table[] = {
+	{ .compatible = "novatek,NVT-ts-spi",},
+	{ },
+};
+#endif
+
+static struct spi_driver nvt_spi_driver = {
+	.probe		= nvt_ts_probe,
+	.remove		= nvt_ts_remove,
+	.shutdown	= nvt_ts_shutdown,
+	.id_table	= nvt_ts_id,
+	.driver = {
+		.name	= NVT_SPI_NAME,
+		.owner	= THIS_MODULE,
+#ifdef CONFIG_PM
+		.pm = &nvt_dev_pm_ops,
+#endif
+#ifdef CONFIG_OF
+		.of_match_table = nvt_match_table,
+#endif
+	},
+};
+
+/*******************************************************
+Description:
+	Driver Install function.
+
+return:
+	Executive Outcomes. 0---succeed. not 0---failed.
+********************************************************/
+static int32_t __init nvt_driver_init(void)
+{
+	int32_t ret = 0;
+
+	NVT_LOG("start\n");
+#ifdef CHECK_TOUCH_VENDOR
+	//Check TP vendor
+	if (IS_ERR_OR_NULL(saved_command_line)) {
+		NVT_ERR("saved_command_line ERROR!\n");
+		ret = -ENOMEM;
+		goto err_driver;
+	} else {
+		if (strnstr(saved_command_line, "huaxing", strlen(saved_command_line)) != NULL) {
+			touch_vendor_id = TP_VENDOR_HUAXING;
+			NVT_LOG("TP info: [Vendor]huaxing [IC]nt36672c\n");
+		} else if (strnstr(saved_command_line, "tianma", strlen(saved_command_line)) != NULL) {
+			touch_vendor_id = TP_VENDOR_TIANMA;
+			NVT_LOG("TP info: [Vendor]tianma [IC]nt36672c\n");
+		} else {
+			touch_vendor_id = TP_VENDOR_UNKNOWN;
+			NVT_ERR("Unknown Touch\n");
+			ret = -ENODEV;
+			goto err_driver;
+		}
+	}
+
+	//Check android mode
+
+	//if (strstr(saved_command_line, "androidboot.mode=charger") != NULL) {
+	//	NVT_LOG("androidboot.mode=charger, doesn't support touch in the charging mode!\n");
+	//	ret = -ENODEV;
+	//	goto err_driver;
+	//}
+#endif
+
+	//---add spi driver---
+	ret = spi_register_driver(&nvt_spi_driver);
+	if (ret) {
+		NVT_ERR("failed to add spi driver %d", ret);
+		goto err_driver;
+	}
+
+	NVT_LOG("finished\n");
+
+err_driver:
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Driver uninstall function.
+
+return:
+	n.a.
+********************************************************/
+static void __exit nvt_driver_exit(void)
+{
+	NVT_LOG("exit tp driver ...\n");
+	spi_unregister_driver(&nvt_spi_driver);
+}
+
+//late_initcall(nvt_driver_init);
+module_init(nvt_driver_init);
+module_exit(nvt_driver_exit);
+
+MODULE_DESCRIPTION("Novatek Touchscreen Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/nt36672c/nt36xxx.h b/drivers/input/touchscreen/nt36672c/nt36xxx.h
new file mode 100644
index 000000000000..873ea0b3fbc6
--- /dev/null
+++ b/drivers/input/touchscreen/nt36672c/nt36xxx.h
@@ -0,0 +1,256 @@
+/*
+ * Copyright (C) 2010 - 2018 Novatek, Inc.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ * $Revision: 43560 $
+ * $Date: 2019-04-19 11:34:19 +0800 (週五, 19 四月 2019) $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#ifndef	_LINUX_NVT_TOUCH_H
+#define	_LINUX_NVT_TOUCH_H
+
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/of.h>
+#include <linux/spi/spi.h>
+#include <linux/uaccess.h>
+#include <linux/regulator/consumer.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#include "nt36xxx_mem_map.h"
+
+#undef CONFIG_FB
+#undef CONFIG_MSM_DRM
+
+#define NVT_DEBUG 1
+
+//---GPIO number---
+#define NVTTOUCH_RST_PIN 87
+#define NVTTOUCH_INT_PIN 88
+
+
+//---INT trigger mode---
+//#define IRQ_TYPE_EDGE_RISING 1
+//#define IRQ_TYPE_EDGE_FALLING 2
+#define INT_TRIGGER_TYPE IRQ_TYPE_EDGE_RISING
+
+
+//---SPI driver info.---
+#define NVT_SPI_NAME "NVT-ts"
+
+#if NVT_DEBUG
+#define NVT_LOG(fmt, args...)    pr_err("[%s] %s %d: " fmt, NVT_SPI_NAME, __func__, __LINE__, ##args)
+#else
+#define NVT_LOG(fmt, args...)    pr_info("[%s] %s %d: " fmt, NVT_SPI_NAME, __func__, __LINE__, ##args)
+#endif
+#define NVT_ERR(fmt, args...)    pr_err("[%s] %s %d: " fmt, NVT_SPI_NAME, __func__, __LINE__, ##args)
+
+//---Input device info.---
+#define NVT_TS_NAME "NVTCapacitiveTouchScreen"
+
+
+//---Touch info.---
+#define TOUCH_DEFAULT_MAX_WIDTH 1080
+#define TOUCH_DEFAULT_MAX_HEIGHT 2400
+#define TOUCH_MAX_FINGER_NUM 10
+#define TOUCH_KEY_NUM 0
+#if TOUCH_KEY_NUM > 0
+extern const uint16_t touch_key_array[TOUCH_KEY_NUM];
+#endif
+#define TOUCH_FORCE_NUM 1000
+
+/* Enable only when module have tp reset pin and connected to host */
+#define NVT_TOUCH_SUPPORT_HW_RST 1
+
+//---Customerized func.---
+#define NVT_TOUCH_PROC 1
+#define NVT_TOUCH_EXT_PROC 1
+#define MT_PROTOCOL_B 1
+#define WAKEUP_GESTURE 1
+#if WAKEUP_GESTURE
+extern const uint16_t gesture_key_array[];
+#endif
+#define BOOT_UPDATE_FIRMWARE 1
+#define FIRMWARE_NAME_LEN    256
+#define BOOT_UPDATE_FIRMWARE_NAME         "novatek_ts_fw.bin"
+#define BOOT_UPDATE_TIANMA_FIRMWARE_NAME  "novatek_ts_tianma_fw.bin"
+#define BOOT_UPDATE_HUAXING_FIRMWARE_NAME    "novatek_ts_huaxing_fw.bin"
+#define MP_UPDATE_FIRMWARE_NAME           "novatek_ts_mp.bin"
+#define MP_UPDATE_TIANMA_FIRMWARE_NAME    "novatek_ts_tianma_mp.bin"
+#define MP_UPDATE_HUAXING_FIRMWARE_NAME      "novatek_ts_huaxing_mp.bin"
+
+//---ESD Protect.---
+#define NVT_TOUCH_ESD_PROTECT 0
+#define NVT_TOUCH_ESD_CHECK_PERIOD 1500	/* ms */
+#define NVT_TOUCH_WDT_RECOVERY 0
+#define NVT_TOUCH_ESD_DISP_RECOVERY 0
+
+//enable 'check touch vendor' feature
+//#define CHECK_TOUCH_VENDOR
+
+//---Touch Vendor ID---
+#define TP_VENDOR_UNKNOWN   0x00
+#define TP_VENDOR_HUAXING   0x01
+#define TP_VENDOR_TIANMA    0x02
+
+/* 2019.12.16 longcheer taocheng add (xiaomi game mode) start */
+#define NVT_REG_MONITOR_MODE                0x7000
+#define NVT_REG_THDIFF                      0x7100
+#define NVT_REG_SENSIVITY                   0x7200
+#define NVT_REG_EDGE_FILTER_LEVEL           0xBA00
+#define NVT_REG_EDGE_FILTER_ORIENTATION     0xBC00
+/* 2019.12.16 longcheer taocheng add (xiaomi game mode) end */
+
+//new qcom platform use
+//#define _MSM_DRM_NOTIFY_H_
+
+struct nvt_ts_data {
+	struct spi_device *client;
+	struct input_dev *input_dev;
+	struct delayed_work nvt_fwu_work;
+	uint16_t addr;
+	int8_t phys[32];
+#if defined(CONFIG_FB)
+	struct workqueue_struct *workqueue;
+	struct work_struct resume_work;
+#ifdef _MSM_DRM_NOTIFY_H_
+	struct notifier_block drm_notif;
+#else
+	struct notifier_block fb_notif;
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	struct early_suspend early_suspend;
+#endif
+#ifdef CHECK_TOUCH_VENDOR
+	uint8_t touch_vendor_id;
+#endif
+	uint8_t boot_update_firmware_name[FIRMWARE_NAME_LEN];
+	uint8_t mp_update_firmware_name[FIRMWARE_NAME_LEN];
+	uint8_t fw_ver;
+	uint8_t x_num;
+	uint8_t y_num;
+	uint16_t abs_x_max;
+	uint16_t abs_y_max;
+	uint8_t max_touch_num;
+	uint8_t max_button_num;
+	uint32_t int_trigger_type;
+	int32_t irq_gpio;
+	uint32_t irq_flags;
+	int32_t reset_gpio;
+	uint32_t reset_flags;
+	struct mutex lock;
+	const struct nvt_ts_mem_map *mmap;
+	uint8_t carrier_system;
+	uint8_t hw_crc;
+	uint16_t nvt_pid;
+	uint8_t rbuf[1025];
+	uint8_t *xbuf;
+	struct mutex xbuf_lock;
+	bool irq_enabled;
+#if WAKEUP_GESTURE
+	bool delay_gesture;
+	bool is_gesture_mode;
+#ifdef CONFIG_PM
+	bool dev_pm_suspend;
+	struct completion dev_pm_suspend_completion;
+#endif
+	struct regulator *pwr_vdd; /* IOVCC 1.8V */
+	struct regulator *pwr_lab; /* VSP +5V */
+	struct regulator *pwr_ibb; /* VSN -5V */
+#endif
+
+	struct mutex reg_lock;
+	struct device *nvt_touch_dev;
+	struct class *nvt_tp_class;
+/*2019.12.16 longcheer taocheng add (xiaomi game mode) end*/
+};
+
+#if NVT_TOUCH_PROC
+struct nvt_flash_data{
+	rwlock_t lock;
+};
+#endif
+
+typedef enum {
+	RESET_STATE_INIT = 0xA0,// IC reset
+	RESET_STATE_REK,		// ReK baseline
+	RESET_STATE_REK_FINISH,	// baseline is ready
+	RESET_STATE_NORMAL_RUN,	// normal run
+	RESET_STATE_MAX  = 0xAF
+} RST_COMPLETE_STATE;
+
+typedef enum {
+    EVENT_MAP_HOST_CMD                      = 0x50,
+    EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE   = 0x51,
+    EVENT_MAP_RESET_COMPLETE                = 0x60,
+    EVENT_MAP_FWINFO                        = 0x78,
+    EVENT_MAP_PROJECTID                     = 0x9A,
+} SPI_EVENT_MAP;
+
+//---SPI READ/WRITE---
+#define SPI_WRITE_MASK(a)	(a | 0x80)
+#define SPI_READ_MASK(a)	(a & 0x7F)
+
+#define DUMMY_BYTES (1)
+#define NVT_TRANSFER_LEN	(63*1024)
+
+typedef enum {
+	NVTWRITE = 0,
+	NVTREAD  = 1
+} NVT_SPI_RW;
+
+#if NVT_TOUCH_ESD_DISP_RECOVERY
+#define ILM_CRC_FLAG        0x01
+#define CRC_DONE            0x04
+#define F2C_RW_READ         0x00
+#define F2C_RW_WRITE        0x01
+#define BIT_F2C_EN          0
+#define BIT_F2C_RW          1
+#define BIT_CPU_IF_ADDR_INC 2
+#define BIT_CPU_POLLING_EN  5
+#define FFM2CPU_CTL         0x3F280
+#define F2C_LENGTH          0x3F283
+#define CPU_IF_ADDR         0x3F284
+#define FFM_ADDR            0x3F286
+#define CP_TP_CPU_REQ       0x3F291
+#define TOUCH_DATA_ADDR     0x20000
+#define DISP_OFF_ADDR       0x2800
+#endif /* NVT_TOUCH_ESD_DISP_RECOVERY */
+
+//---extern structures---
+extern struct nvt_ts_data *ts;
+
+//---extern functions---
+int32_t CTP_SPI_READ(struct spi_device *client, uint8_t *buf, uint16_t len);
+int32_t CTP_SPI_WRITE(struct spi_device *client, uint8_t *buf, uint16_t len);
+void nvt_bootloader_reset(void);
+void nvt_eng_reset(void);
+void nvt_sw_reset(void);
+void nvt_sw_reset_idle(void);
+void nvt_boot_ready(void);
+void nvt_bld_crc_enable(void);
+void nvt_fw_crc_enable(void);
+int32_t nvt_update_firmware(char *firmware_name);
+int32_t nvt_check_fw_reset_state(RST_COMPLETE_STATE check_reset_state);
+int32_t nvt_get_fw_info(void);
+int32_t nvt_clear_fw_status(void);
+int32_t nvt_check_fw_status(void);
+int32_t nvt_set_page(uint32_t addr);
+int32_t nvt_write_addr(uint32_t addr, uint8_t data);
+#if NVT_TOUCH_ESD_PROTECT
+extern void nvt_esd_check_enable(uint8_t enable);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+#endif /* _LINUX_NVT_TOUCH_H */
diff --git a/drivers/input/touchscreen/nt36672c/nt36xxx_ext_proc.c b/drivers/input/touchscreen/nt36672c/nt36xxx_ext_proc.c
new file mode 100644
index 000000000000..0ecfb7f10155
--- /dev/null
+++ b/drivers/input/touchscreen/nt36672c/nt36xxx_ext_proc.c
@@ -0,0 +1,2039 @@
+/*
+ * Copyright (C) 2010 - 2018 Novatek, Inc.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ * $Revision: 43423 $
+ * $Date: 2019-04-16 19:58:23 +0800 (週二, 16 四月 2019) $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#include "nt36xxx.h"
+
+#if NVT_TOUCH_EXT_PROC
+#define NVT_FW_VERSION "nvt_fw_version"
+#define NVT_BASELINE "nvt_baseline"
+#define NVT_RAW "nvt_raw"
+#define NVT_DIFF "nvt_diff"
+#define NVT_PF_SWITCH "nvt_pf_switch"
+#define NVT_SENSITIVITY_SWITCH "nvt_sensitivity_switch"
+#define NVT_ER_RANGE_SWITCH "nvt_er_range_switch"
+#define NVT_MAX_POWER_SWITCH "nvt_max_power_switch"
+#define NVT_EDGE_REJECT_SWITCH "nvt_edge_reject_switch"
+#define NVT_POCKET_PALM_SWITCH "nvt_pocket_palm_switch"
+#define NVT_CHARGER_SWITCH "nvt_charger_switch"
+
+#define SPI_TANSFER_LENGTH  256
+
+#define NORMAL_MODE 0x00
+#define TEST_MODE_1 0x21
+#define TEST_MODE_2 0x22
+#define HANDSHAKING_HOST_READY 0xBB
+
+#define XDATA_SECTOR_SIZE   256
+
+static uint8_t xdata_tmp[2048] = {0};
+static int32_t xdata[2048] = {0};
+
+static struct proc_dir_entry *NVT_proc_fw_version_entry;
+static struct proc_dir_entry *NVT_proc_baseline_entry;
+static struct proc_dir_entry *NVT_proc_raw_entry;
+static struct proc_dir_entry *NVT_proc_diff_entry;
+static struct proc_dir_entry *NVT_proc_pf_switch_entry;
+static struct proc_dir_entry *NVT_proc_sensitivity_switch_entry;
+static struct proc_dir_entry *NVT_proc_er_range_switch_entry;
+static struct proc_dir_entry *NVT_proc_max_power_switch_entry;
+static struct proc_dir_entry *NVT_proc_edge_reject_switch_entry;
+static struct proc_dir_entry *NVT_proc_pocket_palm_switch_entry;
+static struct proc_dir_entry *NVT_proc_charger_switch_entry;
+static int32_t diff_data[2048] = {0};
+
+/*******************************************************
+Description:
+	Novatek touchscreen change mode function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_change_mode(uint8_t mode)
+{
+	uint8_t buf[8] = {0};
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+
+	//---set mode---
+	buf[0] = EVENT_MAP_HOST_CMD;
+	buf[1] = mode;
+	CTP_SPI_WRITE(ts->client, buf, 2);
+
+	if (mode == NORMAL_MODE) {
+		buf[0] = EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE;
+		buf[1] = HANDSHAKING_HOST_READY;
+		CTP_SPI_WRITE(ts->client, buf, 2);
+		msleep(20);
+	}
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen get firmware pipe function.
+
+return:
+	Executive outcomes. 0---pipe 0. 1---pipe 1.
+*******************************************************/
+uint8_t nvt_get_fw_pipe(void)
+{
+	uint8_t buf[8] = {0};
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE);
+
+	//---read fw status---
+	buf[0] = EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE;
+	buf[1] = 0x00;
+	CTP_SPI_READ(ts->client, buf, 2);
+
+	//NVT_LOG("FW pipe=%d, buf[1]=0x%02X\n", (buf[1]&0x01), buf[1]);
+
+	return (buf[1] & 0x01);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen read meta data function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_read_mdata(uint32_t xdata_addr, uint32_t xdata_btn_addr)
+{
+	int32_t i = 0;
+	int32_t j = 0;
+	int32_t k = 0;
+	uint8_t buf[SPI_TANSFER_LENGTH + 1] = {0};
+	uint32_t head_addr = 0;
+	int32_t dummy_len = 0;
+	int32_t data_len = 0;
+	int32_t residual_len = 0;
+
+	//---set xdata sector address & length---
+	head_addr = xdata_addr - (xdata_addr % XDATA_SECTOR_SIZE);
+	dummy_len = xdata_addr - head_addr;
+	data_len = ts->x_num * ts->y_num * 2;
+	residual_len = (head_addr + dummy_len + data_len) % XDATA_SECTOR_SIZE;
+
+	//printk("head_addr=0x%05X, dummy_len=0x%05X, data_len=0x%05X,
+	//residual_len=0x%05X\n", head_addr, dummy_len, data_len, residual_len);
+
+	//read xdata : step 1
+	for (i = 0; i < ((dummy_len + data_len) / XDATA_SECTOR_SIZE); i++) {
+		//---read xdata by SPI_TANSFER_LENGTH
+		for (j = 0; j < (XDATA_SECTOR_SIZE / SPI_TANSFER_LENGTH); j++) {
+			//---change xdata index---
+			nvt_set_page(head_addr + (XDATA_SECTOR_SIZE * i) + (SPI_TANSFER_LENGTH * j));
+
+			//---read data---
+			buf[0] = SPI_TANSFER_LENGTH * j;
+			CTP_SPI_READ(ts->client, buf, SPI_TANSFER_LENGTH + 1);
+
+			//---copy buf to xdata_tmp---
+			for (k = 0; k < SPI_TANSFER_LENGTH; k++) {
+				xdata_tmp[XDATA_SECTOR_SIZE * i + SPI_TANSFER_LENGTH * j + k] = buf[k + 1];
+				//printk("0x%02X, 0x%04X\n", buf[k+1], (XDATA_SECTOR_SIZE*i + SPI_TANSFER_LENGTH*j + k));
+			}
+		}
+		//printk("addr=0x%05X\n", (head_addr+XDATA_SECTOR_SIZE*i));
+	}
+
+	//read xdata : step2
+	if (residual_len != 0) {
+		//---read xdata by SPI_TANSFER_LENGTH
+		for (j = 0; j < (residual_len / SPI_TANSFER_LENGTH + 1); j++) {
+			//---change xdata index---
+			nvt_set_page(xdata_addr + data_len - residual_len + (SPI_TANSFER_LENGTH * j));
+
+			//---read data---
+			buf[0] = SPI_TANSFER_LENGTH * j;
+			CTP_SPI_READ(ts->client, buf, SPI_TANSFER_LENGTH + 1);
+
+			//---copy buf to xdata_tmp---
+			for (k = 0; k < SPI_TANSFER_LENGTH; k++) {
+				xdata_tmp[(dummy_len + data_len - residual_len) + SPI_TANSFER_LENGTH * j + k] = buf[k + 1];
+				//printk("0x%02X, 0x%04x\n", buf[k+1],
+				//((dummy_len+data_len-residual_len) + SPI_TANSFER_LENGTH*j + k));
+			}
+		}
+		//printk("addr=0x%05X\n", (xdata_addr+data_len-residual_len));
+	}
+
+	//---remove dummy data and 2bytes-to-1data---
+	for (i = 0; i < (data_len / 2); i++) {
+		xdata[i] = (int16_t)(xdata_tmp[dummy_len + i * 2] + 256 * xdata_tmp[dummy_len + i * 2 + 1]);
+	}
+
+#if TOUCH_KEY_NUM > 0
+	//read button xdata : step3
+	//---change xdata index---
+	nvt_set_page(xdata_btn_addr);
+	//---read data---
+	buf[0] = (xdata_btn_addr & 0xFF);
+	CTP_SPI_READ(ts->client, buf, (TOUCH_KEY_NUM * 2 + 1));
+
+	//---2bytes-to-1data---
+	for (i = 0; i < TOUCH_KEY_NUM; i++) {
+		xdata[ts->x_num * ts->y_num + i] = (int16_t)(buf[1 + i * 2] + 256 * buf[1 + i * 2 + 1]);
+	}
+#endif
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR);
+}
+
+/*******************************************************
+Description:
+    Novatek touchscreen get meta data function.
+
+return:
+    n.a.
+*******************************************************/
+void nvt_get_mdata(int32_t *buf, uint8_t *m_x_num, uint8_t *m_y_num)
+{
+    *m_x_num = ts->x_num;
+    *m_y_num = ts->y_num;
+    memcpy(buf, xdata, ((ts->x_num * ts->y_num + TOUCH_KEY_NUM) * sizeof(int32_t)));
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen firmware version show function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t c_fw_version_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "fw_ver=%d, x_num=%d, y_num=%d, button_num=%d\n", ts->fw_ver, ts->x_num, ts->y_num, ts->max_button_num);
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen xdata sequence print show
+	function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t c_show(struct seq_file *m, void *v)
+{
+	int32_t i = 0;
+	int32_t j = 0;
+
+	for (i = 0; i < ts->y_num; i++) {
+		for (j = 0; j < ts->x_num; j++) {
+			seq_printf(m, "%5d, ", xdata[i * ts->x_num + j]);
+		}
+		seq_puts(m, "\n");
+	}
+
+#if TOUCH_KEY_NUM > 0
+	for (i = 0; i < TOUCH_KEY_NUM; i++) {
+		seq_printf(m, "%5d, ", xdata[ts->x_num * ts->y_num + i]);
+	}
+	seq_puts(m, "\n");
+#endif
+
+	seq_printf(m, "\n\n");
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen xdata sequence print start
+	function.
+
+return:
+	Executive outcomes. 1---call next function.
+	NULL---not call next function and sequence loop
+	stop.
+*******************************************************/
+static void *c_start(struct seq_file *m, loff_t *pos)
+{
+	return *pos < 1 ? (void *)1 : NULL;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen xdata sequence print next
+	function.
+
+return:
+	Executive outcomes. NULL---no next and call sequence
+	stop function.
+*******************************************************/
+static void *c_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	++*pos;
+	return NULL;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen xdata sequence print stop
+	function.
+
+return:
+	n.a.
+*******************************************************/
+static void c_stop(struct seq_file *m, void *v)
+{
+	return;
+}
+
+const struct seq_operations nvt_fw_version_seq_ops = {
+	.start  = c_start,
+	.next   = c_next,
+	.stop   = c_stop,
+	.show   = c_fw_version_show
+};
+
+const struct seq_operations nvt_seq_ops = {
+	.start  = c_start,
+	.next   = c_next,
+	.stop   = c_stop,
+	.show   = c_show
+};
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/nvt_fw_version open
+	function.
+
+return:
+	n.a.
+*******************************************************/
+static int32_t nvt_fw_version_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+	NVT_LOG("++\n");
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	if (nvt_get_fw_info()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	mutex_unlock(&ts->lock);
+
+	NVT_LOG("--\n");
+
+	return seq_open(file, &nvt_fw_version_seq_ops);
+}
+
+static const struct proc_ops nvt_fw_version_fops = {
+	//.owner = THIS_MODULE,
+	.proc_open = nvt_fw_version_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = seq_release,
+};
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/nvt_baseline open function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t nvt_baseline_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+	NVT_LOG("++\n");
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	if (nvt_clear_fw_status()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	nvt_change_mode(TEST_MODE_2);
+
+	if (nvt_check_fw_status()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	if (nvt_get_fw_info()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	nvt_read_mdata(ts->mmap->BASELINE_ADDR, ts->mmap->BASELINE_BTN_ADDR);
+
+	nvt_change_mode(NORMAL_MODE);
+
+	mutex_unlock(&ts->lock);
+
+	NVT_LOG("--\n");
+
+	return seq_open(file, &nvt_seq_ops);
+}
+
+static const struct proc_ops nvt_baseline_fops = {
+	//.owner = THIS_MODULE,
+	.proc_open = nvt_baseline_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = seq_release,
+};
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/nvt_raw open function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t nvt_raw_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+	NVT_LOG("++\n");
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	if (nvt_clear_fw_status()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	nvt_change_mode(TEST_MODE_2);
+
+	if (nvt_check_fw_status()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	if (nvt_get_fw_info()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	if (nvt_get_fw_pipe() == 0)
+		nvt_read_mdata(ts->mmap->RAW_PIPE0_ADDR, ts->mmap->RAW_BTN_PIPE0_ADDR);
+	else
+		nvt_read_mdata(ts->mmap->RAW_PIPE1_ADDR, ts->mmap->RAW_BTN_PIPE1_ADDR);
+
+	nvt_change_mode(NORMAL_MODE);
+
+	mutex_unlock(&ts->lock);
+
+	NVT_LOG("--\n");
+
+	return seq_open(file, &nvt_seq_ops);
+}
+
+static const struct proc_ops nvt_raw_fops = {
+	.proc_open = nvt_raw_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = seq_release,
+};
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/nvt_diff open function.
+
+return:
+	Executive outcomes. 0---succeed. negative---failed.
+*******************************************************/
+static int32_t nvt_diff_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+	NVT_LOG("++\n");
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	if (nvt_clear_fw_status()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	nvt_change_mode(TEST_MODE_2);
+
+	if (nvt_check_fw_status()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	if (nvt_get_fw_info()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	if (nvt_get_fw_pipe() == 0)
+		nvt_read_mdata(ts->mmap->DIFF_PIPE0_ADDR, ts->mmap->DIFF_BTN_PIPE0_ADDR);
+	else
+		nvt_read_mdata(ts->mmap->DIFF_PIPE1_ADDR, ts->mmap->DIFF_BTN_PIPE1_ADDR);
+
+	nvt_change_mode(NORMAL_MODE);
+
+	mutex_unlock(&ts->lock);
+
+	NVT_LOG("--\n");
+
+	return seq_open(file, &nvt_seq_ops);
+}
+
+static const struct proc_ops nvt_diff_fops = {
+	.proc_open = nvt_diff_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = seq_release,
+};
+
+/*******************************************************
+Description:
+	Novatek touchscreen read diff meta data function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_read_diff_mdata(uint32_t xdata_addr, uint32_t xdata_btn_addr)
+{
+	int32_t i = 0;
+	int32_t j = 0;
+	int32_t k = 0;
+	uint8_t buf[SPI_TANSFER_LENGTH + 1] = {0};
+	uint32_t head_addr = 0;
+	int32_t dummy_len = 0;
+	int32_t data_len = 0;
+	int32_t residual_len = 0;
+
+	//---set diff_data sector address & length---
+	head_addr = xdata_addr - (xdata_addr % XDATA_SECTOR_SIZE);
+	dummy_len = xdata_addr - head_addr;
+	data_len = ts->x_num * ts->y_num * 2;
+	residual_len = (head_addr + dummy_len + data_len) % XDATA_SECTOR_SIZE;
+
+	//printk("head_addr=0x%05X, dummy_len=0x%05X, data_len=0x%05X,
+	//residual_len=0x%05X\n", head_addr, dummy_len, data_len, residual_len);
+
+	//read diff_data : step 1
+	for (i = 0; i < ((dummy_len + data_len) / XDATA_SECTOR_SIZE); i++) {
+		//---read diff_data by SPI_TANSFER_LENGTH
+		for (j = 0; j < (XDATA_SECTOR_SIZE / SPI_TANSFER_LENGTH); j++) {
+			//---change diff_data index---
+			nvt_set_page(head_addr + (XDATA_SECTOR_SIZE * i) + (SPI_TANSFER_LENGTH * j));
+
+			//---read data---
+			buf[0] = SPI_TANSFER_LENGTH * j;
+			CTP_SPI_READ(ts->client, buf, SPI_TANSFER_LENGTH + 1);
+
+			//---copy buf to xdata_tmp---
+			for (k = 0; k < SPI_TANSFER_LENGTH; k++) {
+				xdata_tmp[XDATA_SECTOR_SIZE * i + SPI_TANSFER_LENGTH * j + k] = buf[k + 1];
+				//printk("0x%02X, 0x%04X\n", buf[k+1],
+				//(XDATA_SECTOR_SIZE*i + SPI_TANSFER_LENGTH*j + k));
+			}
+		}
+		//printk("addr=0x%05X\n", (head_addr+XDATA_SECTOR_SIZE*i));
+	}
+
+	//read diff_data : step2
+	if (residual_len != 0) {
+		//---read diff_data by SPI_TANSFER_LENGTH
+		for (j = 0; j < (residual_len / SPI_TANSFER_LENGTH + 1); j++) {
+			//---change diff_data index---
+			nvt_set_page(xdata_addr + data_len - residual_len + (SPI_TANSFER_LENGTH * j));
+
+			//---read data---
+			buf[0] = SPI_TANSFER_LENGTH * j;
+			CTP_SPI_READ(ts->client, buf, SPI_TANSFER_LENGTH + 1);
+
+			//---copy buf to xdata_tmp---
+			for (k = 0; k < SPI_TANSFER_LENGTH; k++) {
+				xdata_tmp[(dummy_len + data_len - residual_len) + SPI_TANSFER_LENGTH * j + k] = buf[k + 1];
+				//printk("0x%02X, 0x%04x\n", buf[k+1],
+				//((dummy_len+data_len-residual_len) + SPI_TANSFER_LENGTH*j + k));
+			}
+		}
+		//printk("addr=0x%05X\n", (xdata_addr+data_len-residual_len));
+	}
+
+	//---remove dummy data and 2bytes-to-1data---
+	for (i = 0; i < (data_len / 2); i++) {
+		diff_data[i] = (int16_t)(xdata_tmp[dummy_len + i * 2] + 256 * xdata_tmp[dummy_len + i * 2 + 1]);
+	}
+
+#if TOUCH_KEY_NUM > 0
+	//read button diff_data : step3
+	//---change diff_data index---
+	nvt_set_page(xdata_btn_addr);
+	//---read data---
+	buf[0] = (xdata_btn_addr & 0xFF);
+	CTP_SPI_READ(ts->client, buf, (TOUCH_KEY_NUM * 2 + 1));
+
+	//---2bytes-to-1data---
+	for (i = 0; i < TOUCH_KEY_NUM; i++) {
+		diff_data[ts->x_num * ts->y_num + i] = (int16_t)(buf[1 + i * 2] + 256 * buf[1 + i * 2 + 1]);
+	}
+#endif
+
+	//---set diff_data index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR);
+}
+
+/*2019.12.10 longcheer taocheng add for charger mode & other node start*/
+/*function description*/
+int32_t nvt_set_pf_switch(uint8_t pf_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set pf switch: %d\n", pf_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_pf_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	buf[1] = 0x70;
+	buf[2] = pf_switch;
+	ret = CTP_SPI_WRITE(ts->client, buf, 3);
+	if (ret < 0) {
+		NVT_ERR("Write pf switch command fail!\n");
+		goto nvt_set_pf_switch_out;
+	}
+
+nvt_set_pf_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_pf_switch(uint8_t *pf_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5D);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_pf_switch_out;
+	}
+
+	buf[0] = 0x5D;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read pf switch status fail!\n");
+		goto nvt_get_pf_switch_out;
+	}
+
+	*pf_switch = (buf[1] & 0x03);
+	NVT_LOG("pf_switch = %d\n", *pf_switch);
+
+nvt_get_pf_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_pf_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t pf_switch;
+	char tmp_buf[64];
+
+	NVT_LOG("++\n");
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_pf_switch(&pf_switch);
+
+	mutex_unlock(&ts->lock);
+//2019.12.21 longcheer taocheng edit for enable pf_proc
+	cnt = snprintf(tmp_buf, sizeof(tmp_buf), "pf_switch: %d\n", pf_switch);
+	if (copy_to_user(buf, tmp_buf, sizeof(tmp_buf))) {
+		NVT_ERR("copy_to_user() error!\n");
+		return -EFAULT;
+	}
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_pf_switch_proc_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t pf_switch;
+	char *tmp_buf;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value! count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/*2019.12.21 longcheer taocheng add for enable pf_proc start*/
+	/*function description*/
+	tmp_buf = kzalloc(count, GFP_KERNEL);
+	if (!tmp_buf) {
+		NVT_ERR("Allocate tmp_buf fail!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(tmp_buf, buf, count)) {
+		NVT_ERR("copy_from_user() error!\n");
+		ret = -EFAULT;
+		goto out;
+	}
+	/*2019.12.21 longcheer taocheng add for enable pf_proc end*/
+
+	ret = sscanf(tmp_buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value! ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if (tmp < 0 || tmp > 2) {
+		NVT_ERR("Invalid value! tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	pf_switch = (uint8_t)tmp;
+	NVT_LOG("pf_switch = %d\n", pf_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_pf_switch(pf_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	kfree(tmp_buf);
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct proc_ops nvt_pf_switch_fops = {
+	//.owner = THIS_MODULE,
+	.proc_read  = nvt_pf_switch_proc_read,
+	.proc_write = nvt_pf_switch_proc_write,
+};
+
+int32_t nvt_set_sensitivity_switch(uint8_t sensitivity_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set sensitivity switch: %d\n", sensitivity_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_sensitivity_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	buf[1] = 0x71;
+	buf[2] = sensitivity_switch;
+	ret = CTP_SPI_WRITE(ts->client, buf, 3);
+	if (ret < 0) {
+		NVT_ERR("Write sensitivity switch command fail!\n");
+		goto nvt_set_sensitivity_switch_out;
+	}
+
+nvt_set_sensitivity_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_sensitivity_switch(uint8_t *sensitivity_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5D);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_sensitivity_switch_out;
+	}
+
+	buf[0] = 0x5D;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read sensitivity switch status fail!\n");
+		goto nvt_get_sensitivity_switch_out;
+	}
+
+	*sensitivity_switch = ((buf[1] >> 2) & 0x03);
+	NVT_LOG("sensitivity_switch = %d\n", *sensitivity_switch);
+
+nvt_get_sensitivity_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_sensitivity_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t sensitivity_switch;
+	char tmp_buf[64];
+
+	NVT_LOG("++\n");
+
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_sensitivity_switch(&sensitivity_switch);
+
+	mutex_unlock(&ts->lock);
+
+	cnt = snprintf(tmp_buf, sizeof(tmp_buf), "sensitivity_switch: %d\n", sensitivity_switch);
+	if (copy_to_user(buf, tmp_buf, sizeof(tmp_buf))) {
+		NVT_ERR("copy_to_user() error!\n");
+		return -EFAULT;
+	}
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_sensitivity_switch_proc_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t sensitivity_switch;
+	char *tmp_buf;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value! count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+	/*2019.12.21 longcheer taocheng add for enable sensitivity_proc start*/
+	/*function description*/
+	tmp_buf = kzalloc(count, GFP_KERNEL);
+	if (!tmp_buf) {
+		NVT_ERR("Allocate tmp_buf fail!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(tmp_buf, buf, count)) {
+		NVT_ERR("copy_from_user() error!\n");
+		ret = -EFAULT;
+		goto out;
+	}
+	/*2019.12.21 longcheer taocheng add for enable sensitivity_proc end*/
+
+	ret = sscanf(tmp_buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value! ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if (tmp < 0 || tmp > 3) {
+		NVT_ERR("Invalid value! tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	sensitivity_switch = (uint8_t)tmp;
+	NVT_LOG("sensitivity_switch = %d\n", sensitivity_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_sensitivity_switch(sensitivity_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	//2019.12.21 longcheer taocheng add for enable sensitivity_proc
+	kfree(tmp_buf);
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct proc_ops nvt_sensitivity_switch_fops = {
+	//.owner = THIS_MODULE,
+	.proc_read = nvt_sensitivity_switch_proc_read,
+	.proc_write = nvt_sensitivity_switch_proc_write,
+};
+
+int32_t nvt_set_er_range_switch(uint8_t er_range_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set er range switch: %d\n", er_range_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_er_range_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	buf[1] = 0x72;
+	buf[2] = er_range_switch;
+	ret = CTP_SPI_WRITE(ts->client, buf, 3);
+	if (ret < 0) {
+		NVT_ERR("Write er range switch command fail!\n");
+		goto nvt_set_er_range_switch_out;
+	}
+
+nvt_set_er_range_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_er_range_switch(uint8_t *er_range_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5D);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_er_range_switch_out;
+	}
+
+	buf[0] = 0x5D;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read er range switch status fail!\n");
+		goto nvt_get_er_range_switch_out;
+	}
+
+	*er_range_switch = ((buf[1] >> 4) & 0x03);
+	NVT_LOG("er_range_switch = %d\n", *er_range_switch);
+
+nvt_get_er_range_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_er_range_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t er_range_switch;
+	char tmp_buf[64];
+
+	NVT_LOG("++\n");
+
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_er_range_switch(&er_range_switch);
+
+	mutex_unlock(&ts->lock);
+
+	cnt = snprintf(tmp_buf, sizeof(tmp_buf), "er_range_switch: %d\n", er_range_switch);
+	if (copy_to_user(buf, tmp_buf, sizeof(tmp_buf))) {
+		NVT_ERR("copy_to_user() error!\n");
+		return -EFAULT;
+	}
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_er_range_switch_proc_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t er_range_switch;
+	char *tmp_buf;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value! count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/*2019.12.21 longcheer taocheng add for enable er_range_proc start*/
+	/*function description*/
+	tmp_buf = kzalloc(count, GFP_KERNEL);
+	if (!tmp_buf) {
+		NVT_ERR("Allocate tmp_buf fail!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(tmp_buf, buf, count)) {
+		NVT_ERR("copy_from_user() error!\n");
+		ret = -EFAULT;
+		goto out;
+	}
+	/*2019.12.21 longcheer taocheng add for enable er_range_proc end*/
+	ret = sscanf(tmp_buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value! ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if (tmp < 0 || tmp > 3) {
+		NVT_ERR("Invalid value! tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	er_range_switch = (uint8_t)tmp;
+	NVT_LOG("er_range_switch = %d\n", er_range_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_er_range_switch(er_range_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	kfree(tmp_buf);
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct proc_ops nvt_er_range_switch_fops = {
+	//.owner = THIS_MODULE,
+	.proc_read = nvt_er_range_switch_proc_read,
+	.proc_write = nvt_er_range_switch_proc_write,
+};
+
+int32_t nvt_set_max_power_switch(uint8_t max_power_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set max power switch: %d\n", max_power_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_max_power_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	if (max_power_switch == 1) {
+		buf[1] = 0x75;
+	} else if (max_power_switch == 0) {
+		buf[1] = 0x76;
+	} else {
+		NVT_ERR("Invalid max power switch: %d\n", max_power_switch);
+		ret = -EINVAL;
+		goto nvt_set_max_power_switch_out;
+	}
+	ret = CTP_SPI_WRITE(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Write max power switch command fail!\n");
+		goto nvt_set_max_power_switch_out;
+	}
+
+nvt_set_max_power_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_max_power_switch(uint8_t *max_power_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5D);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_max_power_switch_out;
+	}
+
+	buf[0] = 0x5D;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read max power switch status fail!\n");
+		goto nvt_get_max_power_switch_out;
+	}
+
+	*max_power_switch = ((buf[1] >> 7) & 0x01);
+	NVT_LOG("max_power_switch = %d\n", *max_power_switch);
+
+nvt_get_max_power_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_max_power_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t max_power_switch;
+
+	NVT_LOG("++\n");
+
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_max_power_switch(&max_power_switch);
+
+	mutex_unlock(&ts->lock);
+
+	cnt = snprintf(buf, PAGE_SIZE - len, "max_power_switch: %d\n", max_power_switch);
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_max_power_switch_proc_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t max_power_switch;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value! count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = sscanf(buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value! ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if (tmp < 0 || tmp > 1) {
+		NVT_ERR("Invalid value! tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	max_power_switch = (uint8_t)tmp;
+	NVT_LOG("max_power_switch = %d\n", max_power_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_max_power_switch(max_power_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct proc_ops nvt_max_power_switch_fops = {
+	//.owner = THIS_MODULE,
+	.proc_read = nvt_max_power_switch_proc_read,
+	.proc_write = nvt_max_power_switch_proc_write,
+};
+
+int32_t nvt_set_edge_reject_switch(uint8_t edge_reject_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set edge reject switch: %d\n", edge_reject_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_edge_reject_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	if (edge_reject_switch == 1) {
+		// vertical
+		buf[1] = 0xBA;
+	} else if (edge_reject_switch == 2) {
+		// left up
+		buf[1] = 0xBB;
+	} else if (edge_reject_switch == 3) {
+		// righ up
+		buf[1] = 0xBC;
+	} else {
+		NVT_ERR("Invalid value! edge_reject_switch = %d\n", edge_reject_switch);
+		ret = -EINVAL;
+		goto nvt_set_edge_reject_switch_out;
+	}
+	ret = CTP_SPI_WRITE(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Write edge reject switch command fail!\n");
+		goto nvt_set_edge_reject_switch_out;
+	}
+
+nvt_set_edge_reject_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_edge_reject_switch(uint8_t *edge_reject_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5C);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_edge_reject_switch_out;
+	}
+
+	buf[0] = 0x5C;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read edge reject switch status fail!\n");
+		goto nvt_get_edge_reject_switch_out;
+	}
+
+	*edge_reject_switch = ((buf[1] >> 5) & 0x03);
+	NVT_LOG("edge_reject_switch = %d\n", *edge_reject_switch);
+
+nvt_get_edge_reject_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_edge_reject_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t edge_reject_switch;
+
+	NVT_LOG("++\n");
+
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_edge_reject_switch(&edge_reject_switch);
+
+	mutex_unlock(&ts->lock);
+
+	cnt = snprintf(buf, PAGE_SIZE - len, "edge_reject_switch: %d\n", edge_reject_switch);
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_edge_reject_switch_proc_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t edge_reject_switch;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value! count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = sscanf(buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value! ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if (tmp < 1 || tmp > 3) {
+		NVT_ERR("Invalid value! tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	edge_reject_switch = (uint8_t)tmp;
+	NVT_LOG("edge_reject_switch = %d\n", edge_reject_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_edge_reject_switch(edge_reject_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct proc_ops nvt_edge_reject_switch_fops = {
+	//.owner = THIS_MODULE,
+	.proc_read = nvt_edge_reject_switch_proc_read,
+	.proc_write = nvt_edge_reject_switch_proc_write,
+};
+
+int32_t nvt_set_pocket_palm_switch(uint8_t pocket_palm_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set pocket palm switch: %d\n", pocket_palm_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_pocket_palm_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	if (pocket_palm_switch == 0) {
+		// pocket palm disable
+		buf[1] = 0x74;
+	} else if (pocket_palm_switch == 1) {
+		// pocket palm enable
+		buf[1] = 0x73;
+	} else {
+		NVT_ERR("Invalid value! pocket_palm_switch = %d\n", pocket_palm_switch);
+		ret = -EINVAL;
+		goto nvt_set_pocket_palm_switch_out;
+	}
+	ret = CTP_SPI_WRITE(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Write pocket palm switch command fail!\n");
+		goto nvt_set_pocket_palm_switch_out;
+	}
+
+nvt_set_pocket_palm_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_pocket_palm_switch(uint8_t *pocket_palm_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5D);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_pocket_palm_switch_out;
+	}
+
+	buf[0] = 0x5D;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read pocket palm switch status fail!\n");
+		goto nvt_get_pocket_palm_switch_out;
+	}
+
+	*pocket_palm_switch = ((buf[1] >> 6) & 0x01);
+	NVT_LOG("pocket_palm_switch = %d\n", *pocket_palm_switch);
+
+nvt_get_pocket_palm_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_pocket_palm_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t pocket_palm_switch;
+	char tmp_buf[64];
+
+	NVT_LOG("++\n");
+
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_pocket_palm_switch(&pocket_palm_switch);
+
+	mutex_unlock(&ts->lock);
+//2020.01.02 longcheer taocheng edit for enable pocket_proc
+	cnt = snprintf(tmp_buf, sizeof(tmp_buf), "pocket_palm_switch: %d\n", pocket_palm_switch);
+	if (copy_to_user(buf, tmp_buf, sizeof(tmp_buf))) {
+		NVT_LOG("copy_to_user() error!\n");
+		return -EFAULT;
+	}
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_pocket_palm_switch_proc_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t pocket_palm_switch;
+	char *tmp_buf;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value!, count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+	/*2020.01.02 longcheer taocheng add for enable pocket_palm_proc start*/
+	/*function description*/
+	tmp_buf = kzalloc(count, GFP_KERNEL);
+	if (!tmp_buf) {
+		NVT_ERR("Allocate tmp_buf fail!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(tmp_buf, buf, count)) {
+		NVT_ERR("copy_from_user() error!\n");
+		ret = -EFAULT;
+		goto out;
+	}
+	/*2020.01.02 longcheer taocheng add for enable pocket_palm_proc end*/
+
+	ret = sscanf(tmp_buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value!, ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if ((tmp < 0) || (tmp > 1)) {
+		NVT_ERR("Invalid value!, tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	pocket_palm_switch = (uint8_t)tmp;
+	NVT_LOG("pocket_palm_switch = %d\n", pocket_palm_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_pocket_palm_switch(pocket_palm_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	kfree(tmp_buf);
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct proc_ops nvt_pocket_palm_switch_fops = {
+	//.owner = THIS_MODULE,
+	.proc_read  = nvt_pocket_palm_switch_proc_read,
+	.proc_write = nvt_pocket_palm_switch_proc_write,
+};
+
+int32_t nvt_set_charger_switch(uint8_t charger_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set charger switch: %d\n", charger_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_charger_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	if (charger_switch == 0) {
+		// charger off
+		buf[1] = 0x51;
+	} else if (charger_switch == 1) {
+		// charger on
+		buf[1] = 0x53;
+	} else {
+		NVT_ERR("Invalid value! charger_switch = %d\n", charger_switch);
+		ret = -EINVAL;
+		goto nvt_set_charger_switch_out;
+	}
+	ret = CTP_SPI_WRITE(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Write charger switch command fail!\n");
+		goto nvt_set_charger_switch_out;
+	}
+
+nvt_set_charger_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_charger_switch(uint8_t *charger_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5D);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_charger_switch_out;
+	}
+
+	buf[0] = 0x5C;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read charger switch status fail!\n");
+		goto nvt_get_charger_switch_out;
+	}
+
+	*charger_switch = ((buf[1] >> 2) & 0x01);
+	NVT_LOG("charger_switch = %d\n", *charger_switch);
+
+nvt_get_charger_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_charger_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t charger_switch;
+	char tmp_buf[64];
+
+	NVT_LOG("++\n");
+
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_charger_switch(&charger_switch);
+
+	mutex_unlock(&ts->lock);
+
+	cnt = snprintf(tmp_buf, sizeof(tmp_buf), "charger_switch: %d\n", charger_switch);
+	if (copy_to_user(buf, tmp_buf, sizeof(tmp_buf))) {
+		NVT_ERR("copy_to_user() error!\n");
+		return -EFAULT;
+	}
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_charger_switch_proc_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t charger_switch;
+	char *tmp_buf;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value!, count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	tmp_buf = kzalloc(count, GFP_KERNEL);
+	if (!tmp_buf) {
+		NVT_ERR("Allocate tmp_buf fail!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(tmp_buf, buf, count)) {
+		NVT_ERR("copy_from_user() error!\n");
+		ret =  -EFAULT;
+		goto out;
+	}
+	ret = sscanf(tmp_buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value!, ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if ((tmp < 0) || (tmp > 1)) {
+		NVT_ERR("Invalid value!, tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	charger_switch = (uint8_t)tmp;
+	NVT_LOG("charger_switch = %d\n", charger_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_charger_switch(charger_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	kfree(tmp_buf);
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct proc_ops nvt_charger_switch_fops = {
+	//.owner = THIS_MODULE,
+	.proc_read = nvt_charger_switch_proc_read,
+	.proc_write = nvt_charger_switch_proc_write,
+};
+/*2019.12.10 longcheer taocheng add for charger mode & other nodes end*/
+
+/*******************************************************
+Description:
+	Novatek touchscreen extra function proc. file node
+	initial function.
+
+return:
+	Executive outcomes. 0---succeed. -12---failed.
+*******************************************************/
+int32_t nvt_extra_proc_init(void)
+{
+	NVT_proc_fw_version_entry = proc_create(NVT_FW_VERSION, 0444, NULL, &nvt_fw_version_fops);
+	if (NVT_proc_fw_version_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_FW_VERSION);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_FW_VERSION);
+	}
+
+	NVT_proc_baseline_entry = proc_create(NVT_BASELINE, 0444, NULL, &nvt_baseline_fops);
+	if (NVT_proc_baseline_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_BASELINE);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_BASELINE);
+	}
+
+	NVT_proc_raw_entry = proc_create(NVT_RAW, 0444, NULL, &nvt_raw_fops);
+	if (NVT_proc_raw_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_RAW);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_RAW);
+	}
+
+	NVT_proc_diff_entry = proc_create(NVT_DIFF, 0444, NULL, &nvt_diff_fops);
+	if (NVT_proc_diff_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_DIFF);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_DIFF);
+	}
+
+/*2019.12.10 longcheer taocheng add for creating nodes begin*/
+/*function description*/
+	NVT_proc_pf_switch_entry = proc_create(NVT_PF_SWITCH, 0666, NULL, &nvt_pf_switch_fops);
+	if (NVT_proc_pf_switch_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_PF_SWITCH);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_PF_SWITCH);
+	}
+
+	NVT_proc_sensitivity_switch_entry = proc_create(NVT_SENSITIVITY_SWITCH, 0666, NULL, &nvt_sensitivity_switch_fops);
+	if (NVT_proc_sensitivity_switch_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_SENSITIVITY_SWITCH);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_SENSITIVITY_SWITCH);
+	}
+
+	NVT_proc_er_range_switch_entry = proc_create(NVT_ER_RANGE_SWITCH, 0666, NULL, &nvt_er_range_switch_fops);
+	if (NVT_proc_er_range_switch_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_ER_RANGE_SWITCH);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_ER_RANGE_SWITCH);
+	}
+
+	NVT_proc_max_power_switch_entry = proc_create(NVT_MAX_POWER_SWITCH, 0666, NULL, &nvt_max_power_switch_fops);
+	if (NVT_proc_max_power_switch_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_MAX_POWER_SWITCH);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_MAX_POWER_SWITCH);
+	}
+
+	NVT_proc_edge_reject_switch_entry = proc_create(NVT_EDGE_REJECT_SWITCH, 0666, NULL, &nvt_edge_reject_switch_fops);
+	if (NVT_proc_edge_reject_switch_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_EDGE_REJECT_SWITCH);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_EDGE_REJECT_SWITCH);
+	}
+
+	NVT_proc_pocket_palm_switch_entry = proc_create(NVT_POCKET_PALM_SWITCH, 0666, NULL, &nvt_pocket_palm_switch_fops);
+	if (NVT_proc_pocket_palm_switch_entry == NULL) {
+		NVT_ERR("create proc/nvt_pocket_palm_switch Failed!\n");
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/nvt_pocket_palm_switch Succeeded!\n");
+	}
+
+	NVT_proc_charger_switch_entry = proc_create(NVT_CHARGER_SWITCH, 0666, NULL, &nvt_charger_switch_fops);
+	if (NVT_proc_charger_switch_entry == NULL) {
+		NVT_ERR("create proc/nvt_charger_switch Failed!\n");
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/nvt_charger_switch Succeeded!\n");
+	}
+
+	return 0;
+}
+/*2019.12.10 longcheer taocheng add for creating nodes end*/
+
+/*******************************************************
+Description:
+	Novatek touchscreen extra function proc. file node
+	deinitial function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_extra_proc_deinit(void)
+{
+	if (NVT_proc_fw_version_entry != NULL) {
+		remove_proc_entry(NVT_FW_VERSION, NULL);
+		NVT_proc_fw_version_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_FW_VERSION);
+	}
+
+	if (NVT_proc_baseline_entry != NULL) {
+		remove_proc_entry(NVT_BASELINE, NULL);
+		NVT_proc_baseline_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_BASELINE);
+	}
+
+	if (NVT_proc_raw_entry != NULL) {
+		remove_proc_entry(NVT_RAW, NULL);
+		NVT_proc_raw_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_RAW);
+	}
+
+	if (NVT_proc_diff_entry != NULL) {
+		remove_proc_entry(NVT_DIFF, NULL);
+		NVT_proc_diff_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_DIFF);
+	}
+
+/*2019.12.10 longcheer taocheng add for charger extra proc begin*/
+/*function description*/
+	if (NVT_proc_pf_switch_entry != NULL) {
+		remove_proc_entry(NVT_PF_SWITCH, NULL);
+		NVT_proc_pf_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_PF_SWITCH);
+	}
+
+	if (NVT_proc_sensitivity_switch_entry != NULL) {
+		remove_proc_entry(NVT_SENSITIVITY_SWITCH, NULL);
+		NVT_proc_sensitivity_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_SENSITIVITY_SWITCH);
+	}
+
+	if (NVT_proc_er_range_switch_entry != NULL) {
+		remove_proc_entry(NVT_ER_RANGE_SWITCH, NULL);
+		NVT_proc_er_range_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_ER_RANGE_SWITCH);
+	}
+
+	if (NVT_proc_max_power_switch_entry != NULL) {
+		remove_proc_entry(NVT_MAX_POWER_SWITCH, NULL);
+		NVT_proc_max_power_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_MAX_POWER_SWITCH);
+	}
+
+	if (NVT_proc_edge_reject_switch_entry != NULL) {
+		remove_proc_entry(NVT_EDGE_REJECT_SWITCH, NULL);
+		NVT_proc_edge_reject_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_EDGE_REJECT_SWITCH);
+	}
+
+	if (NVT_proc_pocket_palm_switch_entry != NULL) {
+		remove_proc_entry(NVT_POCKET_PALM_SWITCH, NULL);
+		NVT_proc_pocket_palm_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_POCKET_PALM_SWITCH);
+	}
+
+	if (NVT_proc_charger_switch_entry != NULL) {
+		remove_proc_entry(NVT_CHARGER_SWITCH, NULL);
+		NVT_proc_charger_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_CHARGER_SWITCH);
+	}
+/*2019.12.10 longcheer taocheng add for charger extra proc end*/
+}
+#endif
diff --git a/drivers/input/touchscreen/nt36672c/nt36xxx_fw_update.c b/drivers/input/touchscreen/nt36672c/nt36xxx_fw_update.c
new file mode 100644
index 000000000000..b2dac6a50c5b
--- /dev/null
+++ b/drivers/input/touchscreen/nt36672c/nt36xxx_fw_update.c
@@ -0,0 +1,1165 @@
+/*
+ * Copyright (C) 2010 - 2018 Novatek, Inc.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ * $Revision: 43560 $
+ * $Date: 2019-04-19 11:34:19 +0800 (週五, 19 四月 2019) $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/firmware.h>
+#include <linux/gpio.h>
+
+#include "nt36xxx.h"
+
+#if BOOT_UPDATE_FIRMWARE
+
+#define SIZE_4KB 4096
+#define FLASH_SECTOR_SIZE SIZE_4KB
+#define FW_BIN_VER_OFFSET (fw_need_write_size - SIZE_4KB)
+#define FW_BIN_VER_BAR_OFFSET (FW_BIN_VER_OFFSET + 1)
+#define NVT_FLASH_END_FLAG_LEN 3
+#define NVT_FLASH_END_FLAG_ADDR (fw_need_write_size - NVT_FLASH_END_FLAG_LEN)
+
+#define NVT_DUMP_PARTITION      (0)
+#define NVT_DUMP_PARTITION_LEN  (1024)
+#define NVT_DUMP_PARTITION_PATH "/data/local/tmp"
+
+//static struct timeval start, end;
+const struct firmware *fw_entry;
+static size_t fw_need_write_size;
+static uint8_t *fwbuf;
+
+struct nvt_ts_bin_map {
+	char name[12];
+	uint32_t BIN_addr;
+	uint32_t SRAM_addr;
+	uint32_t size;
+	uint32_t crc;
+};
+
+static struct nvt_ts_bin_map *bin_map;
+
+static int32_t nvt_get_fw_need_write_size(const struct firmware *fw_entry)
+{
+	int32_t i = 0;
+	int32_t total_sectors_to_check = 0;
+
+	total_sectors_to_check = fw_entry->size / FLASH_SECTOR_SIZE;
+	/* printk("total_sectors_to_check = %d\n", total_sectors_to_check); */
+
+	for (i = total_sectors_to_check; i > 0; i--) {
+		/* printk("current end flag address checked = 0x%X\n", i * FLASH_SECTOR_SIZE - NVT_FLASH_END_FLAG_LEN); */
+		/* check if there is end flag "NVT" at the end of this sector */
+		if (strncmp(&fw_entry->data[i * FLASH_SECTOR_SIZE - NVT_FLASH_END_FLAG_LEN],
+			"NVT", NVT_FLASH_END_FLAG_LEN) == 0) {
+			fw_need_write_size = i * FLASH_SECTOR_SIZE;
+			NVT_LOG("fw_need_write_size = %zu(0x%zx), NVT end flag\n", fw_need_write_size, fw_need_write_size);
+			return 0;
+		}
+
+		/* check if there is end flag "MOD" at the end of this sector */
+		if (strncmp(&fw_entry->data[i * FLASH_SECTOR_SIZE - NVT_FLASH_END_FLAG_LEN],
+			"MOD", NVT_FLASH_END_FLAG_LEN) == 0) {
+			fw_need_write_size = i * FLASH_SECTOR_SIZE;
+			NVT_LOG("fw_need_write_size = %zu(0x%zx), MOD end flag\n", fw_need_write_size, fw_need_write_size);
+			return 0;
+		}
+	}
+
+	NVT_ERR("end flag \"NVT\" \"MOD\" not found!\n");
+	return -EPERM;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen init variable and allocate buffer
+for download firmware function.
+
+return:
+	n.a.
+*******************************************************/
+static int32_t nvt_download_init(void)
+{
+	/* allocate buffer for transfer firmware */
+	//NVT_LOG("NVT_TRANSFER_LEN = 0x%06X\n", NVT_TRANSFER_LEN);
+
+	if (fwbuf == NULL) {
+		fwbuf = (uint8_t *)kzalloc((NVT_TRANSFER_LEN + 1 + DUMMY_BYTES), GFP_KERNEL);
+		if (fwbuf == NULL) {
+			NVT_ERR("kzalloc for fwbuf failed!\n");
+			return -ENOMEM;
+		}
+	}
+
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen checksum function. Calculate bin
+file checksum for comparison.
+
+return:
+	n.a.
+*******************************************************/
+static uint32_t CheckSum(const u8 *data, size_t len)
+{
+	uint32_t i = 0;
+	uint32_t checksum = 0;
+
+	for (i = 0 ; i < len+1 ; i++)
+		checksum += data[i];
+
+	checksum += len;
+	checksum = ~checksum + 1;
+
+	return checksum;
+}
+
+static uint32_t byte_to_word(const uint8_t *data)
+{
+	return data[0] + (data[1] << 8) + (data[2] << 16) + (data[3] << 24);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen parsing bin header function.
+
+return:
+	n.a.
+*******************************************************/
+static uint32_t partition;
+static uint8_t ilm_dlm_num = 2;
+static int32_t nvt_bin_header_parser(const u8 *fwdata, size_t fwsize)
+{
+	uint32_t list = 0;
+	uint32_t pos = 0x00;
+	uint32_t end = 0x00;
+	uint8_t info_sec_num = 0;
+	uint8_t ovly_sec_num = 0;
+	uint8_t ovly_info = 0;
+
+	/* Find the header size */
+	end = fwdata[0] + (fwdata[1] << 8) + (fwdata[2] << 16) + (fwdata[3] << 24);
+	pos = 0x30;	// info section start at 0x30 offset
+	while (pos < end) {
+		info_sec_num++;
+		pos += 0x10;	/* each header info is 16 bytes */
+	}
+
+	/*
+	 * Find the DLM OVLY section
+	 * [0:3] Overlay Section Number
+	 * [4]   Overlay Info
+	 */
+	ovly_info = (fwdata[0x28] & 0x10) >> 4;
+	ovly_sec_num = (ovly_info) ? (fwdata[0x28] & 0x0F) : 0;
+
+	/*
+	 * calculate all partition number
+	 * ilm_dlm_num (ILM & DLM) + ovly_sec_num + info_sec_num
+	 */
+	partition = ilm_dlm_num + ovly_sec_num + info_sec_num;
+	NVT_LOG("ovly_info = %d, ilm_dlm_num = %d, ovly_sec_num = %d, info_sec_num = %d, partition = %d\n",
+			ovly_info, ilm_dlm_num, ovly_sec_num, info_sec_num, partition);
+
+	/* allocated memory for header info */
+	bin_map = (struct nvt_ts_bin_map *)kzalloc((partition+1) * sizeof(struct nvt_ts_bin_map), GFP_KERNEL);
+	if (bin_map == NULL) {
+		NVT_ERR("kzalloc for bin_map failed!\n");
+		return -ENOMEM;
+	}
+
+	for (list = 0; list < partition; list++) {
+		/*
+		 * [1] parsing ILM & DLM header info
+		 * BIN_addr : SRAM_addr : size (12-bytes)
+		 * crc located at 0x18 & 0x1C
+		 */
+		if (list < ilm_dlm_num) {
+			bin_map[list].BIN_addr = byte_to_word(&fwdata[0 + list*12]);
+			bin_map[list].SRAM_addr = byte_to_word(&fwdata[4 + list*12]);
+			bin_map[list].size = byte_to_word(&fwdata[8 + list*12]);
+			if (ts->hw_crc)
+				bin_map[list].crc = byte_to_word(&fwdata[0x18 + list*4]);
+			else { //ts->hw_crc
+				if ((bin_map[list].BIN_addr + bin_map[list].size) < fwsize)
+					bin_map[list].crc = CheckSum(&fwdata[bin_map[list].BIN_addr], bin_map[list].size);
+				else {
+					NVT_ERR("access range (0x%08X to 0x%08X) is larger than bin size!\n",
+							bin_map[list].BIN_addr, bin_map[list].BIN_addr + bin_map[list].size);
+					return -EINVAL;
+				}
+			} //ts->hw_crc
+			if (list == 0)
+				snprintf(bin_map[list].name, PAGE_SIZE, "ILM");
+			else if (list == 1)
+				snprintf(bin_map[list].name, PAGE_SIZE, "DLM");
+		}
+
+		/*
+		 * [2] parsing others header info
+		 * SRAM_addr : size : BIN_addr : crc (16-bytes)
+		 */
+		if ((list >= ilm_dlm_num) && (list < (ilm_dlm_num + info_sec_num))) {
+			/* others partition located at 0x30 offset */
+			pos = 0x30 + (0x10 * (list - ilm_dlm_num));
+
+			bin_map[list].SRAM_addr = byte_to_word(&fwdata[pos]);
+			bin_map[list].size = byte_to_word(&fwdata[pos+4]);
+			bin_map[list].BIN_addr = byte_to_word(&fwdata[pos+8]);
+			if (ts->hw_crc)
+				bin_map[list].crc = byte_to_word(&fwdata[pos+12]);
+			else { //ts->hw_crc
+				if ((bin_map[list].BIN_addr + bin_map[list].size) < fwsize)
+					bin_map[list].crc = CheckSum(&fwdata[bin_map[list].BIN_addr], bin_map[list].size);
+				else {
+					NVT_ERR("access range (0x%08X to 0x%08X) is larger than bin size!\n",
+							bin_map[list].BIN_addr, bin_map[list].BIN_addr + bin_map[list].size);
+					return -EINVAL;
+				}
+			} //ts->hw_crc
+			/* detect header end to protect parser function */
+			if ((bin_map[list].BIN_addr == 0) && (bin_map[list].size != 0)) {
+				snprintf(bin_map[list].name, PAGE_SIZE, "Header");
+			} else {
+				snprintf(bin_map[list].name, PAGE_SIZE, "Info-%d", (list - ilm_dlm_num));
+			}
+		}
+
+		/*
+		 * [3] parsing overlay section header info
+		 * SRAM_addr : size : BIN_addr : crc (16-bytes)
+		 */
+		if (list >= (ilm_dlm_num + info_sec_num)) {
+			/* overlay info located at DLM (list = 1) start addr */
+			pos = bin_map[1].BIN_addr + (0x10 * (list - ilm_dlm_num - info_sec_num));
+
+			bin_map[list].SRAM_addr = byte_to_word(&fwdata[pos]);
+			bin_map[list].size = byte_to_word(&fwdata[pos+4]);
+			bin_map[list].BIN_addr = byte_to_word(&fwdata[pos+8]);
+			if (ts->hw_crc)
+				bin_map[list].crc = byte_to_word(&fwdata[pos+12]);
+			else { //ts->hw_crc
+				if ((bin_map[list].BIN_addr + bin_map[list].size) < fwsize)
+					bin_map[list].crc = CheckSum(&fwdata[bin_map[list].BIN_addr], bin_map[list].size);
+				else {
+					NVT_ERR("access range (0x%08X to 0x%08X) is larger than bin size!\n",
+							bin_map[list].BIN_addr, bin_map[list].BIN_addr + bin_map[list].size);
+					return -EINVAL;
+				}
+			} //ts->hw_crc
+			snprintf(bin_map[list].name, PAGE_SIZE, "Overlay-%d", (list - ilm_dlm_num - info_sec_num));
+		}
+
+		/* BIN size error detect */
+		if ((bin_map[list].BIN_addr + bin_map[list].size) > fwsize) {
+			NVT_ERR("access range (0x%08X to 0x%08X) is larger than bin size!\n",
+					bin_map[list].BIN_addr, bin_map[list].BIN_addr + bin_map[list].size);
+			return -EINVAL;
+		}
+
+//		NVT_LOG("[%d][%s] SRAM (0x%08X), SIZE (0x%08X), BIN (0x%08X), CRC (0x%08X)\n",
+//				list, bin_map[list].name,
+//				bin_map[list].SRAM_addr, bin_map[list].size,  bin_map[list].BIN_addr, bin_map[list].crc);
+	}
+
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen release update firmware function.
+
+return:
+	n.a.
+*******************************************************/
+static void update_firmware_release(void)
+{
+	if (fw_entry) {
+		release_firmware(fw_entry);
+	}
+
+	fw_entry = NULL;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen request update firmware function.
+
+return:
+	Executive outcomes. 0---succeed. -1,-22---failed.
+*******************************************************/
+static int32_t update_firmware_request(char *filename)
+{
+	uint8_t retry = 0;
+	int32_t ret = 0;
+
+	if (NULL == filename) {
+		return -ENOENT;
+	}
+
+	while (1) {
+		NVT_LOG("filename is %s\n", filename);
+
+		ret = request_firmware(&fw_entry, filename, &ts->client->dev);
+		if (ret) {
+			NVT_ERR("firmware load failed, ret=%d\n", ret);
+			goto request_fail;
+		}
+
+		// check FW need to write size
+		if (nvt_get_fw_need_write_size(fw_entry)) {
+			NVT_ERR("get fw need to write size fail!\n");
+			ret = -EINVAL;
+			goto invalid;
+		}
+
+		// check if FW version add FW version bar equals 0xFF
+		if (*(fw_entry->data + FW_BIN_VER_OFFSET) + *(fw_entry->data + FW_BIN_VER_BAR_OFFSET) != 0xFF) {
+			NVT_ERR("bin file FW_VER + FW_VER_BAR should be 0xFF!\n");
+			NVT_ERR("FW_VER=0x%02X, FW_VER_BAR=0x%02X\n", *(fw_entry->data+FW_BIN_VER_OFFSET),
+					*(fw_entry->data+FW_BIN_VER_BAR_OFFSET));
+			ret = -ENOEXEC;
+			goto invalid;
+		}
+
+		/* BIN Header Parser */
+		ret = nvt_bin_header_parser(fw_entry->data, fw_entry->size);
+		if (ret) {
+			NVT_ERR("bin header parser failed\n");
+			goto invalid;
+		} else {
+			break;
+		}
+
+invalid:
+		update_firmware_release();
+		if (!IS_ERR_OR_NULL(bin_map)) {
+			kfree(bin_map);
+			bin_map = NULL;
+		}
+
+request_fail:
+		retry++;
+		if (unlikely(retry > 2)) {
+			NVT_ERR("error, retry=%d\n", retry);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+#if NVT_DUMP_PARTITION
+/*******************************************************
+Description:
+	Novatek touchscreen dump flash partition function.
+
+return:
+	n.a.
+*******************************************************/
+loff_t file_offset;
+static int32_t nvt_read_ram_and_save_file(uint32_t addr, uint16_t len, char *name)
+{
+	char file[256] = "";
+	uint8_t *fbufp = NULL;
+	int32_t ret = 0;
+	struct file *fp = NULL;
+	struct filename *vts_name;
+	mm_segment_t org_fs;
+
+	snprintf(file, PAGE_SIZE,  "%s/dump_%s.bin", NVT_DUMP_PARTITION_PATH, name);
+	NVT_LOG("Dump [%s] from 0x%08X to 0x%08X\n", file, addr, addr+len);
+
+	fbufp = (uint8_t *)kzalloc(len+1, GFP_KERNEL);
+	if (fbufp == NULL) {
+		NVT_ERR("kzalloc for fbufp failed!\n");
+		ret = -ENOMEM;
+		goto alloc_buf_fail;
+	}
+
+	org_fs = get_fs();
+	set_fs(KERNEL_DS);
+	vts_name = getname_kernel(file);
+	fp = file_open_name(vts_name, O_RDWR | O_CREAT, 0644);
+	//fp = filp_open(file, O_RDWR | O_CREAT, 0644);
+	if (fp == NULL || IS_ERR(fp)) {
+		ret = -ENOMEM;
+		NVT_ERR("open file failed\n");
+		goto open_file_fail;
+	}
+
+	/* SPI read */
+	//---set xdata index to addr---
+	nvt_set_page(addr);
+
+	fbufp[0] = addr & 0x7F;	//offset
+	CTP_SPI_READ(ts->client, fbufp, len+1);
+
+	/* Write to file */
+	ret = vfs_write(fp, (char __user *)fbufp+1, len, &file_offset);
+	if (ret != len) {
+		NVT_ERR("write file failed\n");
+		goto open_file_fail;
+	} else {
+		ret = 0;
+	}
+
+open_file_fail:
+	set_fs(org_fs);
+	if (!IS_ERR_OR_NULL(fp)) {
+		filp_close(fp, NULL);
+		fp = NULL;
+	}
+
+	if (!IS_ERR_OR_NULL(fbufp)) {
+		kfree(fbufp);
+		fbufp = NULL;
+	}
+alloc_buf_fail:
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen nvt_dump_partition function to dump
+ each partition for debug.
+
+return:
+	n.a.
+*******************************************************/
+static int32_t nvt_dump_partition(void)
+{
+	uint32_t list = 0;
+	char *name;
+	uint32_t SRAM_addr, size;
+	uint32_t i = 0;
+	uint16_t len = 0;
+	int32_t count = 0;
+	int32_t ret = 0;
+
+	if (NVT_DUMP_PARTITION_LEN >= sizeof(ts->rbuf)) {
+		NVT_ERR("dump len %d is larger than buffer size %ld\n",
+				NVT_DUMP_PARTITION_LEN, sizeof(ts->rbuf));
+		return -EINVAL;
+	} else if (NVT_DUMP_PARTITION_LEN >= NVT_TRANSFER_LEN) {
+		NVT_ERR("dump len %d is larger than NVT_TRANSFER_LEN\n", NVT_DUMP_PARTITION_LEN);
+		return -EINVAL;
+	}
+
+	if (bin_map == NULL) {
+		NVT_ERR("bin_map is NULL\n");
+		return -ENOMEM;
+	}
+
+	memset(fwbuf, 0, (NVT_DUMP_PARTITION_LEN+1));
+
+	for (list = 0; list < partition; list++) {
+		/* initialize variable */
+		SRAM_addr = bin_map[list].SRAM_addr;
+		size = bin_map[list].size;
+		name = bin_map[list].name;
+
+		/* ignore reserved partition (Reserved Partition size is zero) */
+		if (!size)
+			continue;
+		else
+			size = size + 1;
+
+		/* write data to SRAM */
+		if (size % NVT_DUMP_PARTITION_LEN)
+			count = (size / NVT_DUMP_PARTITION_LEN) + 1;
+		else
+			count = (size / NVT_DUMP_PARTITION_LEN);
+
+		for (i = 0 ; i < count ; i++) {
+			len = (size < NVT_DUMP_PARTITION_LEN) ? size : NVT_DUMP_PARTITION_LEN;
+
+			/* dump for debug download firmware */
+			ret = nvt_read_ram_and_save_file(SRAM_addr, len, name);
+			if (ret < 0) {
+				NVT_ERR("nvt_read_ram_and_save_file failed, ret = %d\n", ret);
+				goto out;
+			}
+
+			SRAM_addr += NVT_DUMP_PARTITION_LEN;
+			size -= NVT_DUMP_PARTITION_LEN;
+		}
+
+		file_offset = 0;
+	}
+
+out:
+	return ret;
+}
+#endif /* NVT_DUMP_PARTITION */
+
+/*******************************************************
+Description:
+	Novatek touchscreen write data to sram function.
+
+- fwdata   : The buffer is written
+- SRAM_addr: The sram destination address
+- size     : Number of data bytes in @fwdata being written
+- BIN_addr : The transferred data offset of @fwdata
+
+return:
+	Executive outcomes. 0---succeed. else---fail.
+*******************************************************/
+static int32_t nvt_write_sram(const u8 *fwdata,
+		uint32_t SRAM_addr, uint32_t size, uint32_t BIN_addr)
+{
+	int32_t ret = 0;
+	uint32_t i = 0;
+	uint16_t len = 0;
+	int32_t count = 0;
+
+	if (size % NVT_TRANSFER_LEN)
+		count = (size / NVT_TRANSFER_LEN) + 1;
+	else
+		count = (size / NVT_TRANSFER_LEN);
+
+	for (i = 0 ; i < count ; i++) {
+		len = (size < NVT_TRANSFER_LEN) ? size : NVT_TRANSFER_LEN;
+
+		//---set xdata index to start address of SRAM---
+		ret = nvt_set_page(SRAM_addr);
+		if (ret) {
+			NVT_ERR("set page failed, ret = %d\n", ret);
+			return ret;
+		}
+
+		//---write data into SRAM---
+		fwbuf[0] = SRAM_addr & 0x7F;	//offset
+		memcpy(fwbuf+1, &fwdata[BIN_addr], len);	//payload
+		ret = CTP_SPI_WRITE(ts->client, fwbuf, len+1);
+		if (ret) {
+			NVT_ERR("write to sram failed, ret = %d\n", ret);
+			return ret;
+		}
+
+		SRAM_addr += NVT_TRANSFER_LEN;
+		BIN_addr += NVT_TRANSFER_LEN;
+		size -= NVT_TRANSFER_LEN;
+	}
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen nvt_write_firmware function to write
+firmware into each partition.
+
+return:
+	n.a.
+*******************************************************/
+static int32_t nvt_write_firmware(const u8 *fwdata, size_t fwsize)
+{
+	uint32_t list = 0;
+	char *name;
+	uint32_t BIN_addr, SRAM_addr, size;
+	int32_t ret = 0;
+
+	memset(fwbuf, 0, (NVT_TRANSFER_LEN+1));
+
+	for (list = 0; list < partition; list++) {
+		/* initialize variable */
+		SRAM_addr = bin_map[list].SRAM_addr;
+		size = bin_map[list].size;
+		BIN_addr = bin_map[list].BIN_addr;
+		name = bin_map[list].name;
+
+//		NVT_LOG("[%d][%s] SRAM (0x%08X), SIZE (0x%08X), BIN (0x%08X)\n",
+//				list, name, SRAM_addr, size, BIN_addr);
+
+		/* Check data size */
+		if ((BIN_addr + size) > fwsize) {
+			NVT_ERR("access range (0x%08X to 0x%08X) is larger than bin size!\n",
+					BIN_addr, BIN_addr + size);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		/* ignore reserved partition (Reserved Partition size is zero) */
+		if (!size)
+			continue;
+		else
+			size = size + 1;
+
+		/* write data to SRAM */
+		ret = nvt_write_sram(fwdata, SRAM_addr, size, BIN_addr);
+		if (ret) {
+			NVT_ERR("sram program failed, ret = %d\n", ret);
+			goto out;
+		}
+	}
+
+out:
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen check checksum function.
+This function will compare file checksum and fw checksum.
+
+return:
+	n.a.
+*******************************************************/
+static int32_t nvt_check_fw_checksum(void)
+{
+	uint32_t fw_checksum = 0;
+	uint32_t len = partition*4;
+	uint32_t list = 0;
+	int32_t ret = 0;
+
+	memset(fwbuf, 0, (len+1));
+
+	//---set xdata index to checksum---
+	nvt_set_page(ts->mmap->R_ILM_CHECKSUM_ADDR);
+
+	/* read checksum */
+	fwbuf[0] = (ts->mmap->R_ILM_CHECKSUM_ADDR) & 0x7F;
+	ret = CTP_SPI_READ(ts->client, fwbuf, len+1);
+	if (ret) {
+		NVT_ERR("Read fw checksum failed\n");
+		return ret;
+	}
+
+	/*
+	 * Compare each checksum from fw
+	 * ILM + DLM + Overlay + Info
+	 * ilm_dlm_num (ILM & DLM) + ovly_sec_num + info_sec_num
+	 */
+	for (list = 0; list < partition; list++) {
+		fw_checksum = byte_to_word(&fwbuf[1+list*4]);
+
+		/* ignore reserved partition (Reserved Partition size is zero) */
+		if (!bin_map[list].size)
+			continue;
+
+		if (bin_map[list].crc != fw_checksum) {
+			NVT_ERR("[%d] BIN_checksum=0x%08X, FW_checksum=0x%08X\n",
+					list, bin_map[list].crc, fw_checksum);
+			ret = -EIO;
+		}
+	}
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen set bootload crc reg bank function.
+This function will set hw crc reg before enable crc function.
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_set_bld_crc_bank(uint32_t DES_ADDR, uint32_t SRAM_ADDR,
+		uint32_t LENGTH_ADDR, uint32_t size,
+		uint32_t G_CHECKSUM_ADDR, uint32_t crc)
+{
+	/* write destination address */
+	nvt_set_page(DES_ADDR);
+	fwbuf[0] = DES_ADDR & 0x7F;
+	fwbuf[1] = (SRAM_ADDR) & 0xFF;
+	fwbuf[2] = (SRAM_ADDR >> 8) & 0xFF;
+	fwbuf[3] = (SRAM_ADDR >> 16) & 0xFF;
+	CTP_SPI_WRITE(ts->client, fwbuf, 4);
+
+	/* write length */
+	//nvt_set_page(LENGTH_ADDR);
+	fwbuf[0] = LENGTH_ADDR & 0x7F;
+	fwbuf[1] = (size) & 0xFF;
+	fwbuf[2] = (size >> 8) & 0xFF;
+	fwbuf[3] = (size >> 16) & 0x01;
+	if (ts->hw_crc == 1) {
+		CTP_SPI_WRITE(ts->client, fwbuf, 3);
+	} else if (ts->hw_crc > 1) {
+		CTP_SPI_WRITE(ts->client, fwbuf, 4);
+	}
+
+	/* write golden dlm checksum */
+	//nvt_set_page(G_CHECKSUM_ADDR);
+	fwbuf[0] = G_CHECKSUM_ADDR & 0x7F;
+	fwbuf[1] = (crc) & 0xFF;
+	fwbuf[2] = (crc >> 8) & 0xFF;
+	fwbuf[3] = (crc >> 16) & 0xFF;
+	fwbuf[4] = (crc >> 24) & 0xFF;
+	CTP_SPI_WRITE(ts->client, fwbuf, 5);
+
+	return;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen set BLD hw crc function.
+This function will set ILM and DLM crc information to register.
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_set_bld_hw_crc(void)
+{
+	/* [0] ILM */
+	/* write register bank */
+	nvt_set_bld_crc_bank(ts->mmap->ILM_DES_ADDR, bin_map[0].SRAM_addr,
+			ts->mmap->ILM_LENGTH_ADDR, bin_map[0].size,
+			ts->mmap->G_ILM_CHECKSUM_ADDR, bin_map[0].crc);
+
+	/* [1] DLM */
+	/* write register bank */
+	nvt_set_bld_crc_bank(ts->mmap->DLM_DES_ADDR, bin_map[1].SRAM_addr,
+			ts->mmap->DLM_LENGTH_ADDR, bin_map[1].size,
+			ts->mmap->G_DLM_CHECKSUM_ADDR, bin_map[1].crc);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen read BLD hw crc info function.
+This function will check crc results from register.
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_read_bld_hw_crc(void)
+{
+	uint8_t buf[8] = {0};
+	uint32_t g_crc = 0, r_crc = 0;
+
+	/* CRC Flag */
+	nvt_set_page(ts->mmap->BLD_ILM_DLM_CRC_ADDR);
+	buf[0] = ts->mmap->BLD_ILM_DLM_CRC_ADDR & 0x7F;
+	buf[1] = 0x00;
+	CTP_SPI_READ(ts->client, buf, 2);
+	NVT_ERR("crc_done = %d, ilm_crc_flag = %d, dlm_crc_flag = %d\n",
+			(buf[1] >> 2) & 0x01, (buf[1] >> 0) & 0x01, (buf[1] >> 1) & 0x01);
+
+	/* ILM CRC */
+	nvt_set_page(ts->mmap->G_ILM_CHECKSUM_ADDR);
+	buf[0] = ts->mmap->G_ILM_CHECKSUM_ADDR & 0x7F;
+	buf[1] = 0x00;
+	buf[2] = 0x00;
+	buf[3] = 0x00;
+	buf[4] = 0x00;
+	CTP_SPI_READ(ts->client, buf, 5);
+	g_crc = buf[1] | (buf[2] << 8) | (buf[3] << 16) | (buf[4] << 24);
+
+	nvt_set_page(ts->mmap->R_ILM_CHECKSUM_ADDR);
+	buf[0] = ts->mmap->R_ILM_CHECKSUM_ADDR & 0x7F;
+	buf[1] = 0x00;
+	buf[2] = 0x00;
+	buf[3] = 0x00;
+	buf[4] = 0x00;
+	CTP_SPI_READ(ts->client, buf, 5);
+	r_crc = buf[1] | (buf[2] << 8) | (buf[3] << 16) | (buf[4] << 24);
+
+	NVT_ERR("ilm: bin crc = 0x%08X, golden = 0x%08X, result = 0x%08X\n",
+			bin_map[0].crc, g_crc, r_crc);
+
+	/* DLM CRC */
+	nvt_set_page(ts->mmap->G_DLM_CHECKSUM_ADDR);
+	buf[0] = ts->mmap->G_DLM_CHECKSUM_ADDR & 0x7F;
+	buf[1] = 0x00;
+	buf[2] = 0x00;
+	buf[3] = 0x00;
+	buf[4] = 0x00;
+	CTP_SPI_READ(ts->client, buf, 5);
+	g_crc = buf[1] | (buf[2] << 8) | (buf[3] << 16) | (buf[4] << 24);
+
+	nvt_set_page(ts->mmap->R_DLM_CHECKSUM_ADDR);
+	buf[0] = ts->mmap->R_DLM_CHECKSUM_ADDR & 0x7F;
+	buf[1] = 0x00;
+	buf[2] = 0x00;
+	buf[3] = 0x00;
+	buf[4] = 0x00;
+	CTP_SPI_READ(ts->client, buf, 5);
+	r_crc = buf[1] | (buf[2] << 8) | (buf[3] << 16) | (buf[4] << 24);
+
+	NVT_ERR("dlm: bin crc = 0x%08X, golden = 0x%08X, result = 0x%08X\n",
+			bin_map[1].crc, g_crc, r_crc);
+
+	return;
+}
+
+#if NVT_TOUCH_ESD_DISP_RECOVERY
+static int32_t nvt_check_crc_done_ilm_err(void)
+{
+    uint8_t buf[8] = {0};
+
+    nvt_set_page(ts->mmap->BLD_ILM_DLM_CRC_ADDR);
+    buf[0] = ts->mmap->BLD_ILM_DLM_CRC_ADDR & 0x7F;
+    buf[1] = 0x00;
+    CTP_SPI_READ(ts->client, buf, 2);
+
+    NVT_ERR("CRC DONE, ILM DLM FLAG = 0x%02X\n", buf[1]);
+    if (((buf[1] & ILM_CRC_FLAG) && (buf[1] & CRC_DONE)) ||
+		(buf[1] == 0xFE) ||
+			((buf[1] & CRC_DONE) == 0x00)) {
+	return 1;
+    } else {
+	return 0;
+    }
+}
+
+static int32_t nvt_f2c_read_write(uint8_t F2C_RW, uint32_t DDIC_REG_ADDR, uint16_t len, uint8_t *data)
+{
+    uint8_t buf[8] = {0};
+    uint8_t retry = 0;
+    uint8_t f2c_control = 0;
+    uint32_t f2c_retry = 0;
+    uint32_t retry_max = 5;
+    int32_t ret = 0;
+
+    nvt_sw_reset_idle();
+
+    //Setp1: Set REG CPU_IF_ADDR[15:0]
+    nvt_set_page(CPU_IF_ADDR);
+    buf[0] = CPU_IF_ADDR & 0x7F;
+    buf[1] = (DDIC_REG_ADDR) & 0xFF;
+    buf[2] = (DDIC_REG_ADDR >> 8) & 0xFF;
+    CTP_SPI_WRITE(ts->client, buf, 3);
+
+
+    //Step2: Set REG FFM_ADDR[15:0]
+    nvt_set_page(FFM_ADDR);
+    buf[0] = FFM_ADDR & 0x7F;
+    buf[1] = (TOUCH_DATA_ADDR) & 0xFF;
+    buf[2] = (TOUCH_DATA_ADDR >> 8) & 0xFF;
+    buf[3] = 0x00;
+    if (ts->hw_crc > 1) {
+	CTP_SPI_WRITE(ts->client, buf, 4);
+    } else {
+	CTP_SPI_WRITE(ts->client, buf, 3);
+	}
+
+    //Step3: Write Data to TOUCH_DATA_ADDR
+    nvt_write_addr(TOUCH_DATA_ADDR, *data);
+
+    //Step4: Set REG F2C_LENGT[H7:0]
+    nvt_write_addr(F2C_LENGTH, len);
+
+	//Enable CP_TP_CPU_REQ
+	nvt_write_addr(CP_TP_CPU_REQ, 0x01);
+
+nvt_f2c_retry:
+    //Step5: Set REG CPU_Polling_En, F2C_RW, CPU_IF_ADDR_INC, F2C_EN
+    nvt_set_page(FFM2CPU_CTL);
+    buf[0] = FFM2CPU_CTL & 0x7F;
+    buf[1] = 0xFF;
+    ret = CTP_SPI_READ(ts->client, buf,  1 + len);//1 is AddrL
+    if (ret) {
+	NVT_ERR("Read FFM2CPU control failed!\n");
+	return ret;
+    }
+
+    f2c_control = buf[1] |
+	(0x01 << BIT_F2C_EN) |
+	(0x01 << BIT_CPU_IF_ADDR_INC) |
+	(0x01 << BIT_CPU_POLLING_EN);
+
+    if (F2C_RW == F2C_RW_READ) {
+	f2c_control = f2c_control & (~(1 << BIT_F2C_RW));
+    } else if (F2C_RW == F2C_RW_WRITE) {
+	f2c_control = f2c_control | (1 << BIT_F2C_RW);
+    }
+
+    nvt_write_addr(FFM2CPU_CTL, f2c_control);
+
+    //Step6: wait F2C_EN = 0
+    retry = 0;
+    while (1) {
+	nvt_set_page(FFM2CPU_CTL);
+	buf[0] = FFM2CPU_CTL & 0x7F;
+	buf[1] = 0xFF;
+	buf[2] = 0xFF;
+	ret = CTP_SPI_READ(ts->client, buf,  3);
+	if (ret) {
+		NVT_ERR("Read FFM2CPU control failed!\n");
+		return ret;
+	}
+
+	if ((buf[1] & 0x01) == 0x00)
+		break;
+
+	usleep_range(1000, 1000);
+	retry++;
+
+	if (unlikely(retry > 40)) {
+		NVT_ERR("Wait F2C_EN = 0 failed! retry = %d\n", retry);
+		return -EIO;
+	}
+    }
+
+    //Step7: Check REG TH_CPU_CHK  status (1: Success,  0: Fail), if 0, can Retry Step5.
+    if (((buf[2] & 0x04) >> 2) != 0x01) {
+	f2c_retry++;
+	if (f2c_retry <= retry_max) {
+		goto nvt_f2c_retry;
+	} else {
+		NVT_ERR("check TH_CPU_CHK failed!, buf[1]=0x%02X, buf[2]=0x%02X, f2c_retry = %d\n",
+					buf[1], buf[2], f2c_retry);
+		return -EIO;
+	}
+    }
+
+    if (F2C_RW == F2C_RW_READ) {
+	nvt_set_page(TOUCH_DATA_ADDR);
+	buf[0] = TOUCH_DATA_ADDR & 0x7F;
+	buf[1] = 0xFF;
+	ret = CTP_SPI_READ(ts->client, buf,  1 + len);//1 is AddrL
+	if (ret) {
+		NVT_ERR("Read data failed!\n");
+		return ret;
+	}
+	*data = buf[1];
+    }
+
+    return ret;
+}
+
+static int32_t nvt_f2c_disp_off(void)
+{
+    uint8_t data = 0x00;
+
+    return nvt_f2c_read_write(F2C_RW_WRITE, DISP_OFF_ADDR, 1, &data);
+}
+#endif /* NVT_TOUCH_ESD_DISP_RECOVERY */
+
+/*******************************************************
+Description:
+	Novatek touchscreen Download_Firmware with HW CRC
+function. It's complete download firmware flow.
+
+return:
+	Executive outcomes. 0---succeed. else---fail.
+*******************************************************/
+static int32_t nvt_download_firmware_hw_crc(void)
+{
+	uint8_t retry = 0;
+	int32_t ret = 0;
+
+	//do_gettimeofday(&start);
+
+	while (1) {
+		/* bootloader reset to reset MCU */
+		nvt_bootloader_reset();
+
+		/* Start to write firmware process */
+		ret = nvt_write_firmware(fw_entry->data, fw_entry->size);
+		if (ret) {
+			NVT_ERR("Write_Firmware failed. (%d)\n", ret);
+			goto fail;
+		}
+
+#if NVT_DUMP_PARTITION
+		ret = nvt_dump_partition();
+		if (ret) {
+			NVT_ERR("nvt_dump_partition failed, ret = %d\n", ret);
+		}
+#endif
+
+		/* set ilm & dlm reg bank */
+		nvt_set_bld_hw_crc();
+
+		/* enable hw bld crc function */
+		nvt_bld_crc_enable();
+
+		/* clear fw reset status & enable fw crc check */
+		nvt_fw_crc_enable();
+
+		/* Set Boot Ready Bit */
+		nvt_boot_ready();
+
+		ret = nvt_check_fw_reset_state(RESET_STATE_INIT);
+		if (ret) {
+			NVT_ERR("nvt_check_fw_reset_state failed. (%d)\n", ret);
+			goto fail;
+		} else {
+			break;
+		}
+
+fail:
+		retry++;
+		if (unlikely(retry > 2)) {
+			NVT_ERR("error, retry=%d\n", retry);
+			nvt_read_bld_hw_crc();
+#if NVT_TOUCH_ESD_DISP_RECOVERY
+			if (nvt_check_crc_done_ilm_err() || nvt_check_crc_done_ilm_err() || nvt_check_crc_done_ilm_err()) {
+				NVT_ERR("set display off to trigger display esd recovery.\n");
+				nvt_f2c_disp_off();
+			}
+#endif /* #if NVT_TOUCH_ESD_DISP_RECOVERY */
+			break;
+		}
+	}
+
+	//do_gettimeofday(&end);
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen Download_Firmware function. It's
+complete download firmware flow.
+
+return:
+	n.a.
+*******************************************************/
+static int32_t nvt_download_firmware(void)
+{
+	uint8_t retry = 0;
+	int32_t ret = 0;
+
+	//do_gettimeofday(&start);
+
+	while (1) {
+		/*
+		 * Send eng reset cmd before download FW
+		 * Keep TP_RESX low when send eng reset cmd
+		 */
+#if NVT_TOUCH_SUPPORT_HW_RST
+		gpio_set_value(ts->reset_gpio, 0);
+		mdelay(1);	//wait 1ms
+#endif
+		nvt_eng_reset();
+#if NVT_TOUCH_SUPPORT_HW_RST
+		gpio_set_value(ts->reset_gpio, 1);
+		mdelay(10);	//wait tRT2BRST after TP_RST
+#endif
+		nvt_bootloader_reset();
+
+		/* clear fw reset status */
+		nvt_write_addr(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_RESET_COMPLETE, 0x00);
+
+		/* Start to write firmware process */
+		ret = nvt_write_firmware(fw_entry->data, fw_entry->size);
+		if (ret) {
+			NVT_ERR("Write_Firmware failed. (%d)\n", ret);
+			goto fail;
+		}
+
+#if NVT_DUMP_PARTITION
+		ret = nvt_dump_partition();
+		if (ret) {
+			NVT_ERR("nvt_dump_partition failed, ret = %d\n", ret);
+		}
+#endif
+
+		/* Set Boot Ready Bit */
+		nvt_boot_ready();
+
+		ret = nvt_check_fw_reset_state(RESET_STATE_INIT);
+		if (ret) {
+			NVT_ERR("nvt_check_fw_reset_state failed. (%d)\n", ret);
+			goto fail;
+		}
+
+		/* check fw checksum result */
+		ret = nvt_check_fw_checksum();
+		if (ret) {
+			NVT_ERR("firmware checksum not match, retry=%d\n", retry);
+			goto fail;
+		} else {
+			break;
+		}
+
+fail:
+		retry++;
+		if (unlikely(retry > 2)) {
+			NVT_ERR("error, retry=%d\n", retry);
+			break;
+		}
+	}
+
+	//do_gettimeofday(&end);
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen update firmware main function.
+
+return:
+	n.a.
+*******************************************************/
+int32_t nvt_update_firmware(char *firmware_name)
+{
+	int32_t ret = 0;
+
+	// request bin file in "/vendor/firmware"
+	ret = update_firmware_request(firmware_name);
+	if (ret) {
+		NVT_ERR("update_firmware_request failed. (%d)\n", ret);
+		goto request_firmware_fail;
+	}
+
+	/* initial buffer and variable */
+	ret = nvt_download_init();
+	if (ret) {
+		NVT_ERR("Download Init failed. (%d)\n", ret);
+		goto download_fail;
+	}
+
+	/* download firmware process */
+	if (ts->hw_crc)
+		ret = nvt_download_firmware_hw_crc();
+	else
+		ret = nvt_download_firmware();
+	if (ret) {
+		NVT_ERR("Download Firmware failed. (%d)\n", ret);
+		goto download_fail;
+	}
+
+	//NVT_LOG("Update firmware success! <%ld us>\n",
+	//		(end.tv_sec - start.tv_sec)*1000000L + (end.tv_usec - start.tv_usec));
+
+	/* Get FW Info */
+	ret = nvt_get_fw_info();
+	if (ret) {
+		NVT_ERR("nvt_get_fw_info failed. (%d)\n", ret);
+	}
+
+download_fail:
+	if (!IS_ERR_OR_NULL(bin_map)) {
+		kfree(bin_map);
+		bin_map = NULL;
+	}
+
+	update_firmware_release();
+request_firmware_fail:
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen update firmware when booting
+	function.
+
+return:
+	n.a.
+*******************************************************/
+void Boot_Update_Firmware(struct work_struct *work)
+{
+	mutex_lock(&ts->lock);
+	nvt_update_firmware(ts->boot_update_firmware_name);
+	mutex_unlock(&ts->lock);
+}
+#endif /* BOOT_UPDATE_FIRMWARE */
diff --git a/drivers/input/touchscreen/nt36672c/nt36xxx_mem_map.h b/drivers/input/touchscreen/nt36672c/nt36xxx_mem_map.h
new file mode 100644
index 000000000000..69c61cf21454
--- /dev/null
+++ b/drivers/input/touchscreen/nt36672c/nt36xxx_mem_map.h
@@ -0,0 +1,300 @@
+/*
+ * Copyright (C) 2010 - 2018 Novatek, Inc.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ * $Revision: 43560 $
+ * $Date: 2019-04-19 11:34:19 +0800 (週五, 19 四月 2019) $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+struct nvt_ts_mem_map {
+	uint32_t EVENT_BUF_ADDR;
+	uint32_t RAW_PIPE0_ADDR;
+	uint32_t RAW_PIPE1_ADDR;
+	uint32_t BASELINE_ADDR;
+	uint32_t BASELINE_BTN_ADDR;
+	uint32_t DIFF_PIPE0_ADDR;
+	uint32_t DIFF_PIPE1_ADDR;
+	uint32_t RAW_BTN_PIPE0_ADDR;
+	uint32_t RAW_BTN_PIPE1_ADDR;
+	uint32_t DIFF_BTN_PIPE0_ADDR;
+	uint32_t DIFF_BTN_PIPE1_ADDR;
+	uint32_t READ_FLASH_CHECKSUM_ADDR;
+	uint32_t RW_FLASH_DATA_ADDR;
+	/* Phase 2 Host Download */
+	uint32_t BOOT_RDY_ADDR;
+	uint32_t POR_CD_ADDR;
+	/* BLD CRC */
+	uint32_t BLD_LENGTH_ADDR;
+	uint32_t ILM_LENGTH_ADDR;
+	uint32_t DLM_LENGTH_ADDR;
+	uint32_t BLD_DES_ADDR;
+	uint32_t ILM_DES_ADDR;
+	uint32_t DLM_DES_ADDR;
+	uint32_t G_ILM_CHECKSUM_ADDR;
+	uint32_t G_DLM_CHECKSUM_ADDR;
+	uint32_t R_ILM_CHECKSUM_ADDR;
+	uint32_t R_DLM_CHECKSUM_ADDR;
+	uint32_t BLD_CRC_EN_ADDR;
+	uint32_t DMA_CRC_EN_ADDR;
+	uint32_t BLD_ILM_DLM_CRC_ADDR;
+	uint32_t DMA_CRC_FLAG_ADDR;
+};
+
+struct nvt_ts_hw_info {
+	uint8_t carrier_system;
+	uint8_t hw_crc;
+};
+
+static const struct nvt_ts_mem_map NT36526_memory_map = {
+	.EVENT_BUF_ADDR           = 0x22D00,
+	.RAW_PIPE0_ADDR           = 0x24000,
+	.RAW_PIPE1_ADDR           = 0x24000,
+	.BASELINE_ADDR            = 0x21758,
+	.BASELINE_BTN_ADDR        = 0,
+	.DIFF_PIPE0_ADDR          = 0x20AB0,
+	.DIFF_PIPE1_ADDR          = 0x24AB0,
+	.RAW_BTN_PIPE0_ADDR       = 0,
+	.RAW_BTN_PIPE1_ADDR       = 0,
+	.DIFF_BTN_PIPE0_ADDR      = 0,
+	.DIFF_BTN_PIPE1_ADDR      = 0,
+	.READ_FLASH_CHECKSUM_ADDR = 0x24000,
+	.RW_FLASH_DATA_ADDR       = 0x24002,
+	/* Phase 2 Host Download */
+	.BOOT_RDY_ADDR            = 0x3F10D,
+	/* BLD CRC */
+	.BLD_LENGTH_ADDR          = 0x3F138,	//0x3F138 ~ 0x3F13A	(3 bytes)
+	.ILM_LENGTH_ADDR          = 0x3F118,	//0x3F118 ~ 0x3F11A	(3 bytes)
+	.DLM_LENGTH_ADDR          = 0x3F130,	//0x3F130 ~ 0x3F132	(3 bytes)
+	.BLD_DES_ADDR             = 0x3F114,	//0x3F114 ~ 0x3F116	(3 bytes)
+	.ILM_DES_ADDR             = 0x3F128,	//0x3F128 ~ 0x3F12A	(3 bytes)
+	.DLM_DES_ADDR             = 0x3F12C,	//0x3F12C ~ 0x3F12E	(3 bytes)
+	.G_ILM_CHECKSUM_ADDR      = 0x3F100,	//0x3F100 ~ 0x3F103	(4 bytes)
+	.G_DLM_CHECKSUM_ADDR      = 0x3F104,	//0x3F104 ~ 0x3F107	(4 bytes)
+	.R_ILM_CHECKSUM_ADDR      = 0x3F120,	//0x3F120 ~ 0x3F123 (4 bytes)
+	.R_DLM_CHECKSUM_ADDR      = 0x3F124,	//0x3F124 ~ 0x3F127 (4 bytes)
+	.BLD_CRC_EN_ADDR          = 0x3F30E,
+	.DMA_CRC_EN_ADDR          = 0x3F136,
+	.BLD_ILM_DLM_CRC_ADDR     = 0x3F133,
+	.DMA_CRC_FLAG_ADDR        = 0x3F134,
+};
+
+
+static const struct nvt_ts_mem_map NT36675_memory_map = {
+	.EVENT_BUF_ADDR           = 0x22D00,
+	.RAW_PIPE0_ADDR           = 0x24000,
+	.RAW_PIPE1_ADDR           = 0x24000,
+	.BASELINE_ADDR            = 0x21B90,
+	.BASELINE_BTN_ADDR        = 0,
+	.DIFF_PIPE0_ADDR          = 0x20C60,
+	.DIFF_PIPE1_ADDR          = 0x24C60,
+	.RAW_BTN_PIPE0_ADDR       = 0,
+	.RAW_BTN_PIPE1_ADDR       = 0,
+	.DIFF_BTN_PIPE0_ADDR      = 0,
+	.DIFF_BTN_PIPE1_ADDR      = 0,
+	.READ_FLASH_CHECKSUM_ADDR = 0x24000,
+	.RW_FLASH_DATA_ADDR       = 0x24002,
+	/* Phase 2 Host Download */
+	.BOOT_RDY_ADDR            = 0x3F10D,
+	/* BLD CRC */
+	.BLD_LENGTH_ADDR          = 0x3F138,	//0x3F138 ~ 0x3F13A	(3 bytes)
+	.ILM_LENGTH_ADDR          = 0x3F118,	//0x3F118 ~ 0x3F11A	(3 bytes)
+	.DLM_LENGTH_ADDR          = 0x3F130,	//0x3F130 ~ 0x3F132	(3 bytes)
+	.BLD_DES_ADDR             = 0x3F114,	//0x3F114 ~ 0x3F116	(3 bytes)
+	.ILM_DES_ADDR             = 0x3F128,	//0x3F128 ~ 0x3F12A	(3 bytes)
+	.DLM_DES_ADDR             = 0x3F12C,	//0x3F12C ~ 0x3F12E	(3 bytes)
+	.G_ILM_CHECKSUM_ADDR      = 0x3F100,	//0x3F100 ~ 0x3F103	(4 bytes)
+	.G_DLM_CHECKSUM_ADDR      = 0x3F104,	//0x3F104 ~ 0x3F107	(4 bytes)
+	.R_ILM_CHECKSUM_ADDR      = 0x3F120,	//0x3F120 ~ 0x3F123 (4 bytes)
+	.R_DLM_CHECKSUM_ADDR      = 0x3F124,	//0x3F124 ~ 0x3F127 (4 bytes)
+	.BLD_CRC_EN_ADDR          = 0x3F30E,
+	.DMA_CRC_EN_ADDR          = 0x3F136,
+	.BLD_ILM_DLM_CRC_ADDR     = 0x3F133,
+	.DMA_CRC_FLAG_ADDR        = 0x3F134,
+};
+
+
+static const struct nvt_ts_mem_map NT36672A_memory_map = {
+	.EVENT_BUF_ADDR           = 0x21C00,
+	.RAW_PIPE0_ADDR           = 0x20000,
+	.RAW_PIPE1_ADDR           = 0x23000,
+	.BASELINE_ADDR            = 0x20BFC,
+	.BASELINE_BTN_ADDR        = 0x23BFC,
+	.DIFF_PIPE0_ADDR          = 0x206DC,
+	.DIFF_PIPE1_ADDR          = 0x236DC,
+	.RAW_BTN_PIPE0_ADDR       = 0x20510,
+	.RAW_BTN_PIPE1_ADDR       = 0x23510,
+	.DIFF_BTN_PIPE0_ADDR      = 0x20BF0,
+	.DIFF_BTN_PIPE1_ADDR      = 0x23BF0,
+	.READ_FLASH_CHECKSUM_ADDR = 0x24000,
+	.RW_FLASH_DATA_ADDR       = 0x24002,
+	/* Phase 2 Host Download */
+	.BOOT_RDY_ADDR            = 0x3F10D,
+	/* BLD CRC */
+	.BLD_LENGTH_ADDR          = 0x3F10E,	//0x3F10E ~ 0x3F10F	(2 bytes)
+	.ILM_LENGTH_ADDR          = 0x3F118,	//0x3F118 ~ 0x3F119	(2 bytes)
+	.DLM_LENGTH_ADDR          = 0x3F130,	//0x3F130 ~ 0x3F131	(2 bytes)
+	.BLD_DES_ADDR             = 0x3F114,	//0x3F114 ~ 0x3F116	(3 bytes)
+	.ILM_DES_ADDR             = 0x3F128,	//0x3F128 ~ 0x3F12A	(3 bytes)
+	.DLM_DES_ADDR             = 0x3F12C,	//0x3F12C ~ 0x3F12E	(3 bytes)
+	.G_ILM_CHECKSUM_ADDR      = 0x3F100,	//0x3F100 ~ 0x3F103	(4 bytes)
+	.G_DLM_CHECKSUM_ADDR      = 0x3F104,	//0x3F104 ~ 0x3F107	(4 bytes)
+	.R_ILM_CHECKSUM_ADDR      = 0x3F120,	//0x3F120 ~ 0x3F123 (4 bytes)
+	.R_DLM_CHECKSUM_ADDR      = 0x3F124,	//0x3F124 ~ 0x3F127 (4 bytes)
+	.BLD_CRC_EN_ADDR          = 0x3F30E,
+	.DMA_CRC_EN_ADDR          = 0x3F132,
+	.BLD_ILM_DLM_CRC_ADDR     = 0x3F133,
+	.DMA_CRC_FLAG_ADDR        = 0x3F134,
+};
+
+static const struct nvt_ts_mem_map NT36772_memory_map = {
+	.EVENT_BUF_ADDR           = 0x11E00,
+	.RAW_PIPE0_ADDR           = 0x10000,
+	.RAW_PIPE1_ADDR           = 0x12000,
+	.BASELINE_ADDR            = 0x10E70,
+	.BASELINE_BTN_ADDR        = 0x12E70,
+	.DIFF_PIPE0_ADDR          = 0x10830,
+	.DIFF_PIPE1_ADDR          = 0x12830,
+	.RAW_BTN_PIPE0_ADDR       = 0x10E60,
+	.RAW_BTN_PIPE1_ADDR       = 0x12E60,
+	.DIFF_BTN_PIPE0_ADDR      = 0x10E68,
+	.DIFF_BTN_PIPE1_ADDR      = 0x12E68,
+	.READ_FLASH_CHECKSUM_ADDR = 0x14000,
+	.RW_FLASH_DATA_ADDR       = 0x14002,
+	/* Phase 2 Host Download */
+	.BOOT_RDY_ADDR            = 0x1F141,
+	.POR_CD_ADDR              = 0x1F61C,
+	/* BLD CRC */
+	.R_ILM_CHECKSUM_ADDR      = 0x1BF00,
+};
+
+static const struct nvt_ts_mem_map NT36525_memory_map = {
+	.EVENT_BUF_ADDR           = 0x11A00,
+	.RAW_PIPE0_ADDR           = 0x10000,
+	.RAW_PIPE1_ADDR           = 0x12000,
+	.BASELINE_ADDR            = 0x10B08,
+	.BASELINE_BTN_ADDR        = 0x12B08,
+	.DIFF_PIPE0_ADDR          = 0x1064C,
+	.DIFF_PIPE1_ADDR          = 0x1264C,
+	.RAW_BTN_PIPE0_ADDR       = 0x10634,
+	.RAW_BTN_PIPE1_ADDR       = 0x12634,
+	.DIFF_BTN_PIPE0_ADDR      = 0x10AFC,
+	.DIFF_BTN_PIPE1_ADDR      = 0x12AFC,
+	.READ_FLASH_CHECKSUM_ADDR = 0x14000,
+	.RW_FLASH_DATA_ADDR       = 0x14002,
+	/* Phase 2 Host Download */
+	.BOOT_RDY_ADDR            = 0x1F141,
+	.POR_CD_ADDR              = 0x1F61C,
+	/* BLD CRC */
+	.R_ILM_CHECKSUM_ADDR      = 0x1BF00,
+};
+
+static const struct nvt_ts_mem_map NT36676F_memory_map = {
+	.EVENT_BUF_ADDR           = 0x11A00,
+	.RAW_PIPE0_ADDR           = 0x10000,
+	.RAW_PIPE1_ADDR           = 0x12000,
+	.BASELINE_ADDR            = 0x10B08,
+	.BASELINE_BTN_ADDR        = 0x12B08,
+	.DIFF_PIPE0_ADDR          = 0x1064C,
+	.DIFF_PIPE1_ADDR          = 0x1264C,
+	.RAW_BTN_PIPE0_ADDR       = 0x10634,
+	.RAW_BTN_PIPE1_ADDR       = 0x12634,
+	.DIFF_BTN_PIPE0_ADDR      = 0x10AFC,
+	.DIFF_BTN_PIPE1_ADDR      = 0x12AFC,
+	.READ_FLASH_CHECKSUM_ADDR = 0x14000,
+	.RW_FLASH_DATA_ADDR       = 0x14002,
+};
+
+static struct nvt_ts_hw_info NT36526_hw_info = {
+	.carrier_system = 2,
+	.hw_crc         = 2,
+};
+
+static struct nvt_ts_hw_info NT36675_hw_info = {
+	.carrier_system = 2,
+	.hw_crc         = 2,
+};
+
+static struct nvt_ts_hw_info NT36672A_hw_info = {
+	.carrier_system = 0,
+	.hw_crc         = 1,
+};
+
+static struct nvt_ts_hw_info NT36772_hw_info = {
+	.carrier_system = 0,
+	.hw_crc         = 0,
+};
+
+static struct nvt_ts_hw_info NT36525_hw_info = {
+	.carrier_system = 0,
+	.hw_crc         = 0,
+};
+
+static struct nvt_ts_hw_info NT36676F_hw_info = {
+	.carrier_system = 0,
+	.hw_crc         = 0,
+};
+
+#define NVT_ID_BYTE_MAX 6
+struct nvt_ts_trim_id_table {
+	uint8_t id[NVT_ID_BYTE_MAX];
+	uint8_t mask[NVT_ID_BYTE_MAX];
+	const struct nvt_ts_mem_map *mmap;
+	const struct nvt_ts_hw_info *hwinfo;
+};
+
+static const struct nvt_ts_trim_id_table trim_id_table[] = {
+	{.id = {0x0C, 0xFF, 0xFF, 0x72, 0x66, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36675_memory_map,  .hwinfo = &NT36675_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x26, 0x65, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36526_memory_map,  .hwinfo = &NT36526_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x75, 0x66, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36675_memory_map,  .hwinfo = &NT36675_hw_info},
+	{.id = {0x0B, 0xFF, 0xFF, 0x72, 0x66, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0B, 0xFF, 0xFF, 0x82, 0x66, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0B, 0xFF, 0xFF, 0x25, 0x65, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0A, 0xFF, 0xFF, 0x72, 0x65, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0A, 0xFF, 0xFF, 0x72, 0x66, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0A, 0xFF, 0xFF, 0x82, 0x66, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0A, 0xFF, 0xFF, 0x70, 0x66, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0B, 0xFF, 0xFF, 0x70, 0x66, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0A, 0xFF, 0xFF, 0x72, 0x67, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x55, 0x00, 0xFF, 0x00, 0x00, 0x00}, .mask = {1, 1, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0x55, 0x72, 0xFF, 0x00, 0x00, 0x00}, .mask = {1, 1, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xAA, 0x00, 0xFF, 0x00, 0x00, 0x00}, .mask = {1, 1, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xAA, 0x72, 0xFF, 0x00, 0x00, 0x00}, .mask = {1, 1, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x72, 0x67, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x70, 0x66, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x70, 0x67, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x72, 0x66, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x25, 0x65, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36525_memory_map,  .hwinfo = &NT36525_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x76, 0x66, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36676F_memory_map, .hwinfo = &NT36676F_hw_info}
+};
diff --git a/drivers/input/touchscreen/nt36xxx_spi/Kconfig b/drivers/input/touchscreen/nt36xxx_spi/Kconfig
new file mode 100644
index 000000000000..6e3da3c40812
--- /dev/null
+++ b/drivers/input/touchscreen/nt36xxx_spi/Kconfig
@@ -0,0 +1,22 @@
+#
+# Novatek NT36xxx touchscreen driver configuration
+#
+config TOUCHSCREEN_NT36xxx_HOSTDL_SPI
+	tristate "Novatek NT36xxx host download SPI driver"
+	depends on SPI
+	default n
+	help
+	  Say Y here if you have a Novatek NT36xxx no flash touchscreen connected
+	  to your system by SPI bus.
+
+	  If unsure, say N.
+
+config TOUCHSCREEN_NT36xxx_HOSTDL_SPI_C3X
+	tristate "Novatek NT36xxx host download SPI driver"
+	depends on SPI
+	default n
+	help
+	  Say Y here if you have a Novatek NT36xxx no flash touchscreen connected
+	  to your system by SPI bus.
+
+	  If unsure, say N.
diff --git a/drivers/input/touchscreen/nt36xxx_spi/Makefile b/drivers/input/touchscreen/nt36xxx_spi/Makefile
new file mode 100644
index 000000000000..695b51bdefa5
--- /dev/null
+++ b/drivers/input/touchscreen/nt36xxx_spi/Makefile
@@ -0,0 +1,10 @@
+#
+# Makefile for the Novatek NT36xxx touchscreen driver.
+#
+
+# Each configuration option enables a list of files.
+
+#ccflags-y = -fdirectives-only -E -fno-canonical-system-headers -dN -dI -dU
+
+obj-$(CONFIG_TOUCHSCREEN_NT36xxx_HOSTDL_SPI) += nt36xxxx.o
+nt36xxxx-objs += nt36xxx.o nt36xxx_fw_update.o nt36xxx_ext_proc.o
diff --git a/drivers/input/touchscreen/nt36xxx_spi/nt36xxx.c b/drivers/input/touchscreen/nt36xxx_spi/nt36xxx.c
new file mode 100644
index 000000000000..c4b3a8790303
--- /dev/null
+++ b/drivers/input/touchscreen/nt36xxx_spi/nt36xxx.c
@@ -0,0 +1,2692 @@
+/*
+ * Copyright (C) 2010 - 2018 Novatek, Inc.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ *
+ * $Revision: 43560 $
+ * $Date: 2019-04-19 11:34:19 +0800 (週五, 19 四月 2019) $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/gpio.h>
+#include <linux/proc_fs.h>
+#include <linux/input/mt.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/pm_runtime.h>
+
+#include "nt36xxx.h"
+
+#if defined(CONFIG_FB)
+#ifdef CONFIG_DRM_MSM
+#include <linux/spi/spi-geni-qcom.h>
+#include <linux/msm_drm_notify.h>
+#endif
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
+
+#if NVT_TOUCH_ESD_PROTECT
+#include <linux/jiffies.h>
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+#if WAKEUP_GESTURE
+#ifdef CONFIG_TOUCHSCREEN_COMMON
+#include <linux/input/tp_common.h>
+#endif
+#endif
+
+#ifdef CHECK_TOUCH_VENDOR
+extern char *saved_command_line;
+
+//---Touch Vendor ID---
+static uint8_t touch_vendor_id = 0;
+#endif
+
+#if NVT_TOUCH_ESD_PROTECT
+static struct delayed_work nvt_esd_check_work;
+static struct workqueue_struct *nvt_esd_check_wq;
+static unsigned long irq_timer = 0;
+uint8_t esd_check = false;
+uint8_t esd_retry = 0;
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+#if NVT_TOUCH_EXT_PROC
+extern int32_t nvt_extra_proc_init(void);
+extern void nvt_extra_proc_deinit(void);
+#endif
+
+/*function description*/
+#if NVT_USB_PLUGIN
+static void nvt_ts_usb_plugin_work_func(struct work_struct *work);
+DECLARE_WORK(nvt_usb_plugin_work, nvt_ts_usb_plugin_work_func);
+extern touchscreen_usb_plugin_data_t g_touchscreen_usb_pulgin;
+#endif
+
+struct nvt_ts_data *ts;
+#if WAKEUP_GESTURE
+static struct device *spi_geni_master_dev;
+#endif
+
+#if BOOT_UPDATE_FIRMWARE
+static struct workqueue_struct *nvt_fwu_wq;
+extern void Boot_Update_Firmware(struct work_struct *work);
+#endif
+
+#if defined(CONFIG_FB)
+static void nvt_ts_resume_work(struct work_struct *work);
+#ifdef _MSM_DRM_NOTIFY_H_
+static int nvt_drm_notifier_callback(struct notifier_block *self, unsigned long event, void *data);
+#else
+static int nvt_fb_notifier_callback(struct notifier_block *self, unsigned long event, void *data);
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+static void nvt_ts_early_suspend(struct early_suspend *h);
+static void nvt_ts_late_resume(struct early_suspend *h);
+#endif
+
+#if WAKEUP_GESTURE
+extern void set_lcd_reset_gpio_keep_high(bool en);
+static int lct_nvt_tp_gesture_callback(bool flag);
+#endif
+
+uint32_t ENG_RST_ADDR  = 0x7FFF80;
+uint32_t SWRST_N8_ADDR = 0; //read from dtsi
+uint32_t SPI_RD_FAST_ADDR = 0;	//read from dtsi
+
+#if TOUCH_KEY_NUM > 0
+const uint16_t touch_key_array[TOUCH_KEY_NUM] = {
+	KEY_BACK,
+	KEY_HOME,
+	KEY_MENU
+};
+#endif
+
+#if WAKEUP_GESTURE
+const uint16_t gesture_key_array[] = {
+	KEY_WAKEUP,  //GESTURE_WORD_C
+	KEY_WAKEUP,  //GESTURE_WORD_W
+	KEY_WAKEUP,  //GESTURE_WORD_V
+	KEY_WAKEUP,  //GESTURE_DOUBLE_CLICK
+	KEY_WAKEUP,  //GESTURE_WORD_Z
+	KEY_WAKEUP,  //GESTURE_WORD_M
+	KEY_WAKEUP,  //GESTURE_WORD_O
+	KEY_WAKEUP,  //GESTURE_WORD_e
+	KEY_WAKEUP,  //GESTURE_WORD_S
+	KEY_WAKEUP,  //GESTURE_SLIDE_UP
+	KEY_WAKEUP,  //GESTURE_SLIDE_DOWN
+	KEY_WAKEUP,  //GESTURE_SLIDE_LEFT
+	KEY_WAKEUP,  //GESTURE_SLIDE_RIGHT
+	KEY_POWER,	 //FOR PALM USING ONLY
+};
+#endif
+
+#ifdef CONFIG_MTK_SPI
+const struct mt_chip_conf spi_ctrdata = {
+	.setuptime = 25,
+	.holdtime = 25,
+	.high_time = 5,	/* 10MHz (SPI_SPEED=100M / (high_time+low_time(10ns)))*/
+	.low_time = 5,
+	.cs_idletime = 2,
+	.ulthgh_thrsh = 0,
+	.cpol = 0,
+	.cpha = 0,
+	.rx_mlsb = 1,
+	.tx_mlsb = 1,
+	.tx_endian = 0,
+	.rx_endian = 0,
+	.com_mod = DMA_TRANSFER,
+	.pause = 0,
+	.finish_intr = 1,
+	.deassert = 0,
+	.ulthigh = 0,
+	.tckdly = 0,
+};
+#endif
+
+#ifdef CONFIG_SPI_MT65XX
+const struct mtk_chip_config spi_ctrdata = {
+    .rx_mlsb = 1,
+    .tx_mlsb = 1,
+    .cs_pol = 0,
+};
+#endif
+
+static uint8_t bTouchIsAwake = 0;
+
+#if WAKEUP_GESTURE
+#define WAKEUP_OFF 4
+#define WAKEUP_ON 5
+int nvt_gesture_switch(struct input_dev *dev, unsigned int type, unsigned int code, int value)
+{
+	NVT_LOG("Enter. type = %u, code = %u, value = %d\n", type, code, value);
+	if (type == EV_SYN && code == SYN_CONFIG) {
+		if (value == WAKEUP_OFF)
+			lct_nvt_tp_gesture_callback(false);
+		else if (value == WAKEUP_ON)
+			lct_nvt_tp_gesture_callback(true);
+	}
+	NVT_LOG("Exit\n");
+	return 0;
+}
+
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_COMMON
+static ssize_t double_tap_show(struct kobject *kobj,
+                               struct kobj_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%d\n", ts->is_gesture_mode);
+}
+
+static ssize_t double_tap_store(struct kobject *kobj,
+                                struct kobj_attribute *attr, const char *buf,
+                                size_t count)
+{
+    int rc, val;
+
+    rc = kstrtoint(buf, 10, &val);
+    if (rc)
+    return -EINVAL;
+
+    lct_nvt_tp_gesture_callback(!!val);
+    return count;
+}
+
+static struct tp_common_ops double_tap_ops = {
+    .show = double_tap_show,
+    .store = double_tap_store
+};
+#endif
+
+/*function description*/
+#if NVT_USB_PLUGIN
+void nvt_ts_usb_event_callback(void)
+{
+	schedule_work(&nvt_usb_plugin_work);
+}
+
+static void nvt_ts_usb_plugin_work_func(struct work_struct *work)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	if ( !bTouchIsAwake ) {
+		NVT_ERR("tp is suspended, can not to set\n");
+		return;
+	}
+
+	NVT_LOG("++\n");
+	mutex_lock(&ts->lock);
+	NVT_LOG("usb_plugged_in = %d\n", g_touchscreen_usb_pulgin.usb_plugged_in);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto exit;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	if (g_touchscreen_usb_pulgin.usb_plugged_in)
+		buf[1] = 0x53;// power plug ac on
+	else
+		buf[1] = 0x51;// power plug off
+
+	ret = CTP_SPI_WRITE(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Write pwr plug switch command fail!\n");
+		goto exit;
+	}
+
+exit:
+	mutex_unlock(&ts->lock);
+	NVT_LOG("--\n");
+}
+#endif
+
+/*******************************************************
+Description:
+	Novatek touchscreen irq enable/disable function.
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_irq_enable(bool enable)
+{
+	struct irq_desc *desc;
+
+	if (enable) {
+		if (!ts->irq_enabled) {
+			enable_irq(ts->client->irq);
+			ts->irq_enabled = true;
+		}
+	} else {
+		if (ts->irq_enabled) {
+			disable_irq(ts->client->irq);
+			ts->irq_enabled = false;
+		}
+	}
+
+	//desc = irq_to_desc(ts->client->irq);
+	desc = irq_data_to_desc(irq_get_irq_data(ts->client->irq));
+	NVT_LOG("enable=%d, desc->depth=%d\n", enable, desc->depth);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen spi read/write core function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static inline int32_t spi_read_write(struct spi_device *client, uint8_t *buf, size_t len , NVT_SPI_RW rw)
+{
+	struct spi_message m;
+	struct spi_transfer t = {
+		.len    = len,
+	};
+
+	memcpy(ts->xbuf, buf, len);
+
+	switch (rw) {
+		case NVTREAD:
+			t.tx_buf = ts->xbuf;
+			t.rx_buf = ts->rbuf;
+			t.len    = (len + DUMMY_BYTES);
+			break;
+
+		case NVTWRITE:
+			t.tx_buf = ts->xbuf;
+			break;
+	}
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	return spi_sync(client, &m);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen spi read function.
+
+return:
+	Executive outcomes. 2---succeed. -5---I/O error
+*******************************************************/
+int32_t CTP_SPI_READ(struct spi_device *client, uint8_t *buf, uint16_t len)
+{
+	int32_t ret = -1;
+	int32_t retries = 0;
+
+	mutex_lock(&ts->xbuf_lock);
+
+	buf[0] = SPI_READ_MASK(buf[0]);
+
+	while (retries < 5) {
+		ret = spi_read_write(client, buf, len, NVTREAD);
+		if (ret == 0) break;
+		retries++;
+	}
+
+	if (unlikely(retries == 5)) {
+		NVT_ERR("read error, ret=%d\n", ret);
+		ret = -EIO;
+	} else {
+		memcpy((buf+1), (ts->rbuf+2), (len-1));
+	}
+
+	mutex_unlock(&ts->xbuf_lock);
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen spi write function.
+
+return:
+	Executive outcomes. 1---succeed. -5---I/O error
+*******************************************************/
+int32_t CTP_SPI_WRITE(struct spi_device *client, uint8_t *buf, uint16_t len)
+{
+	int32_t ret = -1;
+	int32_t retries = 0;
+
+	mutex_lock(&ts->xbuf_lock);
+
+	buf[0] = SPI_WRITE_MASK(buf[0]);
+
+	while (retries < 5) {
+		ret = spi_read_write(client, buf, len, NVTWRITE);
+		if (ret == 0)	break;
+		retries++;
+	}
+
+	if (unlikely(retries == 5)) {
+		NVT_ERR("error, ret=%d\n", ret);
+		ret = -EIO;
+	}
+
+	mutex_unlock(&ts->xbuf_lock);
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen set index/page/addr address.
+
+return:
+	Executive outcomes. 0---succeed. -5---access fail.
+*******************************************************/
+int32_t nvt_set_page(uint32_t addr)
+{
+	uint8_t buf[4] = {0};
+
+	buf[0] = 0xFF;	//set index/page/addr command
+	buf[1] = (addr >> 15) & 0xFF;
+	buf[2] = (addr >> 7) & 0xFF;
+
+	return CTP_SPI_WRITE(ts->client, buf, 3);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen write data to specify address.
+
+return:
+	Executive outcomes. 0---succeed. -5---access fail.
+*******************************************************/
+int32_t nvt_write_addr(uint32_t addr, uint8_t data)
+{
+	int32_t ret = 0;
+	uint8_t buf[4] = {0};
+
+	//---set xdata index---
+	buf[0] = 0xFF;	//set index/page/addr command
+	buf[1] = (addr >> 15) & 0xFF;
+	buf[2] = (addr >> 7) & 0xFF;
+	ret = CTP_SPI_WRITE(ts->client, buf, 3);
+	if (ret) {
+		NVT_ERR("set page 0x%06X failed, ret = %d\n", addr, ret);
+		return ret;
+	}
+
+	//---write data to index---
+	buf[0] = addr & (0x7F);
+	buf[1] = data;
+	ret = CTP_SPI_WRITE(ts->client, buf, 2);
+	if (ret) {
+		NVT_ERR("write data to 0x%06X failed, ret = %d\n", addr, ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen enable hw bld crc function.
+
+return:
+	N/A.
+*******************************************************/
+void nvt_bld_crc_enable(void)
+{
+	uint8_t buf[2] = {0};
+
+	//---set xdata index to BLD_CRC_EN_ADDR---
+	nvt_set_page(ts->mmap->BLD_CRC_EN_ADDR);
+
+	//---read data from index---
+	buf[0] = ts->mmap->BLD_CRC_EN_ADDR & (0x7F);
+	buf[1] = 0xFF;
+	CTP_SPI_READ(ts->client, buf, 2);
+
+	//---write data to index---
+	buf[0] = ts->mmap->BLD_CRC_EN_ADDR & (0x7F);
+	buf[1] = buf[1] | (0x01 << 7);
+	CTP_SPI_WRITE(ts->client, buf, 2);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen clear status & enable fw crc function.
+
+return:
+	N/A.
+*******************************************************/
+void nvt_fw_crc_enable(void)
+{
+	uint8_t buf[2] = {0};
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR);
+
+	//---clear fw reset status---
+	buf[0] = EVENT_MAP_RESET_COMPLETE & (0x7F);
+	buf[1] = 0x00;
+	CTP_SPI_WRITE(ts->client, buf, 2);
+
+	//---enable fw crc---
+	buf[0] = EVENT_MAP_HOST_CMD & (0x7F);
+	buf[1] = 0xAE;	//enable fw crc command
+	CTP_SPI_WRITE(ts->client, buf, 2);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen set boot ready function.
+
+return:
+	N/A.
+*******************************************************/
+void nvt_boot_ready(void)
+{
+	//---write BOOT_RDY status cmds---
+	nvt_write_addr(ts->mmap->BOOT_RDY_ADDR, 1);
+
+	mdelay(5);
+
+	if (!ts->hw_crc) {
+		//---write BOOT_RDY status cmds---
+		nvt_write_addr(ts->mmap->BOOT_RDY_ADDR, 0);
+
+		//---write POR_CD cmds---
+		nvt_write_addr(ts->mmap->POR_CD_ADDR, 0xA0);
+	}
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen eng reset cmd
+    function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_eng_reset(void)
+{
+	//---eng reset cmds to ENG_RST_ADDR---
+	nvt_write_addr(ENG_RST_ADDR, 0x5A);
+
+	mdelay(1);	//wait tMCU_Idle2TP_REX_Hi after TP_RST
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen reset MCU
+    function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_sw_reset(void)
+{
+	//---software reset cmds to SWRST_N8_ADDR---
+	nvt_write_addr(SWRST_N8_ADDR, 0x55);
+
+	msleep(10);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen reset MCU then into idle mode
+    function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_sw_reset_idle(void)
+{
+	//---MCU idle cmds to SWRST_N8_ADDR---
+	nvt_write_addr(SWRST_N8_ADDR, 0xAA);
+
+	msleep(15);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen reset MCU (boot) function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_bootloader_reset(void)
+{
+	//---reset cmds to SWRST_N8_ADDR---
+	nvt_write_addr(SWRST_N8_ADDR, 0x69);
+
+	mdelay(5);	//wait tBRST2FR after Bootload RST
+
+	if (SPI_RD_FAST_ADDR) {
+		/* disable SPI_RD_FAST */
+		nvt_write_addr(SPI_RD_FAST_ADDR, 0x00);
+	}
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen clear FW status function.
+
+return:
+	Executive outcomes. 0---succeed. -1---fail.
+*******************************************************/
+int32_t nvt_clear_fw_status(void)
+{
+	uint8_t buf[8] = {0};
+	int32_t i = 0;
+	const int32_t retry = 20;
+
+	for (i = 0; i < retry; i++) {
+		//---set xdata index to EVENT BUF ADDR---
+		nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE);
+
+		//---clear fw status---
+		buf[0] = EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE;
+		buf[1] = 0x00;
+		CTP_SPI_WRITE(ts->client, buf, 2);
+
+		//---read fw status---
+		buf[0] = EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE;
+		buf[1] = 0xFF;
+		CTP_SPI_READ(ts->client, buf, 2);
+
+		if (buf[1] == 0x00)
+			break;
+
+		usleep_range(10000, 10000);
+	}
+
+	if (i >= retry) {
+		NVT_ERR("failed, i=%d, buf[1]=0x%02X\n", i, buf[1]);
+		return -1;
+	} else {
+		return 0;
+	}
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen check FW status function.
+
+return:
+	Executive outcomes. 0---succeed. -1---failed.
+*******************************************************/
+int32_t nvt_check_fw_status(void)
+{
+	uint8_t buf[8] = {0};
+	int32_t i = 0;
+	const int32_t retry = 50;
+
+	for (i = 0; i < retry; i++) {
+		//---set xdata index to EVENT BUF ADDR---
+		nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE);
+
+		//---read fw status---
+		buf[0] = EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE;
+		buf[1] = 0x00;
+		CTP_SPI_READ(ts->client, buf, 2);
+
+		if ((buf[1] & 0xF0) == 0xA0)
+			break;
+
+		usleep_range(10000, 10000);
+	}
+
+	if (i >= retry) {
+		NVT_ERR("failed, i=%d, buf[1]=0x%02X\n", i, buf[1]);
+		return -1;
+	} else {
+		return 0;
+	}
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen check FW reset state function.
+
+return:
+	Executive outcomes. 0---succeed. -1---failed.
+*******************************************************/
+int32_t nvt_check_fw_reset_state(RST_COMPLETE_STATE check_reset_state)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+	int32_t retry = 0;
+	int32_t retry_max = (check_reset_state == RESET_STATE_INIT) ? 10 : 50;
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_RESET_COMPLETE);
+
+	while (1) {
+		//---read reset state---
+		buf[0] = EVENT_MAP_RESET_COMPLETE;
+		buf[1] = 0x00;
+		CTP_SPI_READ(ts->client, buf, 6);
+
+		if ((buf[1] >= check_reset_state) && (buf[1] <= RESET_STATE_MAX)) {
+			ret = 0;
+			break;
+		}
+
+		retry++;
+		if(unlikely(retry > retry_max)) {
+			NVT_ERR("error, retry=%d, buf[1]=0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X\n",
+				retry, buf[1], buf[2], buf[3], buf[4], buf[5]);
+			ret = -1;
+			break;
+		}
+
+		usleep_range(10000, 10000);
+	}
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen get novatek project id information
+	function.
+
+return:
+	Executive outcomes. 0---success. -1---fail.
+*******************************************************/
+int32_t nvt_read_pid(void)
+{
+	uint8_t buf[3] = {0};
+	int32_t ret = 0;
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_PROJECTID);
+
+	//---read project id---
+	buf[0] = EVENT_MAP_PROJECTID;
+	buf[1] = 0x00;
+	buf[2] = 0x00;
+	CTP_SPI_READ(ts->client, buf, 3);
+
+	ts->nvt_pid = (buf[2] << 8) + buf[1];
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR);
+
+	NVT_LOG("PID=%04X\n", ts->nvt_pid);
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen get firmware related information
+	function.
+
+return:
+	Executive outcomes. 0---success. -1---fail.
+*******************************************************/
+int32_t nvt_get_fw_info(void)
+{
+	uint8_t buf[64] = {0};
+	uint8_t tp_info_buf[64] = {0};
+	uint32_t retry_count = 0;
+	int32_t ret = 0;
+
+info_retry:
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_FWINFO);
+
+	//---read fw info---
+	buf[0] = EVENT_MAP_FWINFO;
+	CTP_SPI_READ(ts->client, buf, 17);
+	ts->fw_ver = buf[1];
+	ts->x_num = buf[3];
+	ts->y_num = buf[4];
+	ts->abs_x_max = (uint16_t)((buf[5] << 8) | buf[6]);
+	ts->abs_y_max = (uint16_t)((buf[7] << 8) | buf[8]);
+	ts->max_button_num = buf[11];
+
+	//---clear x_num, y_num if fw info is broken---
+	if ((buf[1] + buf[2]) != 0xFF) {
+		NVT_ERR("FW info is broken! fw_ver=0x%02X, ~fw_ver=0x%02X\n", buf[1], buf[2]);
+		ts->fw_ver = 0;
+		ts->x_num = 18;
+		ts->y_num = 32;
+		ts->abs_x_max = TOUCH_DEFAULT_MAX_WIDTH;
+		ts->abs_y_max = TOUCH_DEFAULT_MAX_HEIGHT;
+		ts->max_button_num = TOUCH_KEY_NUM;
+
+		if(retry_count < 3) {
+			retry_count++;
+			NVT_ERR("retry_count=%d\n", retry_count);
+			goto info_retry;
+		} else {
+			NVT_ERR("Set default fw_ver=%d, x_num=%d, y_num=%d, "
+					"abs_x_max=%d, abs_y_max=%d, max_button_num=%d!\n",
+					ts->fw_ver, ts->x_num, ts->y_num,
+					ts->abs_x_max, ts->abs_y_max, ts->max_button_num);
+			ret = -1;
+		}
+	} else {
+		ret = 0;
+	}
+
+	NVT_LOG("fw_ver = 0x%02X, fw_type = 0x%02X\n", ts->fw_ver, buf[14]);
+
+#ifdef CHECK_TOUCH_VENDOR
+	switch(ts->touch_vendor_id) {
+	case TP_VENDOR_TIANMA:
+		sprintf(tp_info_buf, "[Vendor]tianma,[FW]0x%02x,[IC]nt36675\n", ts->fw_ver);
+		break;
+	}
+#else
+	sprintf(tp_info_buf, "[Vendor]unknow,[FW]0x%02x,[IC]nt36675\n", ts->fw_ver);
+#endif
+
+	//---Get Novatek PID---
+	nvt_read_pid();
+
+	return ret;
+}
+
+/*******************************************************
+  Create Device Node (Proc Entry)
+*******************************************************/
+#if NVT_TOUCH_PROC
+static struct proc_dir_entry *NVT_proc_entry;
+#define DEVICE_NAME	"NVTSPI"
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/NVTSPI read function.
+
+return:
+	Executive outcomes. 2---succeed. -5,-14---failed.
+*******************************************************/
+static ssize_t nvt_flash_read(struct file *file, char __user *buff, size_t count, loff_t *offp)
+{
+	uint8_t *str = NULL;
+	int32_t ret = 0;
+	int32_t retries = 0;
+	int8_t spi_wr = 0;
+	uint8_t *buf;
+
+	if ((count > NVT_TRANSFER_LEN + 3) || (count < 3)) {
+		NVT_ERR("invalid transfer len!\n");
+		return -EFAULT;
+	}
+
+	/* allocate buffer for spi transfer */
+	str = (uint8_t *)kzalloc((count), GFP_KERNEL);
+	if(str == NULL) {
+		NVT_ERR("kzalloc for buf failed!\n");
+		ret = -ENOMEM;
+		goto kzalloc_failed;
+	}
+
+	buf = (uint8_t *)kzalloc((count), GFP_KERNEL | GFP_DMA);
+	if(buf == NULL) {
+		NVT_ERR("kzalloc for buf failed!\n");
+		ret = -ENOMEM;
+		kfree(str);
+		str = NULL;
+		goto kzalloc_failed;
+	}
+
+	if (copy_from_user(str, buff, count)) {
+		NVT_ERR("copy from user error\n");
+		ret = -EFAULT;
+		goto out;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	/*
+	 * stop esd check work to avoid case that 0x77 report righ after here to enable esd check again
+	 * finally lead to trigger esd recovery bootloader reset
+	 */
+	cancel_delayed_work_sync(&nvt_esd_check_work);
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	spi_wr = str[0] >> 7;
+	memcpy(buf, str+2, ((str[0] & 0x7F) << 8) | str[1]);
+
+	if (spi_wr == NVTWRITE) {	//SPI write
+		while (retries < 20) {
+			ret = CTP_SPI_WRITE(ts->client, buf, ((str[0] & 0x7F) << 8) | str[1]);
+			if (!ret)
+				break;
+			else
+				NVT_ERR("error, retries=%d, ret=%d\n", retries, ret);
+
+			retries++;
+		}
+
+		if (unlikely(retries == 20)) {
+			NVT_ERR("error, ret = %d\n", ret);
+			ret = -EIO;
+			goto out;
+		}
+	} else if (spi_wr == NVTREAD) {	//SPI read
+		while (retries < 20) {
+			ret = CTP_SPI_READ(ts->client, buf, ((str[0] & 0x7F) << 8) | str[1]);
+			if (!ret)
+				break;
+			else
+				NVT_ERR("error, retries=%d, ret=%d\n", retries, ret);
+
+			retries++;
+		}
+
+		memcpy(str+2, buf, ((str[0] & 0x7F) << 8) | str[1]);
+		// copy buff to user if spi transfer
+		if (retries < 20) {
+			if (copy_to_user(buff, str, count)) {
+				ret = -EFAULT;
+				goto out;
+			}
+		}
+
+		if (unlikely(retries == 20)) {
+			NVT_ERR("error, ret = %d\n", ret);
+			ret = -EIO;
+			goto out;
+		}
+	} else {
+		NVT_ERR("Call error, str[0]=%d\n", str[0]);
+		ret = -EFAULT;
+		goto out;
+	}
+
+out:
+	kfree(str);
+    kfree(buf);
+kzalloc_failed:
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/NVTSPI open function.
+
+return:
+	Executive outcomes. 0---succeed. -12---failed.
+*******************************************************/
+static int32_t nvt_flash_open(struct inode *inode, struct file *file)
+{
+	struct nvt_flash_data *dev;
+
+	dev = kmalloc(sizeof(struct nvt_flash_data), GFP_KERNEL);
+	if (dev == NULL) {
+		NVT_ERR("Failed to allocate memory for nvt flash data\n");
+		return -ENOMEM;
+	}
+
+	rwlock_init(&dev->lock);
+	file->private_data = dev;
+
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/NVTSPI close function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t nvt_flash_close(struct inode *inode, struct file *file)
+{
+	struct nvt_flash_data *dev = file->private_data;
+
+	if (dev)
+		kfree(dev);
+
+	return 0;
+}
+
+static const struct file_operations nvt_flash_fops = {
+	.owner = THIS_MODULE,
+	.open = nvt_flash_open,
+	.release = nvt_flash_close,
+	.read = nvt_flash_read,
+};
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/NVTSPI initial function.
+
+return:
+	Executive outcomes. 0---succeed. -12---failed.
+*******************************************************/
+static int32_t nvt_flash_proc_init(void)
+{
+	NVT_proc_entry = proc_create(DEVICE_NAME, 0444, NULL,&nvt_flash_fops);
+	if (NVT_proc_entry == NULL) {
+		NVT_ERR("Failed!\n");
+		return -ENOMEM;
+	} else {
+		NVT_LOG("Succeeded!\n");
+	}
+
+	NVT_LOG("============================================================\n");
+	NVT_LOG("Create /proc/%s\n", DEVICE_NAME);
+	NVT_LOG("============================================================\n");
+
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/NVTSPI deinitial function.
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_flash_proc_deinit(void)
+{
+	if (NVT_proc_entry != NULL) {
+		remove_proc_entry(DEVICE_NAME, NULL);
+		NVT_proc_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", DEVICE_NAME);
+	}
+}
+#endif
+
+#if WAKEUP_GESTURE
+#define GESTURE_WORD_C          12
+#define GESTURE_WORD_W          13
+#define GESTURE_WORD_V          14
+#define GESTURE_DOUBLE_CLICK    15
+#define GESTURE_WORD_Z          16
+#define GESTURE_WORD_M          17
+#define GESTURE_WORD_O          18
+#define GESTURE_WORD_e          19
+#define GESTURE_WORD_S          20
+#define GESTURE_SLIDE_UP        21
+#define GESTURE_SLIDE_DOWN      22
+#define GESTURE_SLIDE_LEFT      23
+#define GESTURE_SLIDE_RIGHT     24
+/* customized gesture id */
+#define DATA_PROTOCOL           30
+
+/* function page definition */
+#define FUNCPAGE_GESTURE         1
+
+/*******************************************************
+Description:
+	Novatek touchscreen wake up gesture key report function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_ts_wakeup_gesture_report(uint8_t gesture_id, uint8_t *data)
+{
+	uint32_t keycode = 0;
+	uint8_t func_type = data[2];
+	uint8_t func_id = data[3];
+
+	/* support fw specifal data protocol */
+	if ((gesture_id == DATA_PROTOCOL) && (func_type == FUNCPAGE_GESTURE)) {
+		gesture_id = func_id;
+	} else if (gesture_id > DATA_PROTOCOL) {
+		NVT_ERR("gesture_id %d is invalid, func_type=%d, func_id=%d\n", gesture_id, func_type, func_id);
+		return;
+	}
+
+	NVT_LOG("gesture_id = %d\n", gesture_id);
+
+	switch (gesture_id) {
+		case GESTURE_WORD_C:
+			NVT_LOG("Gesture : Word-C.\n");
+			keycode = gesture_key_array[0];
+			break;
+		case GESTURE_WORD_W:
+			NVT_LOG("Gesture : Word-W.\n");
+			keycode = gesture_key_array[1];
+			break;
+		case GESTURE_WORD_V:
+			NVT_LOG("Gesture : Word-V.\n");
+			keycode = gesture_key_array[2];
+			break;
+		case GESTURE_DOUBLE_CLICK:
+			NVT_LOG("Gesture : Double Click.\n");
+			keycode = gesture_key_array[3];
+			break;
+		case GESTURE_WORD_Z:
+			NVT_LOG("Gesture : Word-Z.\n");
+			keycode = gesture_key_array[4];
+			break;
+		case GESTURE_WORD_M:
+			NVT_LOG("Gesture : Word-M.\n");
+			keycode = gesture_key_array[5];
+			break;
+		case GESTURE_WORD_O:
+			NVT_LOG("Gesture : Word-O.\n");
+			keycode = gesture_key_array[6];
+			break;
+		case GESTURE_WORD_e:
+			NVT_LOG("Gesture : Word-e.\n");
+			keycode = gesture_key_array[7];
+			break;
+		case GESTURE_WORD_S:
+			NVT_LOG("Gesture : Word-S.\n");
+			keycode = gesture_key_array[8];
+			break;
+		case GESTURE_SLIDE_UP:
+			NVT_LOG("Gesture : Slide UP.\n");
+			keycode = gesture_key_array[9];
+			break;
+		case GESTURE_SLIDE_DOWN:
+			NVT_LOG("Gesture : Slide DOWN.\n");
+			keycode = gesture_key_array[10];
+			break;
+		case GESTURE_SLIDE_LEFT:
+			NVT_LOG("Gesture : Slide LEFT.\n");
+			keycode = gesture_key_array[11];
+			break;
+		case GESTURE_SLIDE_RIGHT:
+			NVT_LOG("Gesture : Slide RIGHT.\n");
+			keycode = gesture_key_array[12];
+			break;
+		default:
+			break;
+	}
+
+	if (keycode > 0) {
+		input_report_key(ts->input_dev, keycode, 1);
+		input_sync(ts->input_dev);
+		input_report_key(ts->input_dev, keycode, 0);
+		input_sync(ts->input_dev);
+	}
+}
+#endif
+
+/*******************************************************
+Description:
+	Novatek touchscreen parse device tree function.
+
+return:
+	n.a.
+*******************************************************/
+#ifdef CONFIG_OF
+static int32_t nvt_parse_dt(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	int32_t ret = 0;
+
+#if NVT_TOUCH_SUPPORT_HW_RST
+	ts->reset_gpio = of_get_named_gpio_flags(np, "novatek,reset-gpio", 0, &ts->reset_flags);
+	NVT_LOG("novatek,reset-gpio=%d\n", ts->reset_gpio);
+#endif
+	ts->irq_gpio = of_get_named_gpio_flags(np, "novatek,irq-gpio", 0, &ts->irq_flags);
+	NVT_LOG("novatek,irq-gpio=%d\n", ts->irq_gpio);
+
+	ret = of_property_read_u32(np, "novatek,swrst-n8-addr", &SWRST_N8_ADDR);
+	if (ret) {
+		NVT_ERR("error reading novatek,swrst-n8-addr. ret=%d\n", ret);
+		return ret;
+	} else {
+		NVT_LOG("SWRST_N8_ADDR=0x%06X\n", SWRST_N8_ADDR);
+	}
+
+	ret = of_property_read_u32(np, "novatek,spi-rd-fast-addr", &SPI_RD_FAST_ADDR);
+	if (ret) {
+		NVT_LOG("not support novatek,spi-rd-fast-addr\n");
+		SPI_RD_FAST_ADDR = 0;
+		ret = 0;
+	} else {
+		NVT_LOG("SPI_RD_FAST_ADDR=0x%06X\n", SPI_RD_FAST_ADDR);
+	}
+
+	return ret;
+}
+#else
+static int32_t nvt_parse_dt(struct device *dev)
+{
+#if NVT_TOUCH_SUPPORT_HW_RST
+	ts->reset_gpio = NVTTOUCH_RST_PIN;
+#endif
+	ts->irq_gpio = NVTTOUCH_INT_PIN;
+	return 0;
+}
+#endif
+
+/*******************************************************
+Description:
+	Novatek touchscreen config and request gpio
+
+return:
+	Executive outcomes. 0---succeed. not 0---failed.
+*******************************************************/
+static int nvt_gpio_config(struct nvt_ts_data *ts)
+{
+	int32_t ret = 0;
+
+#if NVT_TOUCH_SUPPORT_HW_RST
+	/* request RST-pin (Output/High) */
+	if (gpio_is_valid(ts->reset_gpio)) {
+		ret = gpio_request_one(ts->reset_gpio, GPIOF_OUT_INIT_LOW, "NVT-tp-rst");
+		if (ret) {
+			NVT_ERR("Failed to request NVT-tp-rst GPIO\n");
+			goto err_request_reset_gpio;
+		}
+	}
+#endif
+
+	/* request INT-pin (Input) */
+	if (gpio_is_valid(ts->irq_gpio)) {
+		ret = gpio_request_one(ts->irq_gpio, GPIOF_IN, "NVT-int");
+		if (ret) {
+			NVT_ERR("Failed to request NVT-int GPIO\n");
+			goto err_request_irq_gpio;
+		}
+	}
+
+	return ret;
+
+err_request_irq_gpio:
+#if NVT_TOUCH_SUPPORT_HW_RST
+	gpio_free(ts->reset_gpio);
+err_request_reset_gpio:
+#endif
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen deconfig gpio
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_gpio_deconfig(struct nvt_ts_data *ts)
+{
+	if (gpio_is_valid(ts->irq_gpio))
+		gpio_free(ts->irq_gpio);
+#if NVT_TOUCH_SUPPORT_HW_RST
+	if (gpio_is_valid(ts->reset_gpio))
+		gpio_free(ts->reset_gpio);
+#endif
+}
+
+#if NVT_TOUCH_ESD_PROTECT
+void nvt_esd_check_enable(uint8_t enable)
+{
+	/* update interrupt timer */
+	irq_timer = jiffies;
+	/* clear esd_retry counter, if protect function is enabled */
+	esd_retry = enable ? 0 : esd_retry;
+	/* enable/disable esd check flag */
+	esd_check = enable;
+}
+
+static uint8_t nvt_fw_recovery(uint8_t *point_data)
+{
+	uint8_t i = 0;
+	uint8_t detected = true;
+
+	/* check pattern */
+	for (i=1 ; i<7 ; i++) {
+		if (point_data[i] != 0x77) {
+			detected = false;
+			break;
+		}
+	}
+
+	return detected;
+}
+
+static void nvt_esd_check_func(struct work_struct *work)
+{
+	unsigned int timer = jiffies_to_msecs(jiffies - irq_timer);
+
+	//NVT_LOG("esd_check = %d (retry %d)\n", esd_check, esd_retry);	//DEBUG
+
+	if ((timer > NVT_TOUCH_ESD_CHECK_PERIOD) && esd_check) {
+		mutex_lock(&ts->lock);
+		NVT_ERR("do ESD recovery, timer = %d, retry = %d\n", timer, esd_retry);
+		/* do esd recovery, reload fw */
+		nvt_update_firmware(ts->boot_update_firmware_name);
+		mutex_unlock(&ts->lock);
+		/* update interrupt timer */
+		irq_timer = jiffies;
+		/* update esd_retry counter */
+		esd_retry++;
+	}
+
+	queue_delayed_work(nvt_esd_check_wq, &nvt_esd_check_work,
+			msecs_to_jiffies(NVT_TOUCH_ESD_CHECK_PERIOD));
+}
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+#if NVT_TOUCH_WDT_RECOVERY
+static uint8_t recovery_cnt = 0;
+static uint8_t nvt_wdt_fw_recovery(uint8_t *point_data)
+{
+   uint32_t recovery_cnt_max = 10;
+   uint8_t recovery_enable = false;
+   uint8_t i = 0;
+
+   recovery_cnt++;
+
+   /* check pattern */
+   for (i=1 ; i<7 ; i++) {
+       if ((point_data[i] != 0xFD) && (point_data[i] != 0xFE)) {
+           recovery_cnt = 0;
+           break;
+       }
+   }
+
+   if (recovery_cnt > recovery_cnt_max){
+       recovery_enable = true;
+       recovery_cnt = 0;
+   }
+
+   return recovery_enable;
+}
+#endif	/* #if NVT_TOUCH_WDT_RECOVERY */
+
+#if WAKEUP_GESTURE
+#define FUNCPAGE_PALM 4
+#define PACKET_PALM_ON 3
+#define PACKET_PALM_OFF 4
+int32_t nvt_check_palm(uint8_t input_id, uint8_t *data)
+{
+	int32_t ret = 0;
+	uint8_t func_type = data[2];
+	uint8_t palm_state = data[3];
+	uint8_t keycode = 0;
+
+		if ((input_id == DATA_PROTOCOL) && (func_type == FUNCPAGE_PALM)) {
+			ret = palm_state;
+			if (palm_state == PACKET_PALM_ON) {
+				NVT_LOG("get packet palm on event.\n");
+				keycode = gesture_key_array[13];
+			} else if (palm_state == PACKET_PALM_OFF) {
+				NVT_LOG("get packet palm off event.\n");
+			} else {
+				NVT_ERR("invalid palm state %d!\n", palm_state);
+				ret = -1;
+			}
+		} else {
+			ret = 0;
+		}
+		if (keycode > 0) {
+			input_report_key(ts->input_dev, keycode, 1);
+			input_sync(ts->input_dev);
+			input_report_key(ts->input_dev, keycode, 0);
+			input_sync(ts->input_dev);
+		}
+	return ret;
+}
+#endif
+
+#define POINT_DATA_LEN 65
+/*******************************************************
+Description:
+	Novatek touchscreen work function.
+
+return:
+	n.a.
+*******************************************************/
+static irqreturn_t nvt_ts_work_func(int irq, void *data)
+{
+	int32_t ret = -1;
+	uint8_t point_data[POINT_DATA_LEN + 1 + DUMMY_BYTES] = {0};
+	uint32_t position = 0;
+	uint32_t input_x = 0;
+	uint32_t input_y = 0;
+	uint32_t input_w = 0;
+	uint32_t input_p = 0;
+	uint8_t input_id = 0;
+#if MT_PROTOCOL_B
+	uint8_t press_id[TOUCH_MAX_FINGER_NUM] = {0};
+#endif /* MT_PROTOCOL_B */
+	int32_t i = 0;
+	int32_t finger_cnt = 0;
+
+#if WAKEUP_GESTURE
+#ifdef CONFIG_PM
+	if (ts->dev_pm_suspend && ts->is_gesture_mode) {
+		ret = wait_for_completion_timeout(&ts->dev_pm_suspend_completion, msecs_to_jiffies(700));
+		if (!ret) {
+			NVT_ERR("system(spi bus) can't finished resuming procedure, skip it");
+			return IRQ_HANDLED;
+		}
+	}
+#endif
+#endif
+
+	mutex_lock(&ts->lock);
+
+	ret = CTP_SPI_READ(ts->client, point_data, POINT_DATA_LEN + 1);
+	if (ret < 0) {
+		NVT_ERR("CTP_SPI_READ failed.(%d)\n", ret);
+		goto XFER_ERROR;
+	}
+
+/*
+	//--- dump SPI buf ---
+	for (i = 0; i < 10; i++) {
+		printk("%02X %02X %02X %02X %02X %02X  ",
+			point_data[1+i*6], point_data[2+i*6], point_data[3+i*6], point_data[4+i*6], point_data[5+i*6], point_data[6+i*6]);
+	}
+	printk("\n");
+*/
+
+#if NVT_TOUCH_WDT_RECOVERY
+   /* ESD protect by WDT */
+   if (nvt_wdt_fw_recovery(point_data)) {
+       NVT_ERR("Recover for fw reset, %02X\n", point_data[1]);
+       nvt_update_firmware(ts->boot_update_firmware_name);
+       goto XFER_ERROR;
+   }
+#endif /* #if NVT_TOUCH_WDT_RECOVERY */
+
+#if NVT_TOUCH_ESD_PROTECT
+	/* ESD protect by FW handshake */
+	if (nvt_fw_recovery(point_data)) {
+		nvt_esd_check_enable(true);
+		goto XFER_ERROR;
+	}
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	input_id = (uint8_t)(point_data[1] >> 3);
+
+#if WAKEUP_GESTURE
+	if (nvt_check_palm(input_id, point_data)) {
+		goto XFER_ERROR;
+	}
+
+	if (bTouchIsAwake == 0) {
+		//input_id = (uint8_t)(point_data[1] >> 3);
+		nvt_ts_wakeup_gesture_report(input_id, point_data);
+		mutex_unlock(&ts->lock);
+		return IRQ_HANDLED;
+	}
+#endif
+	finger_cnt = 0;
+
+	for (i = 0; i < ts->max_touch_num; i++) {
+		position = 1 + 6 * i;
+		input_id = (uint8_t)(point_data[position + 0] >> 3);
+		if ((input_id == 0) || (input_id > ts->max_touch_num))
+			continue;
+
+		if (((point_data[position] & 0x07) == 0x01) || ((point_data[position] & 0x07) == 0x02)) {	//finger down (enter & moving)
+#if NVT_TOUCH_ESD_PROTECT
+			/* update interrupt timer */
+			irq_timer = jiffies;
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+			input_x = (uint32_t)(point_data[position + 1] << 4) + (uint32_t) (point_data[position + 3] >> 4);
+			input_y = (uint32_t)(point_data[position + 2] << 4) + (uint32_t) (point_data[position + 3] & 0x0F);
+			if ((input_x < 0) || (input_y < 0))
+				continue;
+			if ((input_x > ts->abs_x_max) || (input_y > ts->abs_y_max))
+				continue;
+			input_w = (uint32_t)(point_data[position + 4]);
+			if (input_w == 0)
+				input_w = 1;
+			if (i < 2) {
+				input_p = (uint32_t)(point_data[position + 5]) + (uint32_t)(point_data[i + 63] << 8);
+				if (input_p > TOUCH_FORCE_NUM)
+					input_p = TOUCH_FORCE_NUM;
+			} else {
+				input_p = (uint32_t)(point_data[position + 5]);
+			}
+			if (input_p == 0)
+				input_p = 1;
+
+#if MT_PROTOCOL_B
+			press_id[input_id - 1] = 1;
+			input_mt_slot(ts->input_dev, input_id - 1);
+			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
+#else /* MT_PROTOCOL_B */
+			input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, input_id - 1);
+			input_report_key(ts->input_dev, BTN_TOUCH, 1);
+#endif /* MT_PROTOCOL_B */
+
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_X, input_x);
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, input_y);
+			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, input_w);
+			input_report_abs(ts->input_dev, ABS_MT_PRESSURE, input_p);
+
+#if MT_PROTOCOL_B
+#else /* MT_PROTOCOL_B */
+			input_mt_sync(ts->input_dev);
+#endif /* MT_PROTOCOL_B */
+
+			finger_cnt++;
+		}
+	}
+
+#if MT_PROTOCOL_B
+	for (i = 0; i < ts->max_touch_num; i++) {
+		if (press_id[i] != 1) {
+			input_mt_slot(ts->input_dev, i);
+			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+			input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 0);
+			input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+		}
+	}
+
+	input_report_key(ts->input_dev, BTN_TOUCH, (finger_cnt > 0));
+#else /* MT_PROTOCOL_B */
+	if (finger_cnt == 0) {
+		input_report_key(ts->input_dev, BTN_TOUCH, 0);
+		input_mt_sync(ts->input_dev);
+	}
+#endif /* MT_PROTOCOL_B */
+
+#if TOUCH_KEY_NUM > 0
+	if (point_data[61] == 0xF8) {
+#if NVT_TOUCH_ESD_PROTECT
+		/* update interrupt timer */
+		irq_timer = jiffies;
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+		for (i = 0; i < ts->max_button_num; i++) {
+			input_report_key(ts->input_dev, touch_key_array[i], ((point_data[62] >> i) & 0x01));
+		}
+	} else {
+		for (i = 0; i < ts->max_button_num; i++) {
+			input_report_key(ts->input_dev, touch_key_array[i], 0);
+		}
+	}
+#endif
+
+	input_sync(ts->input_dev);
+
+XFER_ERROR:
+
+	mutex_unlock(&ts->lock);
+
+	return IRQ_HANDLED;
+}
+
+
+/*******************************************************
+Description:
+	Novatek touchscreen check chip version trim function.
+
+return:
+	Executive outcomes. 0---NVT IC. -1---not NVT IC.
+*******************************************************/
+static int8_t nvt_ts_check_chip_ver_trim(void)
+{
+	uint8_t buf[8] = {0};
+	int32_t retry = 0;
+	int32_t list = 0;
+	int32_t i = 0;
+	int32_t found_nvt_chip = 0;
+	int32_t ret = -1;
+
+	//---Check for 5 times---
+	for (retry = 5; retry > 0; retry--) {
+
+		nvt_bootloader_reset();
+
+		//---set xdata index to 0x1F64E---
+		nvt_set_page(0x1F64E);
+
+		buf[0] = 0x4E;
+		buf[1] = 0x00;
+		buf[2] = 0x00;
+		buf[3] = 0x00;
+		buf[4] = 0x00;
+		buf[5] = 0x00;
+		buf[6] = 0x00;
+		CTP_SPI_READ(ts->client, buf, 7);
+		NVT_LOG("buf[1]=0x%02X, buf[2]=0x%02X, buf[3]=0x%02X, buf[4]=0x%02X, buf[5]=0x%02X, buf[6]=0x%02X\n",
+			buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);
+
+		// compare read chip id on supported list
+		for (list = 0; list < (sizeof(trim_id_table) / sizeof(struct nvt_ts_trim_id_table)); list++) {
+			found_nvt_chip = 0;
+
+			// compare each byte
+			for (i = 0; i < NVT_ID_BYTE_MAX; i++) {
+				if (trim_id_table[list].mask[i]) {
+					if (buf[i + 1] != trim_id_table[list].id[i])
+						break;
+				}
+			}
+
+			if (i == NVT_ID_BYTE_MAX) {
+				found_nvt_chip = 1;
+			}
+
+			if (found_nvt_chip) {
+				NVT_LOG("This is NVT touch IC\n");
+				ts->mmap = trim_id_table[list].mmap;
+				ts->carrier_system = trim_id_table[list].hwinfo->carrier_system;
+				ts->hw_crc = trim_id_table[list].hwinfo->hw_crc;
+				ret = 0;
+				goto out;
+			} else {
+				ts->mmap = NULL;
+				ret = -1;
+			}
+		}
+
+		msleep(10);
+	}
+
+out:
+	return ret;
+}
+
+#if WAKEUP_GESTURE
+/*******************************************************
+Description:
+	Novatek touchscreen driver get regulator function.
+
+return:
+	Executive outcomes. 0---succeed. negative---failed
+*******************************************************/
+static int32_t nvt_ts_get_regulator(bool get)
+{
+	int32_t ret = 0;
+
+	NVT_LOG("get/put regulator : %d \n", get);
+
+	if (!get) {
+		goto put_regulator;
+	}
+
+	ts->pwr_vdd = regulator_get(&ts->client->dev, "touch_vddio");
+	if (IS_ERR_OR_NULL(ts->pwr_vdd)) {
+		ret = PTR_ERR(ts->pwr_vdd);
+		NVT_ERR("Failed to get vdd regulator");
+		goto put_regulator;
+	} else {
+        if (regulator_count_voltages(ts->pwr_vdd) > 0) {
+            ret = regulator_set_voltage(ts->pwr_vdd,
+                                        1800000,
+                                        1800000);
+            if (ret) {
+                NVT_ERR("vddio regulator set_vtg failed,ret=%d", ret);
+                goto put_regulator;
+            }
+        }
+	}
+
+	ts->pwr_lab = regulator_get(&ts->client->dev, "touch_lab");
+	if (IS_ERR_OR_NULL(ts->pwr_lab)) {
+		ret = PTR_ERR(ts->pwr_lab);
+		NVT_ERR("Failed to get lab regulator");
+		goto put_regulator;
+	}
+
+	ts->pwr_ibb = regulator_get(&ts->client->dev, "touch_ibb");
+	if (IS_ERR_OR_NULL(ts->pwr_ibb)) {
+		ret = PTR_ERR(ts->pwr_ibb);
+		NVT_ERR("Failed to get ibb regulator");
+		goto put_regulator;
+	}
+
+	return 0;
+
+put_regulator:
+	if (ts->pwr_vdd) {
+		regulator_put(ts->pwr_vdd);
+		ts->pwr_vdd = NULL;
+	}
+
+	if (ts->pwr_lab) {
+		regulator_put(ts->pwr_lab);
+		ts->pwr_lab = NULL;
+	}
+
+	if (ts->pwr_ibb) {
+		regulator_put(ts->pwr_ibb);
+		ts->pwr_ibb = NULL;
+	}
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen driver enable regulator function.
+
+return:
+	Executive outcomes. 0---succeed. negative---failed
+*******************************************************/
+static int32_t nvt_ts_enable_regulator(bool en)
+{
+	static bool status = false;
+	int32_t ret = 0;
+
+	if (status == en) {
+		NVT_LOG("Already %s touch regulator", en?"enable":"disable");
+		return 0;
+	}
+	status = en;
+	NVT_LOG("%s touch regulator", en?"enable":"disable");
+
+	if (!en) {
+		goto disable_ibb_regulator;
+	}
+
+	if (ts->pwr_vdd) {
+		ret = regulator_enable(ts->pwr_vdd);
+		if (ret < 0) {
+			NVT_ERR("Failed to enable vdd regulator");
+			goto exit;
+		}
+	}
+
+	if (ts->pwr_lab) {
+		ret = regulator_enable(ts->pwr_lab);
+		if (ret < 0) {
+			NVT_ERR("Failed to enable lab regulator");
+			goto disable_vdd_regulator;
+		}
+	}
+
+	if (ts->pwr_ibb) {
+		ret = regulator_enable(ts->pwr_ibb);
+		if (ret < 0) {
+			NVT_ERR("Failed to enable ibb regulator");
+			goto disable_lab_regulator;
+		}
+	}
+
+	return 0;
+
+disable_ibb_regulator:
+	if (ts->pwr_ibb)
+		regulator_disable(ts->pwr_ibb);
+
+disable_lab_regulator:
+	if (ts->pwr_lab)
+		regulator_disable(ts->pwr_lab);
+
+disable_vdd_regulator:
+	if (ts->pwr_vdd)
+		regulator_disable(ts->pwr_vdd);
+
+exit:
+	return ret;
+}
+#endif
+
+/*******************************************************
+Description:
+	Novatek touchscreen driver probe function.
+
+return:
+	Executive outcomes. 0---succeed. negative---failed
+*******************************************************/
+static int32_t nvt_ts_probe(struct spi_device *client)
+{
+	int32_t ret = 0;
+#if ((TOUCH_KEY_NUM > 0) || WAKEUP_GESTURE)
+	int32_t retry = 0;
+#endif
+
+	NVT_LOG("start\n");
+	pr_info("%s %d", __func__, __LINE__);
+#if WAKEUP_GESTURE
+	spi_geni_master_dev = NULL;
+#endif
+	ts = kzalloc(sizeof(struct nvt_ts_data), GFP_KERNEL);
+	if (IS_ERR_OR_NULL(ts)) {
+		NVT_ERR("failed to allocated memory for nvt ts data\n");
+		return -ENOMEM;
+	}
+
+	ts->xbuf = (uint8_t *)kzalloc((NVT_TRANSFER_LEN+1), GFP_KERNEL);
+	if(IS_ERR_OR_NULL(ts->xbuf)) {
+		NVT_ERR("kzalloc for xbuf failed!\n");
+		if (ts) {
+			kfree(ts);
+			ts = NULL;
+		}
+		return -ENOMEM;
+	}
+
+#ifdef CHECK_TOUCH_VENDOR
+	ts->touch_vendor_id = touch_vendor_id;
+	switch(ts->touch_vendor_id) {
+	case TP_VENDOR_TIANMA:
+		memcpy(ts->boot_update_firmware_name, BOOT_UPDATE_TIANMA_FIRMWARE_NAME, sizeof(BOOT_UPDATE_TIANMA_FIRMWARE_NAME));
+		memcpy(ts->mp_update_firmware_name, MP_UPDATE_TIANMA_FIRMWARE_NAME, sizeof(MP_UPDATE_TIANMA_FIRMWARE_NAME));
+		break;
+	default:
+		goto err_vendor_check;
+	}
+#else
+	memcpy(ts->boot_update_firmware_name, BOOT_UPDATE_FIRMWARE_NAME, sizeof(BOOT_UPDATE_FIRMWARE_NAME));
+	memcpy(ts->mp_update_firmware_name, MP_UPDATE_FIRMWARE_NAME, sizeof(MP_UPDATE_FIRMWARE_NAME));
+#endif
+
+	ts->client = client;
+	spi_set_drvdata(client, ts);
+
+	//---prepare for spi parameter---
+	if (ts->client->master->flags & SPI_MASTER_HALF_DUPLEX) {
+		NVT_ERR("Full duplex not supported by master\n");
+		ret = -EIO;
+		goto err_ckeck_full_duplex;
+	}
+	ts->client->bits_per_word = 8;
+	ts->client->mode = SPI_MODE_0;
+
+	ret = spi_setup(ts->client);
+	if (ret < 0) {
+		NVT_ERR("Failed to perform SPI setup\n");
+		goto err_spi_setup;
+	}
+
+#ifdef CONFIG_MTK_SPI
+    /* old usage of MTK spi API */
+    memcpy(&ts->spi_ctrl, &spi_ctrdata, sizeof(struct mt_chip_conf));
+    ts->client->controller_data = (void *)&ts->spi_ctrl;
+#endif
+
+#ifdef CONFIG_SPI_MT65XX
+    /* new usage of MTK spi API */
+    memcpy(&ts->spi_ctrl, &spi_ctrdata, sizeof(struct mtk_chip_config));
+    ts->client->controller_data = (void *)&ts->spi_ctrl;
+#endif
+
+	NVT_LOG("mode=%d, max_speed_hz=%d\n", ts->client->mode, ts->client->max_speed_hz);
+
+	//---parse dts---
+	ret = nvt_parse_dt(&client->dev);
+	if (ret) {
+		NVT_ERR("parse dt error\n");
+		goto err_spi_setup;
+	}
+
+	//---config regulator---
+#if WAKEUP_GESTURE
+	ret = nvt_ts_get_regulator(true);
+	if (ret < 0) {
+		NVT_ERR("Failed to get register\n");
+		goto err_get_regulator;
+	}
+
+	ret = nvt_ts_enable_regulator(false);//default disable regulator
+	if (ret < 0) {
+		NVT_ERR("Failed to enable regulator\n");
+		goto err_enable_regulator;
+	}
+#endif
+
+	//---request and config GPIOs---
+	ret = nvt_gpio_config(ts);
+	if (ret) {
+		NVT_ERR("gpio config error!\n");
+		goto err_gpio_config_failed;
+	}
+
+	mutex_init(&ts->lock);
+	mutex_init(&ts->xbuf_lock);
+	mutex_init(&ts->reg_lock);
+
+	//---eng reset before TP_RESX high
+	nvt_eng_reset();
+
+#if NVT_TOUCH_SUPPORT_HW_RST
+	gpio_set_value(ts->reset_gpio, 1);
+#endif
+
+	// need 10ms delay after POR(power on reset)
+	msleep(10);
+
+	//---check chip version trim---
+	ret = nvt_ts_check_chip_ver_trim();
+	if (ret) {
+		NVT_ERR("chip is not identified\n");
+		ret = -EINVAL;
+		goto err_chipvertrim_failed;
+	}
+
+	ts->abs_x_max = TOUCH_DEFAULT_MAX_WIDTH;
+	ts->abs_y_max = TOUCH_DEFAULT_MAX_HEIGHT;
+
+	//---allocate input device---
+	ts->input_dev = input_allocate_device();
+	if (ts->input_dev == NULL) {
+		NVT_ERR("allocate input device failed\n");
+		ret = -ENOMEM;
+		goto err_input_dev_alloc_failed;
+	}
+
+	ts->max_touch_num = TOUCH_MAX_FINGER_NUM;
+
+#if TOUCH_KEY_NUM > 0
+	ts->max_button_num = TOUCH_KEY_NUM;
+#endif
+
+	ts->int_trigger_type = INT_TRIGGER_TYPE;
+
+
+	//---set input device info.---
+	ts->input_dev->evbit[0] = BIT_MASK(EV_SYN) | BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS) ;
+	ts->input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	ts->input_dev->propbit[0] = BIT(INPUT_PROP_DIRECT);
+
+#if MT_PROTOCOL_B
+	input_mt_init_slots(ts->input_dev, ts->max_touch_num, 0);
+#endif
+
+	input_set_abs_params(ts->input_dev, ABS_MT_PRESSURE, 0, TOUCH_FORCE_NUM, 0, 0);    //pressure = TOUCH_FORCE_NUM
+
+#if TOUCH_MAX_FINGER_NUM > 1
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);    //area = 255
+
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0, ts->abs_x_max - 1, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0, ts->abs_y_max - 1, 0, 0);
+#if MT_PROTOCOL_B
+	// no need to set ABS_MT_TRACKING_ID, input_mt_init_slots() already set it
+#else
+	input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID, 0, ts->max_touch_num, 0, 0);
+#endif //MT_PROTOCOL_B
+#endif //TOUCH_MAX_FINGER_NUM > 1
+
+#if TOUCH_KEY_NUM > 0
+	for (retry = 0; retry < ts->max_button_num; retry++) {
+		input_set_capability(ts->input_dev, EV_KEY, touch_key_array[retry]);
+	}
+#endif
+
+#if WAKEUP_GESTURE
+	ts->input_dev->event =nvt_gesture_switch;
+	for (retry = 0; retry < (sizeof(gesture_key_array) / sizeof(gesture_key_array[0])); retry++) {
+		input_set_capability(ts->input_dev, EV_KEY, gesture_key_array[retry]);
+	}
+#endif
+
+#ifdef CONFIG_TOUCHSCREEN_COMMON
+	ret = tp_common_set_double_tap_ops(&double_tap_ops);
+	if (ret < 0) {
+		NVT_ERR("%s: Failed to create double_tap node err=%d\n",
+                	__func__, ret);
+    }
+#endif
+	sprintf(ts->phys, "input/ts");
+	ts->input_dev->name = NVT_TS_NAME;
+	ts->input_dev->phys = ts->phys;
+	ts->input_dev->id.bustype = BUS_SPI;
+
+	//---register input device---
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		NVT_ERR("register input device (%s) failed. ret=%d\n", ts->input_dev->name, ret);
+		goto err_input_register_device_failed;
+	}
+
+	//---set int-pin & request irq---
+	client->irq = gpio_to_irq(ts->irq_gpio);
+	if (client->irq) {
+		NVT_LOG("int_trigger_type=%d\n", ts->int_trigger_type);
+		ts->irq_enabled = true;
+		ret = request_threaded_irq(client->irq, NULL, nvt_ts_work_func,
+				ts->int_trigger_type | IRQF_ONESHOT, NVT_SPI_NAME, ts);
+		if (ret != 0) {
+			NVT_ERR("request irq failed. ret=%d\n", ret);
+			goto err_int_request_failed;
+		} else {
+			nvt_irq_enable(false);
+			NVT_LOG("request irq %d succeed\n", client->irq);
+		}
+	}
+
+#if WAKEUP_GESTURE
+	device_init_wakeup(&ts->input_dev->dev, 1);
+#endif
+
+#if BOOT_UPDATE_FIRMWARE
+	nvt_fwu_wq = alloc_workqueue("nvt_fwu_wq", WQ_UNBOUND | WQ_MEM_RECLAIM, 1);
+	if (!nvt_fwu_wq) {
+		NVT_ERR("nvt_fwu_wq create workqueue failed\n");
+		ret = -ENOMEM;
+		goto err_create_nvt_fwu_wq_failed;
+	}
+	INIT_DELAYED_WORK(&ts->nvt_fwu_work, Boot_Update_Firmware);
+	// please make sure boot update start after display reset(RESX) sequence
+	queue_delayed_work(nvt_fwu_wq, &ts->nvt_fwu_work, msecs_to_jiffies(5000));
+#endif
+
+	NVT_LOG("NVT_TOUCH_ESD_PROTECT is %d\n", NVT_TOUCH_ESD_PROTECT);
+#if NVT_TOUCH_ESD_PROTECT
+	INIT_DELAYED_WORK(&nvt_esd_check_work, nvt_esd_check_func);
+	nvt_esd_check_wq = alloc_workqueue("nvt_esd_check_wq", WQ_MEM_RECLAIM, 1);
+	if (!nvt_esd_check_wq) {
+		NVT_ERR("nvt_esd_check_wq create workqueue failed\n");
+		ret = -ENOMEM;
+		goto err_create_nvt_esd_check_wq_failed;
+	}
+	queue_delayed_work(nvt_esd_check_wq, &nvt_esd_check_work,
+			msecs_to_jiffies(NVT_TOUCH_ESD_CHECK_PERIOD));
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	//---set device node---
+#if NVT_TOUCH_PROC
+	ret = nvt_flash_proc_init();
+	if (ret != 0) {
+		NVT_ERR("nvt flash proc init failed. ret=%d\n", ret);
+		goto err_flash_proc_init_failed;
+	}
+#endif
+
+#if NVT_TOUCH_EXT_PROC
+	ret = nvt_extra_proc_init();
+	if (ret != 0) {
+		NVT_ERR("nvt extra proc init failed. ret=%d\n", ret);
+		goto err_extra_proc_init_failed;
+	}
+#endif
+
+#if defined(CONFIG_FB)
+	ts->workqueue = create_singlethread_workqueue("nvt_ts_workqueue");
+	if (!ts->workqueue) {
+		NVT_ERR("create nvt_ts_workqueue fail");
+		ret = -ENOMEM;
+		goto err_create_nvt_ts_workqueue_failed;
+	}
+	INIT_WORK(&ts->resume_work, nvt_ts_resume_work);
+
+#ifdef CONFIG_DRM_MSM
+	ts->drm_notif.notifier_call = nvt_drm_notifier_callback;
+	ret = msm_drm_register_client(&ts->drm_notif);
+	if(ret) {
+		NVT_ERR("register drm_notifier failed. ret=%d\n", ret);
+		goto err_register_drm_notif_failed;
+	}
+#else
+	ts->fb_notif.notifier_call = nvt_fb_notifier_callback;
+	ret = fb_register_client(&ts->fb_notif);
+	if(ret) {
+		NVT_ERR("register fb_notifier failed. ret=%d\n", ret);
+		goto err_register_fb_notif_failed;
+	}
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ts->early_suspend.suspend = nvt_ts_early_suspend;
+	ts->early_suspend.resume = nvt_ts_late_resume;
+	ret = register_early_suspend(&ts->early_suspend);
+	if(ret) {
+		NVT_ERR("register early suspend failed. ret=%d\n", ret);
+		goto err_register_early_suspend_failed;
+	}
+#endif
+
+	/*function description*/
+	if (ts->nvt_tp_class == NULL) {
+		if (ts->nvt_tp_class) {
+			ts->nvt_touch_dev = device_create(ts->nvt_tp_class, NULL, 0x38, ts, "tp_dev");
+			if (IS_ERR(ts->nvt_touch_dev)) {
+				NVT_ERR("Failed to create device !\n");
+				goto err_class_create;
+			}
+			dev_set_drvdata(ts->nvt_touch_dev, ts);
+		}
+	}
+
+	bTouchIsAwake = 1;
+	NVT_LOG("end\n");
+
+	nvt_irq_enable(true);
+
+#ifdef CONFIG_PM
+	ts->dev_pm_suspend = false;
+	init_completion(&ts->dev_pm_suspend_completion);
+#endif
+
+	pm_runtime_enable(&ts->client->dev);
+
+#if NVT_USB_PLUGIN
+	g_touchscreen_usb_pulgin.event_callback = nvt_ts_usb_event_callback;
+#endif
+#if WAKEUP_GESTURE
+	//spi bus pm_runtime_get
+	spi_geni_master_dev = lct_get_spi_geni_master_dev(ts->client->master);
+	if (spi_geni_master_dev) {
+		if (pm_runtime_get(spi_geni_master_dev))
+			NVT_ERR("pm_runtime_get fail!\n");
+	}
+#endif
+	return 0;
+
+err_class_create:
+	class_destroy(ts->nvt_tp_class);
+	ts->nvt_tp_class = NULL;
+
+#if defined(CONFIG_FB)
+err_create_nvt_ts_workqueue_failed:
+	if (ts->workqueue)
+		destroy_workqueue(ts->workqueue);
+#ifdef _MSM_DRM_NOTIFY_H_
+	if (msm_drm_unregister_client(&ts->drm_notif))
+		NVT_ERR("Error occurred while unregistering drm_notifier.\n");
+err_register_drm_notif_failed:
+#else
+	if (fb_unregister_client(&ts->fb_notif))
+		NVT_ERR("Error occurred while unregistering fb_notifier.\n");
+err_register_fb_notif_failed:
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	unregister_early_suspend(&ts->early_suspend);
+err_register_early_suspend_failed:
+#endif
+#if NVT_TOUCH_EXT_PROC
+nvt_extra_proc_deinit();
+err_extra_proc_init_failed:
+#endif
+#if NVT_TOUCH_PROC
+nvt_flash_proc_deinit();
+err_flash_proc_init_failed:
+#endif
+#if NVT_TOUCH_ESD_PROTECT
+	if (nvt_esd_check_wq) {
+		cancel_delayed_work_sync(&nvt_esd_check_work);
+		destroy_workqueue(nvt_esd_check_wq);
+		nvt_esd_check_wq = NULL;
+	}
+err_create_nvt_esd_check_wq_failed:
+#endif
+#if BOOT_UPDATE_FIRMWARE
+	if (nvt_fwu_wq) {
+		cancel_delayed_work_sync(&ts->nvt_fwu_work);
+		destroy_workqueue(nvt_fwu_wq);
+		nvt_fwu_wq = NULL;
+	}
+err_create_nvt_fwu_wq_failed:
+#endif
+#if WAKEUP_GESTURE
+	device_init_wakeup(&ts->input_dev->dev, 0);
+#endif
+	free_irq(client->irq, ts);
+err_int_request_failed:
+	input_unregister_device(ts->input_dev);
+	ts->input_dev = NULL;
+err_input_register_device_failed:
+	if (ts->input_dev) {
+		input_free_device(ts->input_dev);
+		ts->input_dev = NULL;
+	}
+err_input_dev_alloc_failed:
+err_chipvertrim_failed:
+	mutex_destroy(&ts->xbuf_lock);
+	mutex_destroy(&ts->lock);
+	nvt_gpio_deconfig(ts);
+err_gpio_config_failed:
+#if WAKEUP_GESTURE
+	nvt_ts_enable_regulator(false);
+err_enable_regulator:
+	nvt_ts_get_regulator(false);
+err_get_regulator:
+#endif
+err_spi_setup:
+err_ckeck_full_duplex:
+	spi_set_drvdata(client, NULL);
+#ifdef CHECK_TOUCH_VENDOR
+err_vendor_check:
+#endif
+	if (ts->xbuf) {
+		kfree(ts->xbuf);
+		ts->xbuf = NULL;
+	}
+	if (ts) {
+		kfree(ts);
+		ts = NULL;
+	}
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen driver release function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static void nvt_ts_remove(struct spi_device *client)
+{
+	NVT_LOG("Removing driver...\n");
+
+#if defined(CONFIG_FB)
+	if (ts->workqueue)
+		destroy_workqueue(ts->workqueue);
+#ifdef _MSM_DRM_NOTIFY_H_
+	if (msm_drm_unregister_client(&ts->drm_notif))
+		NVT_ERR("Error occurred while unregistering drm_notifier.\n");
+#else
+	if (fb_unregister_client(&ts->fb_notif))
+		NVT_ERR("Error occurred while unregistering fb_notifier.\n");
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	unregister_early_suspend(&ts->early_suspend);
+#endif
+
+#if NVT_TOUCH_EXT_PROC
+	nvt_extra_proc_deinit();
+#endif
+#if NVT_TOUCH_PROC
+	nvt_flash_proc_deinit();
+#endif
+
+#if NVT_TOUCH_ESD_PROTECT
+	if (nvt_esd_check_wq) {
+		cancel_delayed_work_sync(&nvt_esd_check_work);
+		nvt_esd_check_enable(false);
+		destroy_workqueue(nvt_esd_check_wq);
+		nvt_esd_check_wq = NULL;
+	}
+#endif
+
+#if BOOT_UPDATE_FIRMWARE
+	if (nvt_fwu_wq) {
+		cancel_delayed_work_sync(&ts->nvt_fwu_work);
+		destroy_workqueue(nvt_fwu_wq);
+		nvt_fwu_wq = NULL;
+	}
+#endif
+
+#if WAKEUP_GESTURE
+	device_init_wakeup(&ts->input_dev->dev, 0);
+#endif
+
+	nvt_irq_enable(false);
+	free_irq(client->irq, ts);
+
+	mutex_destroy(&ts->xbuf_lock);
+	mutex_destroy(&ts->lock);
+
+#if WAKEUP_GESTURE
+	nvt_ts_enable_regulator(false);
+	nvt_ts_get_regulator(false);
+#endif
+
+	nvt_gpio_deconfig(ts);
+
+	if (ts->input_dev) {
+		input_unregister_device(ts->input_dev);
+		ts->input_dev = NULL;
+	}
+
+	spi_set_drvdata(client, NULL);
+
+	if (ts->xbuf) {
+		kfree(ts->xbuf);
+		ts->xbuf = NULL;
+	}
+
+	if (ts) {
+		kfree(ts);
+		ts = NULL;
+	}
+
+}
+
+static void nvt_ts_shutdown(struct spi_device *client)
+{
+	NVT_LOG("Shutdown driver...\n");
+
+	nvt_irq_enable(false);
+
+#if defined(CONFIG_FB)
+	if (ts->workqueue)
+		destroy_workqueue(ts->workqueue);
+#ifdef _MSM_DRM_NOTIFY_H_
+	if (msm_drm_unregister_client(&ts->drm_notif))
+		NVT_ERR("Error occurred while unregistering drm_notifier.\n");
+#else
+	if (fb_unregister_client(&ts->fb_notif))
+		NVT_ERR("Error occurred while unregistering fb_notifier.\n");
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	unregister_early_suspend(&ts->early_suspend);
+#endif
+
+#if NVT_TOUCH_EXT_PROC
+	nvt_extra_proc_deinit();
+#endif
+#if NVT_TOUCH_PROC
+	nvt_flash_proc_deinit();
+#endif
+
+#if NVT_TOUCH_ESD_PROTECT
+	if (nvt_esd_check_wq) {
+		cancel_delayed_work_sync(&nvt_esd_check_work);
+		nvt_esd_check_enable(false);
+		destroy_workqueue(nvt_esd_check_wq);
+		nvt_esd_check_wq = NULL;
+	}
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+#if BOOT_UPDATE_FIRMWARE
+	if (nvt_fwu_wq) {
+		cancel_delayed_work_sync(&ts->nvt_fwu_work);
+		destroy_workqueue(nvt_fwu_wq);
+		nvt_fwu_wq = NULL;
+	}
+#endif
+
+#if WAKEUP_GESTURE
+	device_init_wakeup(&ts->input_dev->dev, 0);
+#endif
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen driver suspend function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t nvt_ts_suspend(struct device *dev)
+{
+	uint8_t buf[4] = {0};
+#if MT_PROTOCOL_B
+	uint32_t i = 0;
+#endif
+
+	if (!bTouchIsAwake) {
+		NVT_LOG("Touch is already suspend\n");
+		return 0;
+	}
+
+#if WAKEUP_GESTURE
+	if (!ts->is_gesture_mode) {
+		nvt_irq_enable(false);
+		//spi bus pm_runtime_get
+		if (spi_geni_master_dev) {
+			if (pm_runtime_put(spi_geni_master_dev))
+				NVT_ERR("pm_runtime_put fail!\n");
+		}
+	}
+#else
+	nvt_irq_enable(false);
+#endif
+
+#if NVT_TOUCH_ESD_PROTECT
+	NVT_LOG("cancel delayed work sync\n");
+	cancel_delayed_work_sync(&nvt_esd_check_work);
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	mutex_lock(&ts->lock);
+
+	NVT_LOG("start\n");
+
+	bTouchIsAwake = 0;
+
+#if WAKEUP_GESTURE
+	if (ts->is_gesture_mode) {
+		//---write command to enter "wakeup gesture mode"---
+		buf[0] = EVENT_MAP_HOST_CMD;
+		buf[1] = 0x13;
+		CTP_SPI_WRITE(ts->client, buf, 2);
+		enable_irq_wake(ts->client->irq);
+		NVT_LOG("Enabled touch wakeup gesture\n");
+	} else {
+		//---write command to enter "deep sleep mode"---
+		buf[0] = EVENT_MAP_HOST_CMD;
+		buf[1] = 0x11;
+		CTP_SPI_WRITE(ts->client, buf, 2);
+	}
+#else // WAKEUP_GESTURE
+	//---write command to enter "deep sleep mode"---
+	buf[0] = EVENT_MAP_HOST_CMD;
+	buf[1] = 0x11;
+	CTP_SPI_WRITE(ts->client, buf, 2);
+#endif // WAKEUP_GESTURE
+
+	mutex_unlock(&ts->lock);
+
+	/* release all touches */
+#if MT_PROTOCOL_B
+	for (i = 0; i < ts->max_touch_num; i++) {
+		input_mt_slot(ts->input_dev, i);
+		input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+		input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 0);
+		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
+	}
+#endif
+	input_report_key(ts->input_dev, BTN_TOUCH, 0);
+#if !MT_PROTOCOL_B
+	input_mt_sync(ts->input_dev);
+#endif
+	input_sync(ts->input_dev);
+
+	msleep(50);
+
+	NVT_LOG("end\n");
+
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen driver resume function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t nvt_ts_resume(struct device *dev)
+{
+	if (bTouchIsAwake) {
+		NVT_LOG("Touch is already resume\n");
+		return 0;
+	}
+
+	mutex_lock(&ts->lock);
+
+	NVT_LOG("start\n");
+
+	// please make sure display reset(RESX) sequence and mipi dsi cmds sent before this
+#if NVT_TOUCH_SUPPORT_HW_RST
+	gpio_set_value(ts->reset_gpio, 1);
+#endif
+	if (nvt_update_firmware(ts->boot_update_firmware_name)) {
+		NVT_ERR("download firmware failed, ignore check fw state\n");
+	} else {
+		nvt_check_fw_reset_state(RESET_STATE_REK);
+	}
+
+#if WAKEUP_GESTURE
+	if (!ts->is_gesture_mode) {
+		nvt_irq_enable(true);
+		//spi bus pm_runtime_get
+		if (spi_geni_master_dev) {
+			if (pm_runtime_get(spi_geni_master_dev))
+				NVT_ERR("pm_runtime_get fail!\n");
+		}
+	}
+#else
+	nvt_irq_enable(true);
+#endif
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+	queue_delayed_work(nvt_esd_check_wq, &nvt_esd_check_work,
+			msecs_to_jiffies(NVT_TOUCH_ESD_CHECK_PERIOD));
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	bTouchIsAwake = 1;
+
+	mutex_unlock(&ts->lock);
+
+#if WAKEUP_GESTURE
+	if (ts->delay_gesture) {
+		lct_nvt_tp_gesture_callback(!ts->is_gesture_mode);
+		ts->delay_gesture = false;
+	}
+#endif
+
+#if NVT_USB_PLUGIN
+	if (g_touchscreen_usb_pulgin.valid && g_touchscreen_usb_pulgin.usb_plugged_in)
+		g_touchscreen_usb_pulgin.event_callback();
+#endif
+
+	NVT_LOG("end\n");
+
+	return 0;
+}
+
+#if WAKEUP_GESTURE
+int lct_nvt_tp_gesture_callback(bool flag)
+{
+	if (!bTouchIsAwake) {
+		ts->delay_gesture = true;
+		NVT_LOG("The gesture mode will be %s the next time you wakes up.\n", flag?"enabled":"disbaled");
+		return 0;
+	}
+	if (flag) {
+		ts->is_gesture_mode = true;
+		if(nvt_ts_enable_regulator(true) < 0)
+			NVT_ERR("Failed to enable regulator\n");
+			set_lcd_reset_gpio_keep_high(true);
+		NVT_LOG("enable gesture mode\n");
+	} else {
+		ts->is_gesture_mode = false;
+		if(nvt_ts_enable_regulator(false) < 0)
+			NVT_ERR("Failed to disable regulator\n");
+			set_lcd_reset_gpio_keep_high(false);
+		NVT_LOG("disable gesture mode\n");
+	}
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_FB)
+static void nvt_ts_resume_work(struct work_struct *work)
+{
+	nvt_ts_resume(&ts->client->dev);
+}
+#ifdef _MSM_DRM_NOTIFY_H_
+static int nvt_drm_notifier_callback(struct notifier_block *self, unsigned long event, void *data)
+{
+	struct msm_drm_notifier *evdata = data;
+	int *blank;
+	struct nvt_ts_data *ts =
+		container_of(self, struct nvt_ts_data, drm_notif);
+
+	if (!evdata || (evdata->id != 0))
+		return 0;
+
+	if (evdata->data && ts) {
+		blank = evdata->data;
+		if (event == MSM_DRM_EARLY_EVENT_BLANK) {
+			if (*blank == MSM_DRM_BLANK_POWERDOWN) {
+				NVT_LOG("event=%lu, *blank=%d\n", event, *blank);
+				cancel_work_sync(&ts->resume_work);
+				nvt_ts_suspend(&ts->client->dev);
+			}
+		} else if (event == MSM_DRM_EVENT_BLANK) {
+			if (*blank == MSM_DRM_BLANK_UNBLANK) {
+				NVT_LOG("event=%lu, *blank=%d\n", event, *blank);
+				//nvt_ts_resume(&ts->client->dev);
+				queue_work(ts->workqueue, &ts->resume_work);
+			}
+		}
+	}
+
+	return 0;
+}
+#else
+static int nvt_fb_notifier_callback(struct notifier_block *self, unsigned long event, void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+	struct nvt_ts_data *ts =
+		container_of(self, struct nvt_ts_data, fb_notif);
+
+	if (evdata && evdata->data && event == FB_EARLY_EVENT_BLANK) {
+		blank = evdata->data;
+		if (*blank == FB_BLANK_POWERDOWN) {
+			NVT_LOG("event=%lu, *blank=%d\n", event, *blank);
+			nvt_ts_suspend(&ts->client->dev);
+		}
+	} else if (evdata && evdata->data && event == FB_EVENT_BLANK) {
+		blank = evdata->data;
+		if (*blank == FB_BLANK_UNBLANK) {
+			NVT_LOG("event=%lu, *blank=%d\n", event, *blank);
+			nvt_ts_resume(&ts->client->dev);
+		}
+	}
+
+	return 0;
+}
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+/*******************************************************
+Description:
+	Novatek touchscreen driver early suspend function.
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_ts_early_suspend(struct early_suspend *h)
+{
+	nvt_ts_suspend(ts->client, PMSG_SUSPEND);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen driver late resume function.
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_ts_late_resume(struct early_suspend *h)
+{
+	nvt_ts_resume(ts->client);
+}
+#endif
+
+#ifdef CONFIG_PM
+static int nvt_pm_suspend(struct device *dev)
+{
+	struct nvt_ts_data *ts = dev_get_drvdata(dev);
+
+	ts->dev_pm_suspend = true;
+	reinit_completion(&ts->dev_pm_suspend_completion);
+	NVT_LOG("pm suspend");
+
+	return 0;
+}
+
+static int nvt_pm_resume(struct device *dev)
+{
+	struct nvt_ts_data *ts = dev_get_drvdata(dev);
+
+	ts->dev_pm_suspend = false;
+	complete(&ts->dev_pm_suspend_completion);
+	NVT_LOG("pm resume");
+
+	return 0;
+}
+
+static const struct dev_pm_ops nvt_dev_pm_ops = {
+	.suspend = nvt_pm_suspend,
+	.resume = nvt_pm_resume,
+};
+#endif
+
+static const struct spi_device_id nvt_ts_id[] = {
+	{ NVT_SPI_NAME, 0 },
+	{ }
+};
+
+//MODULE_DEVICE_TABLE(spi, nvt_ts_id);
+
+#ifdef CONFIG_OF
+static struct of_device_id nvt_match_table[] = {
+	{ .compatible = "novatek,NVT-ts-spi",},
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, nvt_match_table);
+#endif
+
+static struct spi_driver nvt_spi_driver = {
+	.probe		= nvt_ts_probe,
+	.remove		= nvt_ts_remove,
+	.shutdown	= nvt_ts_shutdown,
+//	.id_table	= nvt_ts_id,
+	.driver = {
+		.name	= NVT_SPI_NAME,
+//		.owner	= THIS_MODULE,
+		.pm = &nvt_dev_pm_ops,
+		.of_match_table = of_match_ptr(nvt_match_table),
+	},
+};
+
+/*******************************************************
+Description:
+	Driver Install function.
+
+return:
+	Executive Outcomes. 0---succeed. not 0---failed.
+********************************************************/
+static int32_t __init nvt_driver_init(void)
+{
+	int32_t ret = 0;
+
+	NVT_LOG("start\n");
+
+#ifdef CHECK_TOUCH_VENDOR
+	//Check TP vendor
+
+	if (IS_ERR_OR_NULL(saved_command_line)){
+		NVT_ERR("saved_command_line ERROR!\n");
+		ret = -ENOMEM;
+		goto err_driver;
+	} else {
+		if (strstr(saved_command_line,"tianma") != NULL) {
+			touch_vendor_id = TP_VENDOR_TIANMA;
+			NVT_LOG("TP info: [Vendor]tianma [IC]nt36675\n");
+		} else {
+			touch_vendor_id = TP_VENDOR_UNKNOW;
+			NVT_ERR("Unknow Touch\n");
+			ret = -ENODEV;
+			goto err_driver;
+		}
+	}
+
+	//Check android mode
+
+	if (strstr(saved_command_line, "androidboot.mode=charger") != NULL) {
+		NVT_LOG("androidboot.mode=charger, doesn't support touch in the charging mode!\n");
+		ret = -ENODEV;
+		goto err_driver;
+	}
+#endif
+
+	//---add spi driver---
+	ret = spi_register_driver(&nvt_spi_driver);
+	if (ret) {
+		NVT_ERR("failed to add spi driver");
+		goto err_driver;
+	}
+
+	NVT_LOG("finished\n");
+
+err_driver:
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Driver uninstall function.
+
+return:
+	n.a.
+********************************************************/
+static void __exit nvt_driver_exit(void)
+{
+	NVT_LOG("exit tp driver ...\n");
+	spi_unregister_driver(&nvt_spi_driver);
+}
+
+//late_initcall(nvt_driver_init);
+//module_init(nvt_driver_init);
+//module_exit(nvt_driver_exit);
+module_spi_driver(nvt_spi_driver);
+
+MODULE_DESCRIPTION("Novatek Touchscreen Driver");
+MODULE_LICENSE("GPL");
+//MODULE_ALIAS("spi:"NVT_SPI_NAME);
diff --git a/drivers/input/touchscreen/nt36xxx_spi/nt36xxx.h b/drivers/input/touchscreen/nt36xxx_spi/nt36xxx.h
new file mode 100644
index 000000000000..db8056c80d21
--- /dev/null
+++ b/drivers/input/touchscreen/nt36xxx_spi/nt36xxx.h
@@ -0,0 +1,263 @@
+/*
+ * Copyright (C) 2010 - 2018 Novatek, Inc.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ *
+ * $Revision: 43560 $
+ * $Date: 2019-04-19 11:34:19 +0800 (週五, 19 四月 2019) $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+#ifndef 	_LINUX_NVT_TOUCH_H
+#define		_LINUX_NVT_TOUCH_H
+
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/of.h>
+#include <linux/spi/spi.h>
+#include <linux/uaccess.h>
+#include <linux/regulator/consumer.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#include "nt36xxx_mem_map.h"
+
+#ifdef CONFIG_MTK_SPI
+/* Please copy mt_spi.h file under mtk spi driver folder */
+#include "mt_spi.h"
+#endif
+
+#ifdef CONFIG_SPI_MT65XX
+#include <linux/platform_data/spi-mt65xx.h>
+#endif
+
+#undef CONFIG_DRM_MSM
+#undef CONFIG_FB
+
+#define NVT_DEBUG 1
+
+//---GPIO number---
+#define NVTTOUCH_RST_PIN 87
+#define NVTTOUCH_INT_PIN 88
+
+
+//---INT trigger mode---
+//#define IRQ_TYPE_EDGE_RISING 1
+//#define IRQ_TYPE_EDGE_FALLING 2
+#define INT_TRIGGER_TYPE IRQ_TYPE_EDGE_RISING
+
+
+//---SPI driver info.---
+#define NVT_SPI_NAME "NVT-ts-spi"
+
+#if NVT_DEBUG
+#define NVT_LOG(fmt, args...)    pr_err("[%s] %s %d: " fmt, NVT_SPI_NAME, __func__, __LINE__, ##args)
+#else
+#define NVT_LOG(fmt, args...)    pr_info("[%s] %s %d: " fmt, NVT_SPI_NAME, __func__, __LINE__, ##args)
+#endif
+#define NVT_ERR(fmt, args...)    pr_err("[%s] %s %d: " fmt, NVT_SPI_NAME, __func__, __LINE__, ##args)
+
+//---Input device info.---
+#define NVT_TS_NAME "NVTCapacitiveTouchScreen"
+
+
+//---Touch info.---
+#define TOUCH_DEFAULT_MAX_WIDTH 1080
+#define TOUCH_DEFAULT_MAX_HEIGHT 2400
+#define TOUCH_MAX_FINGER_NUM 10
+#define TOUCH_KEY_NUM 0
+#if TOUCH_KEY_NUM > 0
+extern const uint16_t touch_key_array[TOUCH_KEY_NUM];
+#endif
+#define TOUCH_FORCE_NUM 1000
+
+/* Enable only when module have tp reset pin and connected to host */
+#define NVT_TOUCH_SUPPORT_HW_RST 0
+
+//---Customerized func.---
+//#define NVT_TOUCH_PROC 1
+#define NVT_TOUCH_EXT_PROC 1
+#define MT_PROTOCOL_B 1
+//#define WAKEUP_GESTURE 1
+#if WAKEUP_GESTURE
+extern const uint16_t gesture_key_array[];
+#endif
+#define BOOT_UPDATE_FIRMWARE 1
+#define FIRMWARE_NAME_LEN    256
+#define BOOT_UPDATE_FIRMWARE_NAME         "novatek_ts_fw.bin"
+#define BOOT_UPDATE_TIANMA_FIRMWARE_NAME  "novatek_ts_tianma_fw.bin"
+#define BOOT_UPDATE_EBBG_FIRMWARE_NAME    "novatek_ts_ebbg_fw.bin"
+#define MP_UPDATE_FIRMWARE_NAME           "novatek_ts_mp.bin"
+#define MP_UPDATE_TIANMA_FIRMWARE_NAME    "novatek_ts_tianma_mp.bin"
+#define MP_UPDATE_EBBG_FIRMWARE_NAME      "novatek_ts_ebbg_mp.bin"
+
+//---ESD Protect.---
+#define NVT_TOUCH_ESD_PROTECT 0
+#define NVT_TOUCH_ESD_CHECK_PERIOD 1500	/* ms */
+#define NVT_TOUCH_WDT_RECOVERY 1
+
+//enable 'check touch vendor' feature
+//#define CHECK_TOUCH_VENDOR
+
+/*functions description*/
+//enable tp usb plugin feature
+#define NVT_USB_PLUGIN 0
+
+#if NVT_USB_PLUGIN
+typedef struct touchscreen_usb_plugin_data {
+	bool valid;
+	bool usb_plugged_in;
+	void (*event_callback)(void);
+} touchscreen_usb_plugin_data_t;
+#endif
+
+//---Touch Vendor ID---
+#define TP_VENDOR_UNKNOW    0x00
+#define TP_VENDOR_TIANMA    0x01
+#define TP_VENDOR_HUAXING   0x02
+#define TP_VENDOR_EBBG      0x03
+
+#define NVT_REG_MONITOR_MODE                0x7000
+#define NVT_REG_THDIFF                      0x7100
+#define NVT_REG_SENSIVITY                   0x7200
+#define NVT_REG_EDGE_FILTER_LEVEL           0xBA00
+#define NVT_REG_EDGE_FILTER_ORIENTATION     0xBC00
+
+//new qcom platform use
+#define _MSM_DRM_NOTIFY_H_
+
+struct nvt_ts_data {
+	struct spi_device *client;
+	struct input_dev *input_dev;
+	struct delayed_work nvt_fwu_work;
+	uint16_t addr;
+	int8_t phys[32];
+#if defined(CONFIG_FB)
+	struct workqueue_struct *workqueue;
+	struct work_struct resume_work;
+#ifdef _MSM_DRM_NOTIFY_H_
+	struct notifier_block drm_notif;
+#else
+	struct notifier_block fb_notif;
+#endif
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	struct early_suspend early_suspend;
+#endif
+#ifdef CHECK_TOUCH_VENDOR
+	uint8_t touch_vendor_id;
+#endif
+	uint8_t boot_update_firmware_name[FIRMWARE_NAME_LEN];
+	uint8_t mp_update_firmware_name[FIRMWARE_NAME_LEN];
+	uint8_t fw_ver;
+	uint8_t x_num;
+	uint8_t y_num;
+	uint16_t abs_x_max;
+	uint16_t abs_y_max;
+	uint8_t max_touch_num;
+	uint8_t max_button_num;
+	uint32_t int_trigger_type;
+	int32_t irq_gpio;
+	uint32_t irq_flags;
+	int32_t reset_gpio;
+	uint32_t reset_flags;
+	struct mutex lock;
+	const struct nvt_ts_mem_map *mmap;
+	uint8_t carrier_system;
+	uint8_t hw_crc;
+	uint16_t nvt_pid;
+	uint8_t rbuf[1025];
+	uint8_t *xbuf;
+	struct mutex xbuf_lock;
+	bool irq_enabled;
+#ifdef CONFIG_PM
+        bool dev_pm_suspend;
+        struct completion dev_pm_suspend_completion;
+#endif
+#if WAKEUP_GESTURE
+	bool delay_gesture;
+	bool is_gesture_mode;
+	struct regulator *pwr_vdd; /* IOVCC 1.8V */
+	struct regulator *pwr_lab; /* VSP +5V */
+	struct regulator *pwr_ibb; /* VSN -5V */
+#endif
+#ifdef CONFIG_MTK_SPI
+	struct mt_chip_conf spi_ctrl;
+#endif
+#ifdef CONFIG_SPI_MT65XX
+    struct mtk_chip_config spi_ctrl;
+#endif
+
+	struct mutex reg_lock;
+	struct device *nvt_touch_dev;
+	struct class *nvt_tp_class;
+};
+
+#if NVT_TOUCH_PROC
+struct nvt_flash_data{
+	rwlock_t lock;
+};
+#endif
+
+typedef enum {
+	RESET_STATE_INIT = 0xA0,// IC reset
+	RESET_STATE_REK,		// ReK baseline
+	RESET_STATE_REK_FINISH,	// baseline is ready
+	RESET_STATE_NORMAL_RUN,	// normal run
+	RESET_STATE_MAX  = 0xAF
+} RST_COMPLETE_STATE;
+
+typedef enum {
+    EVENT_MAP_HOST_CMD                      = 0x50,
+    EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE   = 0x51,
+    EVENT_MAP_RESET_COMPLETE                = 0x60,
+    EVENT_MAP_FWINFO                        = 0x78,
+    EVENT_MAP_PROJECTID                     = 0x9A,
+} SPI_EVENT_MAP;
+
+//---SPI READ/WRITE---
+#define SPI_WRITE_MASK(a)	(a | 0x80)
+#define SPI_READ_MASK(a)	(a & 0x7F)
+
+#define DUMMY_BYTES (1)
+#define NVT_TRANSFER_LEN	(63*1024)
+
+typedef enum {
+	NVTWRITE = 0,
+	NVTREAD  = 1
+} NVT_SPI_RW;
+
+//---extern structures---
+extern struct nvt_ts_data *ts;
+
+//---extern functions---
+int32_t CTP_SPI_READ(struct spi_device *client, uint8_t *buf, uint16_t len);
+int32_t CTP_SPI_WRITE(struct spi_device *client, uint8_t *buf, uint16_t len);
+void nvt_bootloader_reset(void);
+void nvt_eng_reset(void);
+void nvt_sw_reset(void);
+void nvt_sw_reset_idle(void);
+void nvt_boot_ready(void);
+void nvt_bld_crc_enable(void);
+void nvt_fw_crc_enable(void);
+int32_t nvt_update_firmware(char *firmware_name);
+int32_t nvt_check_fw_reset_state(RST_COMPLETE_STATE check_reset_state);
+int32_t nvt_get_fw_info(void);
+int32_t nvt_clear_fw_status(void);
+int32_t nvt_check_fw_status(void);
+int32_t nvt_set_page(uint32_t addr);
+int32_t nvt_write_addr(uint32_t addr, uint8_t data);
+#if NVT_TOUCH_ESD_PROTECT
+extern void nvt_esd_check_enable(uint8_t enable);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+#endif /* _LINUX_NVT_TOUCH_H */
diff --git a/drivers/input/touchscreen/nt36xxx_spi/nt36xxx_ext_proc.c b/drivers/input/touchscreen/nt36xxx_spi/nt36xxx_ext_proc.c
new file mode 100644
index 000000000000..00998718f55b
--- /dev/null
+++ b/drivers/input/touchscreen/nt36xxx_spi/nt36xxx_ext_proc.c
@@ -0,0 +1,2017 @@
+/*
+ * Copyright (C) 2010 - 2018 Novatek, Inc.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ *
+ * $Revision: 43423 $
+ * $Date: 2019-04-16 19:58:23 +0800 (週二, 16 四月 2019) $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+#include "nt36xxx.h"
+
+#if NVT_TOUCH_EXT_PROC
+#define NVT_FW_VERSION "nvt_fw_version"
+#define NVT_BASELINE "nvt_baseline"
+#define NVT_RAW "nvt_raw"
+#define NVT_DIFF "nvt_diff"
+#define NVT_PF_SWITCH "nvt_pf_switch"
+#define NVT_SENSITIVITY_SWITCH "nvt_sensitivity_switch"
+#define NVT_ER_RANGE_SWITCH "nvt_er_range_switch"
+#define NVT_MAX_POWER_SWITCH "nvt_max_power_switch"
+#define NVT_EDGE_REJECT_SWITCH "nvt_edge_reject_switch"
+#define NVT_POCKET_PALM_SWITCH "nvt_pocket_palm_switch"
+#define NVT_CHARGER_SWITCH "nvt_charger_switch"
+
+#define SPI_TANSFER_LENGTH  256
+
+#define NORMAL_MODE 0x00
+#define TEST_MODE_1 0x21
+#define TEST_MODE_2 0x22
+#define HANDSHAKING_HOST_READY 0xBB
+
+#define XDATA_SECTOR_SIZE   256
+
+static uint8_t xdata_tmp[2048] = {0};
+static int32_t xdata[2048] = {0};
+
+static struct proc_dir_entry *NVT_proc_fw_version_entry;
+static struct proc_dir_entry *NVT_proc_baseline_entry;
+static struct proc_dir_entry *NVT_proc_raw_entry;
+static struct proc_dir_entry *NVT_proc_diff_entry;
+static struct proc_dir_entry *NVT_proc_pf_switch_entry;
+static struct proc_dir_entry *NVT_proc_sensitivity_switch_entry;
+static struct proc_dir_entry *NVT_proc_er_range_switch_entry;
+static struct proc_dir_entry *NVT_proc_max_power_switch_entry;
+static struct proc_dir_entry *NVT_proc_edge_reject_switch_entry;
+static struct proc_dir_entry *NVT_proc_pocket_palm_switch_entry;
+static struct proc_dir_entry *NVT_proc_charger_switch_entry;
+static int32_t diff_data[2048] = {0};
+
+/*******************************************************
+Description:
+	Novatek touchscreen change mode function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_change_mode(uint8_t mode)
+{
+	uint8_t buf[8] = {0};
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+
+	//---set mode---
+	buf[0] = EVENT_MAP_HOST_CMD;
+	buf[1] = mode;
+	CTP_SPI_WRITE(ts->client, buf, 2);
+
+	if (mode == NORMAL_MODE) {
+		buf[0] = EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE;
+		buf[1] = HANDSHAKING_HOST_READY;
+		CTP_SPI_WRITE(ts->client, buf, 2);
+		msleep(20);
+	}
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen get firmware pipe function.
+
+return:
+	Executive outcomes. 0---pipe 0. 1---pipe 1.
+*******************************************************/
+uint8_t nvt_get_fw_pipe(void)
+{
+	uint8_t buf[8]= {0};
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE);
+
+	//---read fw status---
+	buf[0] = EVENT_MAP_HANDSHAKING_or_SUB_CMD_BYTE;
+	buf[1] = 0x00;
+	CTP_SPI_READ(ts->client, buf, 2);
+
+	//NVT_LOG("FW pipe=%d, buf[1]=0x%02X\n", (buf[1]&0x01), buf[1]);
+
+	return (buf[1] & 0x01);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen read meta data function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_read_mdata(uint32_t xdata_addr, uint32_t xdata_btn_addr)
+{
+	int32_t i = 0;
+	int32_t j = 0;
+	int32_t k = 0;
+	uint8_t buf[SPI_TANSFER_LENGTH + 1] = {0};
+	uint32_t head_addr = 0;
+	int32_t dummy_len = 0;
+	int32_t data_len = 0;
+	int32_t residual_len = 0;
+
+	//---set xdata sector address & length---
+	head_addr = xdata_addr - (xdata_addr % XDATA_SECTOR_SIZE);
+	dummy_len = xdata_addr - head_addr;
+	data_len = ts->x_num * ts->y_num * 2;
+	residual_len = (head_addr + dummy_len + data_len) % XDATA_SECTOR_SIZE;
+
+	//printk("head_addr=0x%05X, dummy_len=0x%05X, data_len=0x%05X, residual_len=0x%05X\n", head_addr, dummy_len, data_len, residual_len);
+
+	//read xdata : step 1
+	for (i = 0; i < ((dummy_len + data_len) / XDATA_SECTOR_SIZE); i++) {
+		//---read xdata by SPI_TANSFER_LENGTH
+		for (j = 0; j < (XDATA_SECTOR_SIZE / SPI_TANSFER_LENGTH); j++) {
+			//---change xdata index---
+			nvt_set_page(head_addr + (XDATA_SECTOR_SIZE * i) + (SPI_TANSFER_LENGTH * j));
+
+			//---read data---
+			buf[0] = SPI_TANSFER_LENGTH * j;
+			CTP_SPI_READ(ts->client, buf, SPI_TANSFER_LENGTH + 1);
+
+			//---copy buf to xdata_tmp---
+			for (k = 0; k < SPI_TANSFER_LENGTH; k++) {
+				xdata_tmp[XDATA_SECTOR_SIZE * i + SPI_TANSFER_LENGTH * j + k] = buf[k + 1];
+				//printk("0x%02X, 0x%04X\n", buf[k+1], (XDATA_SECTOR_SIZE*i + SPI_TANSFER_LENGTH*j + k));
+			}
+		}
+		//printk("addr=0x%05X\n", (head_addr+XDATA_SECTOR_SIZE*i));
+	}
+
+	//read xdata : step2
+	if (residual_len != 0) {
+		//---read xdata by SPI_TANSFER_LENGTH
+		for (j = 0; j < (residual_len / SPI_TANSFER_LENGTH + 1); j++) {
+			//---change xdata index---
+			nvt_set_page(xdata_addr + data_len - residual_len + (SPI_TANSFER_LENGTH * j));
+
+			//---read data---
+			buf[0] = SPI_TANSFER_LENGTH * j;
+			CTP_SPI_READ(ts->client, buf, SPI_TANSFER_LENGTH + 1);
+
+			//---copy buf to xdata_tmp---
+			for (k = 0; k < SPI_TANSFER_LENGTH; k++) {
+				xdata_tmp[(dummy_len + data_len - residual_len) + SPI_TANSFER_LENGTH * j + k] = buf[k + 1];
+				//printk("0x%02X, 0x%04x\n", buf[k+1], ((dummy_len+data_len-residual_len) + SPI_TANSFER_LENGTH*j + k));
+			}
+		}
+		//printk("addr=0x%05X\n", (xdata_addr+data_len-residual_len));
+	}
+
+	//---remove dummy data and 2bytes-to-1data---
+	for (i = 0; i < (data_len / 2); i++) {
+		xdata[i] = (int16_t)(xdata_tmp[dummy_len + i * 2] + 256 * xdata_tmp[dummy_len + i * 2 + 1]);
+	}
+
+#if TOUCH_KEY_NUM > 0
+	//read button xdata : step3
+	//---change xdata index---
+	nvt_set_page(xdata_btn_addr);
+	//---read data---
+	buf[0] = (xdata_btn_addr & 0xFF);
+	CTP_SPI_READ(ts->client, buf, (TOUCH_KEY_NUM * 2 + 1));
+
+	//---2bytes-to-1data---
+	for (i = 0; i < TOUCH_KEY_NUM; i++) {
+		xdata[ts->x_num * ts->y_num + i] = (int16_t)(buf[1 + i * 2] + 256 * buf[1 + i * 2 + 1]);
+	}
+#endif
+
+	//---set xdata index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR);
+}
+
+/*******************************************************
+Description:
+    Novatek touchscreen get meta data function.
+
+return:
+    n.a.
+*******************************************************/
+void nvt_get_mdata(int32_t *buf, uint8_t *m_x_num, uint8_t *m_y_num)
+{
+    *m_x_num = ts->x_num;
+    *m_y_num = ts->y_num;
+    memcpy(buf, xdata, ((ts->x_num * ts->y_num + TOUCH_KEY_NUM) * sizeof(int32_t)));
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen firmware version show function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t c_fw_version_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "fw_ver=%d, x_num=%d, y_num=%d, button_num=%d\n", ts->fw_ver, ts->x_num, ts->y_num, ts->max_button_num);
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen xdata sequence print show
+	function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t c_show(struct seq_file *m, void *v)
+{
+	int32_t i = 0;
+	int32_t j = 0;
+
+	for (i = 0; i < ts->y_num; i++) {
+		for (j = 0; j < ts->x_num; j++) {
+			seq_printf(m, "%5d, ", xdata[i * ts->x_num + j]);
+		}
+		seq_puts(m, "\n");
+	}
+
+#if TOUCH_KEY_NUM > 0
+	for (i = 0; i < TOUCH_KEY_NUM; i++) {
+		seq_printf(m, "%5d, ", xdata[ts->x_num * ts->y_num + i]);
+	}
+	seq_puts(m, "\n");
+#endif
+
+	seq_printf(m, "\n\n");
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen xdata sequence print start
+	function.
+
+return:
+	Executive outcomes. 1---call next function.
+	NULL---not call next function and sequence loop
+	stop.
+*******************************************************/
+static void *c_start(struct seq_file *m, loff_t *pos)
+{
+	return *pos < 1 ? (void *)1 : NULL;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen xdata sequence print next
+	function.
+
+return:
+	Executive outcomes. NULL---no next and call sequence
+	stop function.
+*******************************************************/
+static void *c_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	++*pos;
+	return NULL;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen xdata sequence print stop
+	function.
+
+return:
+	n.a.
+*******************************************************/
+static void c_stop(struct seq_file *m, void *v)
+{
+	return;
+}
+
+const struct seq_operations nvt_fw_version_seq_ops = {
+	.start  = c_start,
+	.next   = c_next,
+	.stop   = c_stop,
+	.show   = c_fw_version_show
+};
+
+const struct seq_operations nvt_seq_ops = {
+	.start  = c_start,
+	.next   = c_next,
+	.stop   = c_stop,
+	.show   = c_show
+};
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/nvt_fw_version open
+	function.
+
+return:
+	n.a.
+*******************************************************/
+static int32_t nvt_fw_version_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+	NVT_LOG("++\n");
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	if (nvt_get_fw_info()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	mutex_unlock(&ts->lock);
+
+	NVT_LOG("--\n");
+
+	return seq_open(file, &nvt_fw_version_seq_ops);
+}
+
+static const struct file_operations nvt_fw_version_fops = {
+	.owner = THIS_MODULE,
+	.open = nvt_fw_version_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/nvt_baseline open function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t nvt_baseline_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+	NVT_LOG("++\n");
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	if (nvt_clear_fw_status()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	nvt_change_mode(TEST_MODE_2);
+
+	if (nvt_check_fw_status()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	if (nvt_get_fw_info()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	nvt_read_mdata(ts->mmap->BASELINE_ADDR, ts->mmap->BASELINE_BTN_ADDR);
+
+	nvt_change_mode(NORMAL_MODE);
+
+	mutex_unlock(&ts->lock);
+
+	NVT_LOG("--\n");
+
+	return seq_open(file, &nvt_seq_ops);
+}
+
+static const struct file_operations nvt_baseline_fops = {
+	.owner = THIS_MODULE,
+	.open = nvt_baseline_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/nvt_raw open function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+static int32_t nvt_raw_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+	NVT_LOG("++\n");
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	if (nvt_clear_fw_status()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	nvt_change_mode(TEST_MODE_2);
+
+	if (nvt_check_fw_status()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	if (nvt_get_fw_info()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	if (nvt_get_fw_pipe() == 0)
+		nvt_read_mdata(ts->mmap->RAW_PIPE0_ADDR, ts->mmap->RAW_BTN_PIPE0_ADDR);
+	else
+		nvt_read_mdata(ts->mmap->RAW_PIPE1_ADDR, ts->mmap->RAW_BTN_PIPE1_ADDR);
+
+	nvt_change_mode(NORMAL_MODE);
+
+	mutex_unlock(&ts->lock);
+
+	NVT_LOG("--\n");
+
+	return seq_open(file, &nvt_seq_ops);
+}
+
+static const struct file_operations nvt_raw_fops = {
+	.owner = THIS_MODULE,
+	.open = nvt_raw_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+/*******************************************************
+Description:
+	Novatek touchscreen /proc/nvt_diff open function.
+
+return:
+	Executive outcomes. 0---succeed. negative---failed.
+*******************************************************/
+static int32_t nvt_diff_open(struct inode *inode, struct file *file)
+{
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+	NVT_LOG("++\n");
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	if (nvt_clear_fw_status()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	nvt_change_mode(TEST_MODE_2);
+
+	if (nvt_check_fw_status()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	if (nvt_get_fw_info()) {
+		mutex_unlock(&ts->lock);
+		return -EAGAIN;
+	}
+
+	if (nvt_get_fw_pipe() == 0)
+		nvt_read_mdata(ts->mmap->DIFF_PIPE0_ADDR, ts->mmap->DIFF_BTN_PIPE0_ADDR);
+	else
+		nvt_read_mdata(ts->mmap->DIFF_PIPE1_ADDR, ts->mmap->DIFF_BTN_PIPE1_ADDR);
+
+	nvt_change_mode(NORMAL_MODE);
+
+	mutex_unlock(&ts->lock);
+
+	NVT_LOG("--\n");
+
+	return seq_open(file, &nvt_seq_ops);
+}
+
+static const struct file_operations nvt_diff_fops = {
+	.owner = THIS_MODULE,
+	.open = nvt_diff_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+/*******************************************************
+Description:
+	Novatek touchscreen read diff meta data function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_read_diff_mdata(uint32_t xdata_addr, uint32_t xdata_btn_addr)
+{
+	int32_t i = 0;
+	int32_t j = 0;
+	int32_t k = 0;
+	uint8_t buf[SPI_TANSFER_LENGTH + 1] = {0};
+	uint32_t head_addr = 0;
+	int32_t dummy_len = 0;
+	int32_t data_len = 0;
+	int32_t residual_len = 0;
+
+	//---set diff_data sector address & length---
+	head_addr = xdata_addr - (xdata_addr % XDATA_SECTOR_SIZE);
+	dummy_len = xdata_addr - head_addr;
+	data_len = ts->x_num * ts->y_num * 2;
+	residual_len = (head_addr + dummy_len + data_len) % XDATA_SECTOR_SIZE;
+
+	//printk("head_addr=0x%05X, dummy_len=0x%05X, data_len=0x%05X, residual_len=0x%05X\n", head_addr, dummy_len, data_len, residual_len);
+
+	//read diff_data : step 1
+	for (i = 0; i < ((dummy_len + data_len) / XDATA_SECTOR_SIZE); i++) {
+		//---read diff_data by SPI_TANSFER_LENGTH
+		for (j = 0; j < (XDATA_SECTOR_SIZE / SPI_TANSFER_LENGTH); j++) {
+			//---change diff_data index---
+			nvt_set_page(head_addr + (XDATA_SECTOR_SIZE * i) + (SPI_TANSFER_LENGTH * j));
+
+			//---read data---
+			buf[0] = SPI_TANSFER_LENGTH * j;
+			CTP_SPI_READ(ts->client, buf, SPI_TANSFER_LENGTH + 1);
+
+			//---copy buf to xdata_tmp---
+			for (k = 0; k < SPI_TANSFER_LENGTH; k++) {
+				xdata_tmp[XDATA_SECTOR_SIZE * i + SPI_TANSFER_LENGTH * j + k] = buf[k + 1];
+				//printk("0x%02X, 0x%04X\n", buf[k+1], (XDATA_SECTOR_SIZE*i + SPI_TANSFER_LENGTH*j + k));
+			}
+		}
+		//printk("addr=0x%05X\n", (head_addr+XDATA_SECTOR_SIZE*i));
+	}
+
+	//read diff_data : step2
+	if (residual_len != 0) {
+		//---read diff_data by SPI_TANSFER_LENGTH
+		for (j = 0; j < (residual_len / SPI_TANSFER_LENGTH + 1); j++) {
+			//---change diff_data index---
+			nvt_set_page(xdata_addr + data_len - residual_len + (SPI_TANSFER_LENGTH * j));
+
+			//---read data---
+			buf[0] = SPI_TANSFER_LENGTH * j;
+			CTP_SPI_READ(ts->client, buf, SPI_TANSFER_LENGTH + 1);
+
+			//---copy buf to xdata_tmp---
+			for (k = 0; k < SPI_TANSFER_LENGTH; k++) {
+				xdata_tmp[(dummy_len + data_len - residual_len) + SPI_TANSFER_LENGTH * j + k] = buf[k + 1];
+				//printk("0x%02X, 0x%04x\n", buf[k+1], ((dummy_len+data_len-residual_len) + SPI_TANSFER_LENGTH*j + k));
+			}
+		}
+		//printk("addr=0x%05X\n", (xdata_addr+data_len-residual_len));
+	}
+
+	//---remove dummy data and 2bytes-to-1data---
+	for (i = 0; i < (data_len / 2); i++) {
+		diff_data[i] = (int16_t)(xdata_tmp[dummy_len + i * 2] + 256 * xdata_tmp[dummy_len + i * 2 + 1]);
+	}
+
+#if TOUCH_KEY_NUM > 0
+	//read button diff_data : step3
+	//---change diff_data index---
+	nvt_set_page(xdata_btn_addr);
+	//---read data---
+	buf[0] = (xdata_btn_addr & 0xFF);
+	CTP_SPI_READ(ts->client, buf, (TOUCH_KEY_NUM * 2 + 1));
+
+	//---2bytes-to-1data---
+	for (i = 0; i < TOUCH_KEY_NUM; i++) {
+		diff_data[ts->x_num * ts->y_num + i] = (int16_t)(buf[1 + i * 2] + 256 * buf[1 + i * 2 + 1]);
+	}
+#endif
+
+	//---set diff_data index to EVENT BUF ADDR---
+	nvt_set_page(ts->mmap->EVENT_BUF_ADDR);
+}
+
+/*function description*/
+int32_t nvt_set_pf_switch(uint8_t pf_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set pf switch: %d\n", pf_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_pf_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	buf[1] = 0x70;
+	buf[2] = pf_switch;
+	ret = CTP_SPI_WRITE(ts->client, buf, 3);
+	if (ret < 0) {
+		NVT_ERR("Write pf switch command fail!\n");
+		goto nvt_set_pf_switch_out;
+	}
+
+nvt_set_pf_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_pf_switch(uint8_t *pf_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5D);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_pf_switch_out;
+	}
+
+	buf[0] = 0x5D;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read pf switch status fail!\n");
+		goto nvt_get_pf_switch_out;
+	}
+
+	*pf_switch = (buf[1] & 0x03);
+	NVT_LOG("pf_switch = %d\n", *pf_switch);
+
+nvt_get_pf_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_pf_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished = 0;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t pf_switch;
+	char tmp_buf[64];
+
+	NVT_LOG("++\n");
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_pf_switch(&pf_switch);
+
+	mutex_unlock(&ts->lock);
+	cnt = snprintf(tmp_buf, sizeof(tmp_buf), "pf_switch: %d\n", pf_switch);
+	if (copy_to_user(buf, tmp_buf, sizeof(tmp_buf))) {
+		NVT_ERR("copy_to_user() error!\n");
+		return -EFAULT;
+	}
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_pf_switch_proc_write(struct file *filp,const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t pf_switch;
+	char *tmp_buf;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value! count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/*function description*/
+	tmp_buf = kzalloc(count, GFP_KERNEL);
+	if (!tmp_buf) {
+		NVT_ERR("Allocate tmp_buf fail!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(tmp_buf, buf, count)) {
+		NVT_ERR("copy_from_user() error!\n");
+		ret = -EFAULT;
+		goto out;
+	}
+
+	ret = sscanf(tmp_buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value! ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if (tmp < 0 || tmp > 2) {
+		NVT_ERR("Invalid value! tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	pf_switch = (uint8_t)tmp;
+	NVT_LOG("pf_switch = %d\n", pf_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_pf_switch(pf_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	kfree(tmp_buf);
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct file_operations nvt_pf_switch_fops = {
+	.owner = THIS_MODULE,
+	.read  = nvt_pf_switch_proc_read,
+	.write = nvt_pf_switch_proc_write,
+};
+
+int32_t nvt_set_sensitivity_switch(uint8_t sensitivity_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set sensitivity switch: %d\n", sensitivity_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_sensitivity_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	buf[1] = 0x71;
+	buf[2] = sensitivity_switch;
+	ret = CTP_SPI_WRITE(ts->client, buf, 3);
+	if (ret < 0) {
+		NVT_ERR("Write sensitivity switch command fail!\n");
+		goto nvt_set_sensitivity_switch_out;
+	}
+
+nvt_set_sensitivity_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_sensitivity_switch(uint8_t *sensitivity_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5D);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_sensitivity_switch_out;
+	}
+
+	buf[0] = 0x5D;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read sensitivity switch status fail!\n");
+		goto nvt_get_sensitivity_switch_out;
+	}
+
+	*sensitivity_switch = ((buf[1] >> 2) & 0x03);
+	NVT_LOG("sensitivity_switch = %d\n", *sensitivity_switch);
+
+nvt_get_sensitivity_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_sensitivity_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished = 0;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t sensitivity_switch;
+	char tmp_buf[64];
+
+	NVT_LOG("++\n");
+
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_sensitivity_switch(&sensitivity_switch);
+
+	mutex_unlock(&ts->lock);
+
+	cnt = snprintf(tmp_buf, sizeof(tmp_buf), "sensitivity_switch: %d\n", sensitivity_switch);
+	if (copy_to_user(buf, tmp_buf, sizeof(tmp_buf))) {
+		NVT_ERR("copy_to_user() error!\n");
+		return -EFAULT;
+	}
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_sensitivity_switch_proc_write(struct file *filp,const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t sensitivity_switch;
+	char *tmp_buf;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value! count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+	/*function description*/
+	tmp_buf = kzalloc(count, GFP_KERNEL);
+	if (!tmp_buf) {
+		NVT_ERR("Allocate tmp_buf fail!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(tmp_buf, buf, count)) {
+		NVT_ERR("copy_from_user() error!\n");
+		ret = -EFAULT;
+		goto out;
+	}
+
+	ret = sscanf(tmp_buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value! ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if (tmp < 0 || tmp > 3) {
+		NVT_ERR("Invalid value! tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	sensitivity_switch = (uint8_t)tmp;
+	NVT_LOG("sensitivity_switch = %d\n", sensitivity_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_sensitivity_switch(sensitivity_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	kfree(tmp_buf);
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct file_operations nvt_sensitivity_switch_fops = {
+	.owner = THIS_MODULE,
+	.read = nvt_sensitivity_switch_proc_read,
+	.write = nvt_sensitivity_switch_proc_write,
+};
+
+int32_t nvt_set_er_range_switch(uint8_t er_range_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set er range switch: %d\n", er_range_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_er_range_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	buf[1] = 0x72;
+	buf[2] = er_range_switch;
+	ret = CTP_SPI_WRITE(ts->client, buf, 3);
+	if (ret < 0) {
+		NVT_ERR("Write er range switch command fail!\n");
+		goto nvt_set_er_range_switch_out;
+	}
+
+nvt_set_er_range_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_er_range_switch(uint8_t *er_range_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5D);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_er_range_switch_out;
+	}
+
+	buf[0] = 0x5D;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read er range switch status fail!\n");
+		goto nvt_get_er_range_switch_out;
+	}
+
+	*er_range_switch = ((buf[1] >> 4) & 0x03);
+	NVT_LOG("er_range_switch = %d\n", *er_range_switch);
+
+nvt_get_er_range_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_er_range_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished = 0;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t er_range_switch;
+	char tmp_buf[64];
+
+	NVT_LOG("++\n");
+
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_er_range_switch(&er_range_switch);
+
+	mutex_unlock(&ts->lock);
+
+	cnt = snprintf(tmp_buf, sizeof(tmp_buf), "er_range_switch: %d\n", er_range_switch);
+	if (copy_to_user(buf, tmp_buf, sizeof(tmp_buf))) {
+		NVT_ERR("copy_to_user() error!\n");
+		return -EFAULT;
+	}
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_er_range_switch_proc_write(struct file *filp,const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t er_range_switch;
+	char *tmp_buf;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value! count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+	/*function description*/
+	tmp_buf = kzalloc(count, GFP_KERNEL);
+	if (!tmp_buf) {
+		NVT_ERR("Allocate tmp_buf fail!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(tmp_buf, buf, count)) {
+		NVT_ERR("copy_from_user() error!\n");
+		ret = -EFAULT;
+		goto out;
+	}
+	ret = sscanf(tmp_buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value! ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if (tmp < 0 || tmp > 3) {
+		NVT_ERR("Invalid value! tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	er_range_switch = (uint8_t)tmp;
+	NVT_LOG("er_range_switch = %d\n", er_range_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_er_range_switch(er_range_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	kfree(tmp_buf);
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct file_operations nvt_er_range_switch_fops = {
+	.owner = THIS_MODULE,
+	.read = nvt_er_range_switch_proc_read,
+	.write = nvt_er_range_switch_proc_write,
+};
+
+int32_t nvt_set_max_power_switch(uint8_t max_power_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set max power switch: %d\n", max_power_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_max_power_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	if (max_power_switch == 1) {
+		buf[1] = 0x75;
+	} else if (max_power_switch == 0) {
+		buf[1] = 0x76;
+	} else {
+		NVT_ERR("Invalid max power switch: %d\n", max_power_switch);
+		ret = -EINVAL;
+		goto nvt_set_max_power_switch_out;
+	}
+	ret = CTP_SPI_WRITE(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Write max power switch command fail!\n");
+		goto nvt_set_max_power_switch_out;
+	}
+
+nvt_set_max_power_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_max_power_switch(uint8_t *max_power_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5D);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_max_power_switch_out;
+	}
+
+	buf[0] = 0x5D;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read max power switch status fail!\n");
+		goto nvt_get_max_power_switch_out;
+	}
+
+	*max_power_switch = ((buf[1] >> 7) & 0x01);
+	NVT_LOG("max_power_switch = %d\n", *max_power_switch);
+
+nvt_get_max_power_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_max_power_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished = 0;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t max_power_switch;
+
+	NVT_LOG("++\n");
+
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_max_power_switch(&max_power_switch);
+
+	mutex_unlock(&ts->lock);
+
+	cnt = snprintf(buf, PAGE_SIZE - len, "max_power_switch: %d\n", max_power_switch);
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_max_power_switch_proc_write(struct file *filp,const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t max_power_switch;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value! count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = sscanf(buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value! ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if (tmp < 0 || tmp > 1) {
+		NVT_ERR("Invalid value! tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	max_power_switch = (uint8_t)tmp;
+	NVT_LOG("max_power_switch = %d\n", max_power_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_max_power_switch(max_power_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct file_operations nvt_max_power_switch_fops = {
+	.owner = THIS_MODULE,
+	.read = nvt_max_power_switch_proc_read,
+	.write = nvt_max_power_switch_proc_write,
+};
+
+int32_t nvt_set_edge_reject_switch(uint8_t edge_reject_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set edge reject switch: %d\n", edge_reject_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_edge_reject_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	if (edge_reject_switch == 1) {
+		// vertical
+		buf[1] = 0xBA;
+	} else if (edge_reject_switch == 2) {
+		// left up
+		buf[1] = 0xBB;
+	} else if (edge_reject_switch == 3) {
+		// righ up
+		buf[1] = 0xBC;
+	} else {
+		NVT_ERR("Invalid value! edge_reject_switch = %d\n", edge_reject_switch);
+		ret = -EINVAL;
+		goto nvt_set_edge_reject_switch_out;
+	}
+	ret = CTP_SPI_WRITE(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Write edge reject switch command fail!\n");
+		goto nvt_set_edge_reject_switch_out;
+	}
+
+nvt_set_edge_reject_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_edge_reject_switch(uint8_t *edge_reject_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5C);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_edge_reject_switch_out;
+	}
+
+	buf[0] = 0x5C;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read edge reject switch status fail!\n");
+		goto nvt_get_edge_reject_switch_out;
+	}
+
+	*edge_reject_switch = ((buf[1] >> 5) & 0x03);
+	NVT_LOG("edge_reject_switch = %d\n", *edge_reject_switch);
+
+nvt_get_edge_reject_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_edge_reject_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished = 0;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t edge_reject_switch;
+
+	NVT_LOG("++\n");
+
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_edge_reject_switch(&edge_reject_switch);
+
+	mutex_unlock(&ts->lock);
+
+	cnt = snprintf(buf, PAGE_SIZE - len, "edge_reject_switch: %d\n", edge_reject_switch);
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_edge_reject_switch_proc_write(struct file *filp,const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t edge_reject_switch;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value! count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = sscanf(buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value! ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if (tmp < 1 || tmp > 3) {
+		NVT_ERR("Invalid value! tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	edge_reject_switch = (uint8_t)tmp;
+	NVT_LOG("edge_reject_switch = %d\n", edge_reject_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_edge_reject_switch(edge_reject_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct file_operations nvt_edge_reject_switch_fops = {
+	.owner = THIS_MODULE,
+	.read = nvt_edge_reject_switch_proc_read,
+	.write = nvt_edge_reject_switch_proc_write,
+};
+
+int32_t nvt_set_pocket_palm_switch(uint8_t pocket_palm_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set pocket palm switch: %d\n", pocket_palm_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_pocket_palm_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	if (pocket_palm_switch == 0) {
+		// pocket palm disable
+		buf[1] = 0x74;
+	} else if (pocket_palm_switch == 1) {
+		// pocket palm enable
+		buf[1] = 0x73;
+	} else {
+		NVT_ERR("Invalid value! pocket_palm_switch = %d\n", pocket_palm_switch);
+		ret = -EINVAL;
+		goto nvt_set_pocket_palm_switch_out;
+	}
+	ret = CTP_SPI_WRITE(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Write pocket palm switch command fail!\n");
+		goto nvt_set_pocket_palm_switch_out;
+	}
+
+nvt_set_pocket_palm_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_pocket_palm_switch(uint8_t *pocket_palm_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5D);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_pocket_palm_switch_out;
+	}
+
+	buf[0] = 0x5D;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read pocket palm switch status fail!\n");
+		goto nvt_get_pocket_palm_switch_out;
+	}
+
+	*pocket_palm_switch = ((buf[1] >> 6) & 0x01);
+	NVT_LOG("pocket_palm_switch = %d\n", *pocket_palm_switch);
+
+nvt_get_pocket_palm_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_pocket_palm_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished = 0;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t pocket_palm_switch;
+	char tmp_buf[64];
+
+	NVT_LOG("++\n");
+
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_pocket_palm_switch(&pocket_palm_switch);
+
+	mutex_unlock(&ts->lock);
+	cnt = snprintf(tmp_buf, sizeof(tmp_buf), "pocket_palm_switch: %d\n", pocket_palm_switch);
+	if (copy_to_user(buf, tmp_buf, sizeof(tmp_buf))) {
+		NVT_LOG("copy_to_user() error!\n");
+		return -EFAULT;
+	}
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_pocket_palm_switch_proc_write(struct file *filp,const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t pocket_palm_switch;
+	char *tmp_buf;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value!, count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+	/*function description*/
+	tmp_buf = kzalloc(count, GFP_KERNEL);
+	if (!tmp_buf) {
+		NVT_ERR("Allocate tmp_buf fail!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(tmp_buf, buf, count)) {
+		NVT_ERR("copy_from_user() error!\n");
+		ret = -EFAULT;
+		goto out;
+	}
+	ret = sscanf(tmp_buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value!, ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if ((tmp < 0) || (tmp > 1)) {
+		NVT_ERR("Invalid value!, tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	pocket_palm_switch = (uint8_t)tmp;
+	NVT_LOG("pocket_palm_switch = %d\n", pocket_palm_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_pocket_palm_switch(pocket_palm_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	kfree(tmp_buf);
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct file_operations nvt_pocket_palm_switch_fops = {
+	.owner = THIS_MODULE,
+	.read  = nvt_pocket_palm_switch_proc_read,
+	.write = nvt_pocket_palm_switch_proc_write,
+};
+
+int32_t nvt_set_charger_switch(uint8_t charger_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+	NVT_LOG("set charger switch: %d\n", charger_switch);
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_HOST_CMD);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_set_charger_switch_out;
+	}
+
+	buf[0] = EVENT_MAP_HOST_CMD;
+	if (charger_switch == 0) {
+		// charger off
+		buf[1] = 0x51;
+	} else if (charger_switch == 1) {
+		// charger on
+		buf[1] = 0x53;
+	} else {
+		NVT_ERR("Invalid value! charger_switch = %d\n", charger_switch);
+		ret = -EINVAL;
+		goto nvt_set_charger_switch_out;
+	}
+	ret = CTP_SPI_WRITE(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Write charger switch command fail!\n");
+		goto nvt_set_charger_switch_out;
+	}
+
+nvt_set_charger_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+int32_t nvt_get_charger_switch(uint8_t *charger_switch)
+{
+	uint8_t buf[8] = {0};
+	int32_t ret = 0;
+
+	NVT_LOG("++\n");
+
+	msleep(35);
+
+	//---set xdata index to EVENT BUF ADDR---
+	ret = nvt_set_page(ts->mmap->EVENT_BUF_ADDR | 0x5D);
+	if (ret < 0) {
+		NVT_ERR("Set event buffer index fail!\n");
+		goto nvt_get_charger_switch_out;
+	}
+
+	buf[0] = 0x5C;
+	buf[1] = 0x00;
+	ret = CTP_SPI_READ(ts->client, buf, 2);
+	if (ret < 0) {
+		NVT_ERR("Read charger switch status fail!\n");
+		goto nvt_get_charger_switch_out;
+	}
+
+	*charger_switch = ((buf[1] >> 2) & 0x01);
+	NVT_LOG("charger_switch = %d\n", *charger_switch);
+
+nvt_get_charger_switch_out:
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static ssize_t nvt_charger_switch_proc_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	static int finished = 0;
+	int32_t cnt = 0;
+	int32_t len = 0;
+	uint8_t charger_switch;
+	char tmp_buf[64];
+
+	NVT_LOG("++\n");
+
+	/*
+	* We return 0 to indicate end of file, that we have
+	* no more information. Otherwise, processes will
+	* continue to read from us in an endless loop.
+	*/
+	if (finished) {
+		NVT_LOG("read END\n");
+		finished = 0;
+		return 0;
+	}
+	finished = 1;
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_get_charger_switch(&charger_switch);
+
+	mutex_unlock(&ts->lock);
+
+	cnt = snprintf(tmp_buf, sizeof(tmp_buf), "charger_switch: %d\n", charger_switch);
+	if (copy_to_user(buf, tmp_buf, sizeof(tmp_buf))) {
+		NVT_ERR("copy_to_user() error!\n");
+		return -EFAULT;
+	}
+	buf += cnt;
+	len += cnt;
+
+	NVT_LOG("--\n");
+	return len;
+}
+
+static ssize_t nvt_charger_switch_proc_write(struct file *filp,const char __user *buf, size_t count, loff_t *f_pos)
+{
+	int32_t ret;
+	int32_t tmp;
+	uint8_t charger_switch;
+	char *tmp_buf;
+
+	NVT_LOG("++\n");
+
+	if (count == 0 || count > 2) {
+		NVT_ERR("Invalid value!, count = %zu\n", count);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	tmp_buf = kzalloc(count, GFP_KERNEL);
+	if (!tmp_buf) {
+		NVT_ERR("Allocate tmp_buf fail!\n");
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (copy_from_user(tmp_buf, buf, count)) {
+		NVT_ERR("copy_from_user() error!\n");
+		ret =  -EFAULT;
+		goto out;
+	}
+	ret = sscanf(tmp_buf, "%d", &tmp);
+	if (ret != 1) {
+		NVT_ERR("Invalid value!, ret = %d\n", ret);
+		ret = -EINVAL;
+		goto out;
+	}
+	if ((tmp < 0) || (tmp > 1)) {
+		NVT_ERR("Invalid value!, tmp = %d\n", tmp);
+		ret = -EINVAL;
+		goto out;
+	}
+	charger_switch = (uint8_t)tmp;
+	NVT_LOG("charger_switch = %d\n", charger_switch);
+
+	if (mutex_lock_interruptible(&ts->lock)) {
+		return -ERESTARTSYS;
+	}
+
+#if NVT_TOUCH_ESD_PROTECT
+	nvt_esd_check_enable(false);
+#endif /* #if NVT_TOUCH_ESD_PROTECT */
+
+	nvt_set_charger_switch(charger_switch);
+
+	mutex_unlock(&ts->lock);
+
+	ret = count;
+out:
+	kfree(tmp_buf);
+	NVT_LOG("--\n");
+	return ret;
+}
+
+static const struct file_operations nvt_charger_switch_fops = {
+	.owner = THIS_MODULE,
+	.read = nvt_charger_switch_proc_read,
+	.write = nvt_charger_switch_proc_write,
+};
+/*******************************************************
+Description:
+	Novatek touchscreen extra function proc. file node
+	initial function.
+
+return:
+	Executive outcomes. 0---succeed. -12---failed.
+*******************************************************/
+int32_t nvt_extra_proc_init(void)
+{
+#if 0
+	NVT_proc_fw_version_entry = proc_create(NVT_FW_VERSION, 0444, NULL,&nvt_fw_version_fops);
+	if (NVT_proc_fw_version_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_FW_VERSION);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_FW_VERSION);
+	}
+
+	NVT_proc_baseline_entry = proc_create(NVT_BASELINE, 0444, NULL,&nvt_baseline_fops);
+	if (NVT_proc_baseline_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_BASELINE);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_BASELINE);
+	}
+
+	NVT_proc_raw_entry = proc_create(NVT_RAW, 0444, NULL,&nvt_raw_fops);
+	if (NVT_proc_raw_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_RAW);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_RAW);
+	}
+
+	NVT_proc_diff_entry = proc_create(NVT_DIFF, 0444, NULL,&nvt_diff_fops);
+	if (NVT_proc_diff_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_DIFF);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_DIFF);
+	}
+/*function description*/
+	NVT_proc_pf_switch_entry = proc_create(NVT_PF_SWITCH, 0666, NULL,&nvt_pf_switch_fops);
+	if (NVT_proc_pf_switch_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_PF_SWITCH);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_PF_SWITCH);
+	}
+
+	NVT_proc_sensitivity_switch_entry = proc_create(NVT_SENSITIVITY_SWITCH, 0666, NULL,&nvt_sensitivity_switch_fops);
+	if (NVT_proc_sensitivity_switch_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_SENSITIVITY_SWITCH);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_SENSITIVITY_SWITCH);
+	}
+
+	NVT_proc_er_range_switch_entry = proc_create(NVT_ER_RANGE_SWITCH, 0666, NULL,&nvt_er_range_switch_fops);
+	if (NVT_proc_er_range_switch_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_ER_RANGE_SWITCH);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_ER_RANGE_SWITCH);
+	}
+
+	NVT_proc_max_power_switch_entry = proc_create(NVT_MAX_POWER_SWITCH, 0666, NULL,&nvt_max_power_switch_fops);
+	if (NVT_proc_max_power_switch_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_MAX_POWER_SWITCH);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_MAX_POWER_SWITCH);
+	}
+
+	NVT_proc_edge_reject_switch_entry = proc_create(NVT_EDGE_REJECT_SWITCH, 0666, NULL,&nvt_edge_reject_switch_fops);
+	if (NVT_proc_edge_reject_switch_entry == NULL) {
+		NVT_ERR("create proc/%s Failed!\n", NVT_EDGE_REJECT_SWITCH);
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/%s Succeeded!\n", NVT_EDGE_REJECT_SWITCH);
+	}
+
+	NVT_proc_pocket_palm_switch_entry = proc_create(NVT_POCKET_PALM_SWITCH, 0666, NULL,&nvt_pocket_palm_switch_fops);
+	if (NVT_proc_pocket_palm_switch_entry == NULL) {
+		NVT_ERR("create proc/nvt_pocket_palm_switch Failed!\n");
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/nvt_pocket_palm_switch Succeeded!\n");
+	}
+
+	NVT_proc_charger_switch_entry = proc_create(NVT_CHARGER_SWITCH, 0666, NULL,&nvt_charger_switch_fops);
+	if (NVT_proc_charger_switch_entry == NULL) {
+		NVT_ERR("create proc/nvt_charger_switch Failed!\n");
+		return -ENOMEM;
+	} else {
+		NVT_LOG("create proc/nvt_charger_switch Succeeded!\n");
+	}
+#endif
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen extra function proc. file node
+	deinitial function.
+
+return:
+	n.a.
+*******************************************************/
+void nvt_extra_proc_deinit(void)
+{
+	if (NVT_proc_fw_version_entry != NULL) {
+		remove_proc_entry(NVT_FW_VERSION, NULL);
+		NVT_proc_fw_version_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_FW_VERSION);
+	}
+
+	if (NVT_proc_baseline_entry != NULL) {
+		remove_proc_entry(NVT_BASELINE, NULL);
+		NVT_proc_baseline_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_BASELINE);
+	}
+
+	if (NVT_proc_raw_entry != NULL) {
+		remove_proc_entry(NVT_RAW, NULL);
+		NVT_proc_raw_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_RAW);
+	}
+
+	if (NVT_proc_diff_entry != NULL) {
+		remove_proc_entry(NVT_DIFF, NULL);
+		NVT_proc_diff_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_DIFF);
+	}
+
+/*function description*/
+	if (NVT_proc_pf_switch_entry != NULL) {
+		remove_proc_entry(NVT_PF_SWITCH, NULL);
+		NVT_proc_pf_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_PF_SWITCH);
+	}
+
+	if (NVT_proc_sensitivity_switch_entry != NULL) {
+		remove_proc_entry(NVT_SENSITIVITY_SWITCH, NULL);
+		NVT_proc_sensitivity_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_SENSITIVITY_SWITCH);
+	}
+
+	if (NVT_proc_er_range_switch_entry != NULL) {
+		remove_proc_entry(NVT_ER_RANGE_SWITCH, NULL);
+		NVT_proc_er_range_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_ER_RANGE_SWITCH);
+	}
+
+	if (NVT_proc_max_power_switch_entry != NULL) {
+		remove_proc_entry(NVT_MAX_POWER_SWITCH, NULL);
+		NVT_proc_max_power_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_MAX_POWER_SWITCH);
+	}
+
+	if (NVT_proc_edge_reject_switch_entry != NULL) {
+		remove_proc_entry(NVT_EDGE_REJECT_SWITCH, NULL);
+		NVT_proc_edge_reject_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_EDGE_REJECT_SWITCH);
+	}
+
+	if (NVT_proc_pocket_palm_switch_entry != NULL) {
+		remove_proc_entry(NVT_POCKET_PALM_SWITCH, NULL);
+		NVT_proc_pocket_palm_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_POCKET_PALM_SWITCH);
+	}
+
+	if (NVT_proc_charger_switch_entry != NULL) {
+		remove_proc_entry(NVT_CHARGER_SWITCH, NULL);
+		NVT_proc_charger_switch_entry = NULL;
+		NVT_LOG("Removed /proc/%s\n", NVT_CHARGER_SWITCH);
+	}
+}
+#endif
diff --git a/drivers/input/touchscreen/nt36xxx_spi/nt36xxx_fw_update.c b/drivers/input/touchscreen/nt36xxx_spi/nt36xxx_fw_update.c
new file mode 100644
index 000000000000..83cecf3a74e0
--- /dev/null
+++ b/drivers/input/touchscreen/nt36xxx_spi/nt36xxx_fw_update.c
@@ -0,0 +1,951 @@
+/*
+ * Copyright (C) 2010 - 2018 Novatek, Inc.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ *
+ * $Revision: 43560 $
+ * $Date: 2019-04-19 11:34:19 +0800 (週五, 19 四月 2019) $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/firmware.h>
+#include <linux/gpio.h>
+
+#include "nt36xxx.h"
+
+#if BOOT_UPDATE_FIRMWARE
+
+#define SIZE_4KB 4096
+#define FLASH_SECTOR_SIZE SIZE_4KB
+#define FW_BIN_VER_OFFSET (fw_need_write_size - SIZE_4KB)
+#define FW_BIN_VER_BAR_OFFSET (FW_BIN_VER_OFFSET + 1)
+#define NVT_FLASH_END_FLAG_LEN 3
+#define NVT_FLASH_END_FLAG_ADDR (fw_need_write_size - NVT_FLASH_END_FLAG_LEN)
+
+#define NVT_DUMP_PARTITION      (0)
+#define NVT_DUMP_PARTITION_LEN  (1024)
+#define NVT_DUMP_PARTITION_PATH "/data/local/tmp"
+
+#if NVT_USB_PLUGIN
+extern touchscreen_usb_plugin_data_t g_touchscreen_usb_pulgin;
+#endif
+
+//struct timeval start, end;
+const struct firmware *fw_entry = NULL;
+static size_t fw_need_write_size = 0;
+static uint8_t *fwbuf = NULL;
+
+struct nvt_ts_bin_map {
+	char name[12];
+	uint32_t BIN_addr;
+	uint32_t SRAM_addr;
+	uint32_t size;
+	uint32_t crc;
+};
+
+static struct nvt_ts_bin_map *bin_map;
+
+static int32_t nvt_get_fw_need_write_size(const struct firmware *fw_entry)
+{
+	int32_t i = 0;
+	int32_t total_sectors_to_check = 0;
+
+	total_sectors_to_check = fw_entry->size / FLASH_SECTOR_SIZE;
+	/* printk("total_sectors_to_check = %d\n", total_sectors_to_check); */
+
+	for (i = total_sectors_to_check; i > 0; i--) {
+		/* printk("current end flag address checked = 0x%X\n", i * FLASH_SECTOR_SIZE - NVT_FLASH_END_FLAG_LEN); */
+		/* check if there is end flag "NVT" at the end of this sector */
+		if (strncmp(&fw_entry->data[i * FLASH_SECTOR_SIZE - NVT_FLASH_END_FLAG_LEN], "NVT", NVT_FLASH_END_FLAG_LEN) == 0) {
+			fw_need_write_size = i * FLASH_SECTOR_SIZE;
+			NVT_LOG("fw_need_write_size = %zu(0x%zx), NVT end flag\n", fw_need_write_size, fw_need_write_size);
+			return 0;
+		}
+
+		/* check if there is end flag "MOD" at the end of this sector */
+		if (strncmp(&fw_entry->data[i * FLASH_SECTOR_SIZE - NVT_FLASH_END_FLAG_LEN], "MOD", NVT_FLASH_END_FLAG_LEN) == 0) {
+			fw_need_write_size = i * FLASH_SECTOR_SIZE;
+			NVT_LOG("fw_need_write_size = %zu(0x%zx), MOD end flag\n", fw_need_write_size, fw_need_write_size);
+			return 0;
+		}
+	}
+
+	NVT_ERR("end flag \"NVT\" \"MOD\" not found!\n");
+	return -1;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen init variable and allocate buffer
+for download firmware function.
+
+return:
+	n.a.
+*******************************************************/
+static int32_t nvt_download_init(void)
+{
+	/* allocate buffer for transfer firmware */
+	//NVT_LOG("NVT_TRANSFER_LEN = 0x%06X\n", NVT_TRANSFER_LEN);
+
+	if (fwbuf == NULL) {
+		fwbuf = (uint8_t *)kzalloc((NVT_TRANSFER_LEN+1), GFP_KERNEL);
+		if(fwbuf == NULL) {
+			NVT_ERR("kzalloc for fwbuf failed!\n");
+			return -ENOMEM;
+		}
+	}
+
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen checksum function. Calculate bin
+file checksum for comparison.
+
+return:
+	n.a.
+*******************************************************/
+static uint32_t CheckSum(const u8 *data, size_t len)
+{
+	uint32_t i = 0;
+	uint32_t checksum = 0;
+
+	for (i = 0 ; i < len+1 ; i++)
+		checksum += data[i];
+
+	checksum += len;
+	checksum = ~checksum +1;
+
+	return checksum;
+}
+
+static uint32_t byte_to_word(const uint8_t *data)
+{
+	return data[0] + (data[1] << 8) + (data[2] << 16) + (data[3] << 24);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen parsing bin header function.
+
+return:
+	n.a.
+*******************************************************/
+static uint32_t partition = 0;
+static uint8_t ilm_dlm_num = 2;
+static int32_t nvt_bin_header_parser(const u8 *fwdata, size_t fwsize)
+{
+	uint32_t list = 0;
+	uint32_t pos = 0x00;
+	uint32_t end = 0x00;
+	uint8_t info_sec_num = 0;
+	uint8_t ovly_sec_num = 0;
+	uint8_t ovly_info = 0;
+
+	/* Find the header size */
+	end = fwdata[0] + (fwdata[1] << 8) + (fwdata[2] << 16) + (fwdata[3] << 24);
+	pos = 0x30;	// info section start at 0x30 offset
+	while (pos < end) {
+		info_sec_num ++;
+		pos += 0x10;	/* each header info is 16 bytes */
+	}
+
+	/*
+	 * Find the DLM OVLY section
+	 * [0:3] Overlay Section Number
+	 * [4]   Overlay Info
+	 */
+	ovly_info = (fwdata[0x28] & 0x10) >> 4;
+	ovly_sec_num = (ovly_info) ? (fwdata[0x28] & 0x0F) : 0;
+
+	/*
+	 * calculate all partition number
+	 * ilm_dlm_num (ILM & DLM) + ovly_sec_num + info_sec_num
+	 */
+	partition = ilm_dlm_num + ovly_sec_num + info_sec_num;
+	NVT_LOG("ovly_info = %d, ilm_dlm_num = %d, ovly_sec_num = %d, info_sec_num = %d, partition = %d\n",
+			ovly_info, ilm_dlm_num, ovly_sec_num, info_sec_num, partition);
+
+	/* allocated memory for header info */
+	bin_map = (struct nvt_ts_bin_map *)kzalloc((partition+1) * sizeof(struct nvt_ts_bin_map), GFP_KERNEL);
+	if(bin_map == NULL) {
+		NVT_ERR("kzalloc for bin_map failed!\n");
+		return -ENOMEM;
+	}
+
+	for (list = 0; list < partition; list++) {
+		/*
+		 * [1] parsing ILM & DLM header info
+		 * BIN_addr : SRAM_addr : size (12-bytes)
+		 * crc located at 0x18 & 0x1C
+		 */
+		if (list < ilm_dlm_num) {
+			bin_map[list].BIN_addr = byte_to_word(&fwdata[0 + list*12]);
+			bin_map[list].SRAM_addr = byte_to_word(&fwdata[4 + list*12]);
+			bin_map[list].size = byte_to_word(&fwdata[8 + list*12]);
+			if (ts->hw_crc)
+				bin_map[list].crc = byte_to_word(&fwdata[0x18 + list*4]);
+			else { //ts->hw_crc
+				if ((bin_map[list].BIN_addr + bin_map[list].size) < fwsize)
+					bin_map[list].crc = CheckSum(&fwdata[bin_map[list].BIN_addr], bin_map[list].size);
+				else {
+					NVT_ERR("access range (0x%08X to 0x%08X) is larger than bin size!\n",
+							bin_map[list].BIN_addr, bin_map[list].BIN_addr + bin_map[list].size);
+					return -EINVAL;
+				}
+			} //ts->hw_crc
+			if (list == 0)
+				sprintf(bin_map[list].name, "ILM");
+			else if (list == 1)
+				sprintf(bin_map[list].name, "DLM");
+		}
+
+		/*
+		 * [2] parsing others header info
+		 * SRAM_addr : size : BIN_addr : crc (16-bytes)
+		 */
+		if ((list >= ilm_dlm_num) && (list < (ilm_dlm_num + info_sec_num))) {
+			/* others partition located at 0x30 offset */
+			pos = 0x30 + (0x10 * (list - ilm_dlm_num));
+
+			bin_map[list].SRAM_addr = byte_to_word(&fwdata[pos]);
+			bin_map[list].size = byte_to_word(&fwdata[pos+4]);
+			bin_map[list].BIN_addr = byte_to_word(&fwdata[pos+8]);
+			if (ts->hw_crc)
+				bin_map[list].crc = byte_to_word(&fwdata[pos+12]);
+			else { //ts->hw_crc
+				if ((bin_map[list].BIN_addr + bin_map[list].size) < fwsize)
+					bin_map[list].crc = CheckSum(&fwdata[bin_map[list].BIN_addr], bin_map[list].size);
+				else {
+					NVT_ERR("access range (0x%08X to 0x%08X) is larger than bin size!\n",
+							bin_map[list].BIN_addr, bin_map[list].BIN_addr + bin_map[list].size);
+					return -EINVAL;
+				}
+			} //ts->hw_crc
+			/* detect header end to protect parser function */
+			if ((bin_map[list].BIN_addr == 0) && (bin_map[list].size != 0)) {
+				sprintf(bin_map[list].name, "Header");
+			} else {
+				sprintf(bin_map[list].name, "Info-%d", (list - ilm_dlm_num));
+			}
+		}
+
+		/*
+		 * [3] parsing overlay section header info
+		 * SRAM_addr : size : BIN_addr : crc (16-bytes)
+		 */
+		if (list >= (ilm_dlm_num + info_sec_num)) {
+			/* overlay info located at DLM (list = 1) start addr */
+			pos = bin_map[1].BIN_addr + (0x10 * (list- ilm_dlm_num - info_sec_num));
+
+			bin_map[list].SRAM_addr = byte_to_word(&fwdata[pos]);
+			bin_map[list].size = byte_to_word(&fwdata[pos+4]);
+			bin_map[list].BIN_addr = byte_to_word(&fwdata[pos+8]);
+			if (ts->hw_crc)
+				bin_map[list].crc = byte_to_word(&fwdata[pos+12]);
+			else { //ts->hw_crc
+				if ((bin_map[list].BIN_addr + bin_map[list].size) < fwsize)
+					bin_map[list].crc = CheckSum(&fwdata[bin_map[list].BIN_addr], bin_map[list].size);
+				else {
+					NVT_ERR("access range (0x%08X to 0x%08X) is larger than bin size!\n",
+							bin_map[list].BIN_addr, bin_map[list].BIN_addr + bin_map[list].size);
+					return -EINVAL;
+				}
+			} //ts->hw_crc
+			sprintf(bin_map[list].name, "Overlay-%d", (list- ilm_dlm_num - info_sec_num));
+		}
+
+		/* BIN size error detect */
+		if ((bin_map[list].BIN_addr + bin_map[list].size) > fwsize) {
+			NVT_ERR("access range (0x%08X to 0x%08X) is larger than bin size!\n",
+					bin_map[list].BIN_addr, bin_map[list].BIN_addr + bin_map[list].size);
+			return -EINVAL;
+		}
+
+//		NVT_LOG("[%d][%s] SRAM (0x%08X), SIZE (0x%08X), BIN (0x%08X), CRC (0x%08X)\n",
+//				list, bin_map[list].name,
+//				bin_map[list].SRAM_addr, bin_map[list].size,  bin_map[list].BIN_addr, bin_map[list].crc);
+	}
+
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen release update firmware function.
+
+return:
+	n.a.
+*******************************************************/
+static void update_firmware_release(void)
+{
+	if (fw_entry) {
+		release_firmware(fw_entry);
+	}
+
+	fw_entry = NULL;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen request update firmware function.
+
+return:
+	Executive outcomes. 0---succeed. -1,-22---failed.
+*******************************************************/
+static int32_t update_firmware_request(char *filename)
+{
+	uint8_t retry = 0;
+	int32_t ret = 0;
+
+	if (NULL == filename) {
+		return -ENOENT;
+	}
+
+	while (1) {
+		NVT_LOG("filename is %s\n", filename);
+
+		ret = request_firmware(&fw_entry, filename, &ts->client->dev);
+		if (ret) {
+			NVT_ERR("firmware load failed, ret=%d\n", ret);
+			goto request_fail;
+		}
+
+		// check FW need to write size
+		if (nvt_get_fw_need_write_size(fw_entry)) {
+			NVT_ERR("get fw need to write size fail!\n");
+			ret = -EINVAL;
+			goto invalid;
+		}
+
+		// check if FW version add FW version bar equals 0xFF
+		if (*(fw_entry->data + FW_BIN_VER_OFFSET) + *(fw_entry->data + FW_BIN_VER_BAR_OFFSET) != 0xFF) {
+			NVT_ERR("bin file FW_VER + FW_VER_BAR should be 0xFF!\n");
+			NVT_ERR("FW_VER=0x%02X, FW_VER_BAR=0x%02X\n", *(fw_entry->data+FW_BIN_VER_OFFSET), *(fw_entry->data+FW_BIN_VER_BAR_OFFSET));
+			ret = -ENOEXEC;
+			goto invalid;
+		}
+
+		/* BIN Header Parser */
+		ret = nvt_bin_header_parser(fw_entry->data, fw_entry->size);
+		if (ret) {
+			NVT_ERR("bin header parser failed\n");
+			goto invalid;
+		} else {
+			break;
+		}
+
+invalid:
+		update_firmware_release();
+		if (!IS_ERR_OR_NULL(bin_map)) {
+			kfree(bin_map);
+			bin_map = NULL;
+		}
+
+request_fail:
+		retry++;
+		if(unlikely(retry > 2)) {
+			NVT_ERR("error, retry=%d\n", retry);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+#if NVT_DUMP_PARTITION
+/*******************************************************
+Description:
+	Novatek touchscreen dump flash partition function.
+
+return:
+	n.a.
+*******************************************************/
+loff_t file_offset = 0;
+static int32_t nvt_read_ram_and_save_file(uint32_t addr, uint16_t len, char *name)
+{
+	char file[256] = "";
+	uint8_t *fbufp = NULL;
+	int32_t ret = 0;
+	struct file *fp = NULL;
+	mm_segment_t org_fs;
+
+	sprintf(file, "%s/dump_%s.bin", NVT_DUMP_PARTITION_PATH, name);
+	NVT_LOG("Dump [%s] from 0x%08X to 0x%08X\n", file, addr, addr+len);
+
+	fbufp = (uint8_t *)kzalloc(len+1, GFP_KERNEL);
+	if(fbufp == NULL) {
+		NVT_ERR("kzalloc for fbufp failed!\n");
+		ret = -ENOMEM;
+		goto alloc_buf_fail;
+	}
+
+	org_fs = get_fs();
+	set_fs(KERNEL_DS);
+	fp = filp_open(file, O_RDWR | O_CREAT, 0644);
+	if (fp == NULL || IS_ERR(fp)) {
+		ret = -ENOMEM;
+		NVT_ERR("open file failed\n");
+		goto open_file_fail;
+	}
+
+	/* SPI read */
+	//---set xdata index to addr---
+	nvt_set_page(addr);
+
+	fbufp[0] = addr & 0x7F;	//offset
+	CTP_SPI_READ(ts->client, fbufp, len+1);
+
+	/* Write to file */
+	ret = vfs_write(fp, (char __user *)fbufp+1, len, &file_offset);
+	if (ret != len) {
+		NVT_ERR("write file failed\n");
+		goto open_file_fail;
+	} else {
+		ret = 0;
+	}
+
+open_file_fail:
+	set_fs(org_fs);
+	if (!IS_ERR_OR_NULL(fp)) {
+		filp_close(fp, NULL);
+		fp = NULL;
+	}
+
+	if (!IS_ERR_OR_NULL(fbufp)) {
+		kfree(fbufp);
+		fbufp = NULL;
+	}
+alloc_buf_fail:
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen nvt_dump_partition function to dump
+ each partition for debug.
+
+return:
+	n.a.
+*******************************************************/
+static int32_t nvt_dump_partition(void)
+{
+	uint32_t list = 0;
+	char *name;
+	uint32_t SRAM_addr, size;
+	uint32_t i = 0;
+	uint16_t len = 0;
+	int32_t count = 0;
+	int32_t ret = 0;
+
+	if (NVT_DUMP_PARTITION_LEN >= sizeof(ts->rbuf)) {
+		NVT_ERR("dump len %d is larger than buffer size %ld\n",
+				NVT_DUMP_PARTITION_LEN, sizeof(ts->rbuf));
+		return -EINVAL;
+	} else if (NVT_DUMP_PARTITION_LEN >= NVT_TRANSFER_LEN) {
+		NVT_ERR("dump len %d is larger than NVT_TRANSFER_LEN\n", NVT_DUMP_PARTITION_LEN);
+		return -EINVAL;
+	}
+
+	if (bin_map == NULL) {
+		NVT_ERR("bin_map is NULL\n");
+		return -ENOMEM;
+	}
+
+	memset(fwbuf, 0, (NVT_DUMP_PARTITION_LEN+1));
+
+	for (list = 0; list < partition; list++) {
+		/* initialize variable */
+		SRAM_addr = bin_map[list].SRAM_addr;
+		size = bin_map[list].size;
+		name = bin_map[list].name;
+
+		/* ignore reserved partition (Reserved Partition size is zero) */
+		if (!size)
+			continue;
+		else
+			size = size +1;
+
+		/* write data to SRAM */
+		if (size % NVT_DUMP_PARTITION_LEN)
+			count = (size / NVT_DUMP_PARTITION_LEN) + 1;
+		else
+			count = (size / NVT_DUMP_PARTITION_LEN);
+
+		for (i = 0 ; i < count ; i++) {
+			len = (size < NVT_DUMP_PARTITION_LEN) ? size : NVT_DUMP_PARTITION_LEN;
+
+			/* dump for debug download firmware */
+			ret = nvt_read_ram_and_save_file(SRAM_addr, len, name);
+			if (ret < 0) {
+				NVT_ERR("nvt_read_ram_and_save_file failed, ret = %d\n", ret);
+				goto out;
+			}
+
+			SRAM_addr += NVT_DUMP_PARTITION_LEN;
+			size -= NVT_DUMP_PARTITION_LEN;
+		}
+
+		file_offset = 0;
+	}
+
+out:
+	return ret;
+}
+#endif /* NVT_DUMP_PARTITION */
+
+/*******************************************************
+Description:
+	Novatek touchscreen write data to sram function.
+
+- fwdata   : The buffer is written
+- SRAM_addr: The sram destination address
+- size     : Number of data bytes in @fwdata being written
+- BIN_addr : The transferred data offset of @fwdata
+
+return:
+	Executive outcomes. 0---succeed. else---fail.
+*******************************************************/
+static int32_t nvt_write_sram(const u8 *fwdata,
+		uint32_t SRAM_addr, uint32_t size, uint32_t BIN_addr)
+{
+	int32_t ret = 0;
+	uint32_t i = 0;
+	uint16_t len = 0;
+	int32_t count = 0;
+
+	if (size % NVT_TRANSFER_LEN)
+		count = (size / NVT_TRANSFER_LEN) + 1;
+	else
+		count = (size / NVT_TRANSFER_LEN);
+
+	for (i = 0 ; i < count ; i++) {
+		len = (size < NVT_TRANSFER_LEN) ? size : NVT_TRANSFER_LEN;
+
+		//---set xdata index to start address of SRAM---
+		ret = nvt_set_page(SRAM_addr);
+		if (ret) {
+			NVT_ERR("set page failed, ret = %d\n", ret);
+			return ret;
+		}
+
+		//---write data into SRAM---
+		fwbuf[0] = SRAM_addr & 0x7F;	//offset
+		memcpy(fwbuf+1, &fwdata[BIN_addr], len);	//payload
+		ret = CTP_SPI_WRITE(ts->client, fwbuf, len+1);
+		if (ret) {
+			NVT_ERR("write to sram failed, ret = %d\n", ret);
+			return ret;
+		}
+
+		SRAM_addr += NVT_TRANSFER_LEN;
+		BIN_addr += NVT_TRANSFER_LEN;
+		size -= NVT_TRANSFER_LEN;
+	}
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen nvt_write_firmware function to write
+firmware into each partition.
+
+return:
+	n.a.
+*******************************************************/
+static int32_t nvt_write_firmware(const u8 *fwdata, size_t fwsize)
+{
+	uint32_t list = 0;
+	char *name;
+	uint32_t BIN_addr, SRAM_addr, size;
+	int32_t ret = 0;
+
+	memset(fwbuf, 0, (NVT_TRANSFER_LEN+1));
+
+	for (list = 0; list < partition; list++) {
+		/* initialize variable */
+		SRAM_addr = bin_map[list].SRAM_addr;
+		size = bin_map[list].size;
+		BIN_addr = bin_map[list].BIN_addr;
+		name = bin_map[list].name;
+
+//		NVT_LOG("[%d][%s] SRAM (0x%08X), SIZE (0x%08X), BIN (0x%08X)\n",
+//				list, name, SRAM_addr, size, BIN_addr);
+
+		/* Check data size */
+		if ((BIN_addr + size) > fwsize) {
+			NVT_ERR("access range (0x%08X to 0x%08X) is larger than bin size!\n",
+					BIN_addr, BIN_addr + size);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		/* ignore reserved partition (Reserved Partition size is zero) */
+		if (!size)
+			continue;
+		else
+			size = size +1;
+
+		/* write data to SRAM */
+		ret = nvt_write_sram(fwdata, SRAM_addr, size, BIN_addr);
+		if (ret) {
+			NVT_ERR("sram program failed, ret = %d\n", ret);
+			goto out;
+		}
+	}
+
+out:
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen check checksum function.
+This function will compare file checksum and fw checksum.
+
+return:
+	n.a.
+*******************************************************/
+static int32_t nvt_check_fw_checksum(void)
+{
+	uint32_t fw_checksum = 0;
+	uint32_t len = partition*4;
+	uint32_t list = 0;
+	int32_t ret = 0;
+
+	memset(fwbuf, 0, (len+1));
+
+	//---set xdata index to checksum---
+	nvt_set_page(ts->mmap->R_ILM_CHECKSUM_ADDR);
+
+	/* read checksum */
+	fwbuf[0] = (ts->mmap->R_ILM_CHECKSUM_ADDR) & 0x7F;
+	ret = CTP_SPI_READ(ts->client, fwbuf, len+1);
+	if (ret) {
+		NVT_ERR("Read fw checksum failed\n");
+		return ret;
+	}
+
+	/*
+	 * Compare each checksum from fw
+	 * ILM + DLM + Overlay + Info
+	 * ilm_dlm_num (ILM & DLM) + ovly_sec_num + info_sec_num
+	 */
+	for (list = 0; list < partition; list++) {
+		fw_checksum = byte_to_word(&fwbuf[1+list*4]);
+
+		/* ignore reserved partition (Reserved Partition size is zero) */
+		if(!bin_map[list].size)
+			continue;
+
+		if (bin_map[list].crc != fw_checksum) {
+			NVT_ERR("[%d] BIN_checksum=0x%08X, FW_checksum=0x%08X\n",
+					list, bin_map[list].crc, fw_checksum);
+			ret = -EIO;
+		}
+	}
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen set bootload crc reg bank function.
+This function will set hw crc reg before enable crc function.
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_set_bld_crc_bank(uint32_t DES_ADDR, uint32_t SRAM_ADDR,
+		uint32_t LENGTH_ADDR, uint32_t size,
+		uint32_t G_CHECKSUM_ADDR, uint32_t crc)
+{
+	/* write destination address */
+	nvt_set_page(DES_ADDR);
+	fwbuf[0] = DES_ADDR & 0x7F;
+	fwbuf[1] = (SRAM_ADDR) & 0xFF;
+	fwbuf[2] = (SRAM_ADDR >> 8) & 0xFF;
+	fwbuf[3] = (SRAM_ADDR >> 16) & 0xFF;
+	CTP_SPI_WRITE(ts->client, fwbuf, 4);
+
+	/* write length */
+	//nvt_set_page(LENGTH_ADDR);
+	fwbuf[0] = LENGTH_ADDR & 0x7F;
+	fwbuf[1] = (size) & 0xFF;
+	fwbuf[2] = (size >> 8) & 0xFF;
+	fwbuf[3] = (size >> 16) & 0x01;
+	if (ts->hw_crc == 1) {
+		CTP_SPI_WRITE(ts->client, fwbuf, 3);
+	} else if (ts->hw_crc > 1) {
+		CTP_SPI_WRITE(ts->client, fwbuf, 4);
+	}
+
+	/* write golden dlm checksum */
+	//nvt_set_page(G_CHECKSUM_ADDR);
+	fwbuf[0] = G_CHECKSUM_ADDR & 0x7F;
+	fwbuf[1] = (crc) & 0xFF;
+	fwbuf[2] = (crc >> 8) & 0xFF;
+	fwbuf[3] = (crc >> 16) & 0xFF;
+	fwbuf[4] = (crc >> 24) & 0xFF;
+	CTP_SPI_WRITE(ts->client, fwbuf, 5);
+
+	return;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen set BLD hw crc function.
+This function will set ILM and DLM crc information to register.
+
+return:
+	n.a.
+*******************************************************/
+static void nvt_set_bld_hw_crc(void)
+{
+	/* [0] ILM */
+	/* write register bank */
+	nvt_set_bld_crc_bank(ts->mmap->ILM_DES_ADDR, bin_map[0].SRAM_addr,
+			ts->mmap->ILM_LENGTH_ADDR, bin_map[0].size,
+			ts->mmap->G_ILM_CHECKSUM_ADDR, bin_map[0].crc);
+
+	/* [1] DLM */
+	/* write register bank */
+	nvt_set_bld_crc_bank(ts->mmap->DLM_DES_ADDR, bin_map[1].SRAM_addr,
+			ts->mmap->DLM_LENGTH_ADDR, bin_map[1].size,
+			ts->mmap->G_DLM_CHECKSUM_ADDR, bin_map[1].crc);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen Download_Firmware with HW CRC
+function. It's complete download firmware flow.
+
+return:
+	Executive outcomes. 0---succeed. else---fail.
+*******************************************************/
+static int32_t nvt_download_firmware_hw_crc(void)
+{
+	uint8_t retry = 0;
+	int32_t ret = 0;
+
+//	do_gettimeofday(&start);
+
+	while (1) {
+		/* bootloader reset to reset MCU */
+		nvt_bootloader_reset();
+
+		/* Start to write firmware process */
+		ret = nvt_write_firmware(fw_entry->data, fw_entry->size);
+		if (ret) {
+			NVT_ERR("Write_Firmware failed. (%d)\n", ret);
+			goto fail;
+		}
+
+#if NVT_DUMP_PARTITION
+		ret = nvt_dump_partition();
+		if (ret) {
+			NVT_ERR("nvt_dump_partition failed, ret = %d\n", ret);
+		}
+#endif
+
+		/* set ilm & dlm reg bank */
+		nvt_set_bld_hw_crc();
+
+		/* enable hw bld crc function */
+		nvt_bld_crc_enable();
+
+		/* clear fw reset status & enable fw crc check */
+		nvt_fw_crc_enable();
+
+		/* Set Boot Ready Bit */
+		nvt_boot_ready();
+
+		ret = nvt_check_fw_reset_state(RESET_STATE_INIT);
+		if (ret) {
+			NVT_ERR("nvt_check_fw_reset_state failed. (%d)\n", ret);
+			goto fail;
+		} else {
+			break;
+		}
+
+fail:
+		retry++;
+		if(unlikely(retry > 2)) {
+			NVT_ERR("error, retry=%d\n", retry);
+			break;
+		}
+	}
+
+//	do_gettimeofday(&end);
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen Download_Firmware function. It's
+complete download firmware flow.
+
+return:
+	n.a.
+*******************************************************/
+static int32_t nvt_download_firmware(void)
+{
+	uint8_t retry = 0;
+	int32_t ret = 0;
+
+//	do_gettimeofday(&start);
+
+	while (1) {
+		/*
+		 * Send eng reset cmd before download FW
+		 * Keep TP_RESX low when send eng reset cmd
+		 */
+#if NVT_TOUCH_SUPPORT_HW_RST
+		gpio_set_value(ts->reset_gpio, 0);
+		mdelay(1);	//wait 1ms
+#endif
+		nvt_eng_reset();
+#if NVT_TOUCH_SUPPORT_HW_RST
+		gpio_set_value(ts->reset_gpio, 1);
+		mdelay(10);	//wait tRT2BRST after TP_RST
+#endif
+		nvt_bootloader_reset();
+
+		/* clear fw reset status */
+		nvt_write_addr(ts->mmap->EVENT_BUF_ADDR | EVENT_MAP_RESET_COMPLETE, 0x00);
+
+		/* Start to write firmware process */
+		ret = nvt_write_firmware(fw_entry->data, fw_entry->size);
+		if (ret) {
+			NVT_ERR("Write_Firmware failed. (%d)\n", ret);
+			goto fail;
+		}
+
+#if NVT_DUMP_PARTITION
+		ret = nvt_dump_partition();
+		if (ret) {
+			NVT_ERR("nvt_dump_partition failed, ret = %d\n", ret);
+		}
+#endif
+
+		/* Set Boot Ready Bit */
+		nvt_boot_ready();
+
+		ret = nvt_check_fw_reset_state(RESET_STATE_INIT);
+		if (ret) {
+			NVT_ERR("nvt_check_fw_reset_state failed. (%d)\n", ret);
+			goto fail;
+		}
+
+		/* check fw checksum result */
+		ret = nvt_check_fw_checksum();
+		if (ret) {
+			NVT_ERR("firmware checksum not match, retry=%d\n", retry);
+			goto fail;
+		} else {
+			break;
+		}
+
+fail:
+		retry++;
+		if(unlikely(retry > 2)) {
+			NVT_ERR("error, retry=%d\n", retry);
+			break;
+		}
+	}
+
+//	do_gettimeofday(&end);
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen update firmware main function.
+
+return:
+	n.a.
+*******************************************************/
+int32_t nvt_update_firmware(char *firmware_name)
+{
+	int32_t ret = 0;
+
+	// request bin file in "/vendor/firmware"
+	ret = update_firmware_request(firmware_name);
+	if (ret) {
+		NVT_ERR("update_firmware_request failed. (%d)\n", ret);
+		goto request_firmware_fail;
+	}
+
+	/* initial buffer and variable */
+	ret = nvt_download_init();
+	if (ret) {
+		NVT_ERR("Download Init failed. (%d)\n", ret);
+		goto download_fail;
+	}
+
+	/* download firmware process */
+	if (ts->hw_crc)
+		ret = nvt_download_firmware_hw_crc();
+	else
+		ret = nvt_download_firmware();
+	if (ret) {
+		NVT_ERR("Download Firmware failed. (%d)\n", ret);
+		goto download_fail;
+	}
+
+	NVT_LOG("Update firmware success! <%ld us>\n", 0L);
+//			(end.tv_sec - start.tv_sec)*1000000L + (end.tv_usec - start.tv_usec));
+
+	/* Get FW Info */
+	ret = nvt_get_fw_info();
+	if (ret) {
+		NVT_ERR("nvt_get_fw_info failed. (%d)\n", ret);
+	}
+
+download_fail:
+	if (!IS_ERR_OR_NULL(bin_map)) {
+		kfree(bin_map);
+		bin_map = NULL;
+	}
+
+	update_firmware_release();
+request_firmware_fail:
+
+	return ret;
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen update firmware when booting
+	function.
+
+return:
+	n.a.
+*******************************************************/
+void Boot_Update_Firmware(struct work_struct *work)
+{
+	mutex_lock(&ts->lock);
+	nvt_update_firmware(ts->boot_update_firmware_name);
+	mutex_unlock(&ts->lock);
+#if NVT_USB_PLUGIN
+	if (!IS_ERR_OR_NULL(g_touchscreen_usb_pulgin.event_callback))
+		g_touchscreen_usb_pulgin.valid = true;
+	if (g_touchscreen_usb_pulgin.valid && g_touchscreen_usb_pulgin.usb_plugged_in)
+		g_touchscreen_usb_pulgin.event_callback();
+#endif
+}
+#endif /* BOOT_UPDATE_FIRMWARE */
diff --git a/drivers/input/touchscreen/nt36xxx_spi/nt36xxx_mem_map.h b/drivers/input/touchscreen/nt36xxx_spi/nt36xxx_mem_map.h
new file mode 100644
index 000000000000..5dc313a5b647
--- /dev/null
+++ b/drivers/input/touchscreen/nt36xxx_spi/nt36xxx_mem_map.h
@@ -0,0 +1,258 @@
+/*
+ * Copyright (C) 2010 - 2018 Novatek, Inc.
+ * Copyright (C) 2020 XiaoMi, Inc.
+ *
+ * $Revision: 43560 $
+ * $Date: 2019-04-19 11:34:19 +0800 (週五, 19 四月 2019) $
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+struct nvt_ts_mem_map {
+	uint32_t EVENT_BUF_ADDR;
+	uint32_t RAW_PIPE0_ADDR;
+	uint32_t RAW_PIPE1_ADDR;
+	uint32_t BASELINE_ADDR;
+	uint32_t BASELINE_BTN_ADDR;
+	uint32_t DIFF_PIPE0_ADDR;
+	uint32_t DIFF_PIPE1_ADDR;
+	uint32_t RAW_BTN_PIPE0_ADDR;
+	uint32_t RAW_BTN_PIPE1_ADDR;
+	uint32_t DIFF_BTN_PIPE0_ADDR;
+	uint32_t DIFF_BTN_PIPE1_ADDR;
+	uint32_t READ_FLASH_CHECKSUM_ADDR;
+	uint32_t RW_FLASH_DATA_ADDR;
+	/* Phase 2 Host Download */
+	uint32_t BOOT_RDY_ADDR;
+	uint32_t POR_CD_ADDR;
+	/* BLD CRC */
+	uint32_t BLD_LENGTH_ADDR;
+	uint32_t ILM_LENGTH_ADDR;
+	uint32_t DLM_LENGTH_ADDR;
+	uint32_t BLD_DES_ADDR;
+	uint32_t ILM_DES_ADDR;
+	uint32_t DLM_DES_ADDR;
+	uint32_t G_ILM_CHECKSUM_ADDR;
+	uint32_t G_DLM_CHECKSUM_ADDR;
+	uint32_t R_ILM_CHECKSUM_ADDR;
+	uint32_t R_DLM_CHECKSUM_ADDR;
+	uint32_t BLD_CRC_EN_ADDR;
+	uint32_t DMA_CRC_EN_ADDR;
+	uint32_t BLD_ILM_DLM_CRC_ADDR;
+	uint32_t DMA_CRC_FLAG_ADDR;
+};
+
+struct nvt_ts_hw_info {
+	uint8_t carrier_system;
+	uint8_t hw_crc;
+};
+
+static const struct nvt_ts_mem_map NT36675_memory_map = {
+	.EVENT_BUF_ADDR           = 0x22D00,
+	.RAW_PIPE0_ADDR           = 0x24000,
+	.RAW_PIPE1_ADDR           = 0x24000,
+	.BASELINE_ADDR            = 0x21B90,
+	.BASELINE_BTN_ADDR        = 0,
+	.DIFF_PIPE0_ADDR          = 0x20C60,
+	.DIFF_PIPE1_ADDR          = 0x24C60,
+	.RAW_BTN_PIPE0_ADDR       = 0,
+	.RAW_BTN_PIPE1_ADDR       = 0,
+	.DIFF_BTN_PIPE0_ADDR      = 0,
+	.DIFF_BTN_PIPE1_ADDR      = 0,
+	.READ_FLASH_CHECKSUM_ADDR = 0x24000,
+	.RW_FLASH_DATA_ADDR       = 0x24002,
+	/* Phase 2 Host Download */
+	.BOOT_RDY_ADDR            = 0x3F10D,
+	/* BLD CRC */
+	.BLD_LENGTH_ADDR          = 0x3F138,	//0x3F138 ~ 0x3F13A	(3 bytes)
+	.ILM_LENGTH_ADDR          = 0x3F118,	//0x3F118 ~ 0x3F11A	(3 bytes)
+	.DLM_LENGTH_ADDR          = 0x3F130,	//0x3F130 ~ 0x3F132	(3 bytes)
+	.BLD_DES_ADDR             = 0x3F114,	//0x3F114 ~ 0x3F116	(3 bytes)
+	.ILM_DES_ADDR             = 0x3F128,	//0x3F128 ~ 0x3F12A	(3 bytes)
+	.DLM_DES_ADDR             = 0x3F12C,	//0x3F12C ~ 0x3F12E	(3 bytes)
+	.G_ILM_CHECKSUM_ADDR      = 0x3F100,	//0x3F100 ~ 0x3F103	(4 bytes)
+	.G_DLM_CHECKSUM_ADDR      = 0x3F104,	//0x3F104 ~ 0x3F107	(4 bytes)
+	.R_ILM_CHECKSUM_ADDR      = 0x3F120,	//0x3F120 ~ 0x3F123 (4 bytes)
+	.R_DLM_CHECKSUM_ADDR      = 0x3F124,	//0x3F124 ~ 0x3F127 (4 bytes)
+	.BLD_CRC_EN_ADDR          = 0x3F30E,
+	.DMA_CRC_EN_ADDR          = 0x3F136,
+	.BLD_ILM_DLM_CRC_ADDR     = 0x3F133,
+	.DMA_CRC_FLAG_ADDR        = 0x3F134,
+};
+
+
+static const struct nvt_ts_mem_map NT36672A_memory_map = {
+	.EVENT_BUF_ADDR           = 0x21C00,
+	.RAW_PIPE0_ADDR           = 0x20000,
+	.RAW_PIPE1_ADDR           = 0x23000,
+	.BASELINE_ADDR            = 0x20BFC,
+	.BASELINE_BTN_ADDR        = 0x23BFC,
+	.DIFF_PIPE0_ADDR          = 0x206DC,
+	.DIFF_PIPE1_ADDR          = 0x236DC,
+	.RAW_BTN_PIPE0_ADDR       = 0x20510,
+	.RAW_BTN_PIPE1_ADDR       = 0x23510,
+	.DIFF_BTN_PIPE0_ADDR      = 0x20BF0,
+	.DIFF_BTN_PIPE1_ADDR      = 0x23BF0,
+	.READ_FLASH_CHECKSUM_ADDR = 0x24000,
+	.RW_FLASH_DATA_ADDR       = 0x24002,
+	/* Phase 2 Host Download */
+	.BOOT_RDY_ADDR            = 0x3F10D,
+	/* BLD CRC */
+	.BLD_LENGTH_ADDR          = 0x3F10E,	//0x3F10E ~ 0x3F10F	(2 bytes)
+	.ILM_LENGTH_ADDR          = 0x3F118,	//0x3F118 ~ 0x3F119	(2 bytes)
+	.DLM_LENGTH_ADDR          = 0x3F130,	//0x3F130 ~ 0x3F131	(2 bytes)
+	.BLD_DES_ADDR             = 0x3F114,	//0x3F114 ~ 0x3F116	(3 bytes)
+	.ILM_DES_ADDR             = 0x3F128,	//0x3F128 ~ 0x3F12A	(3 bytes)
+	.DLM_DES_ADDR             = 0x3F12C,	//0x3F12C ~ 0x3F12E	(3 bytes)
+	.G_ILM_CHECKSUM_ADDR      = 0x3F100,	//0x3F100 ~ 0x3F103	(4 bytes)
+	.G_DLM_CHECKSUM_ADDR      = 0x3F104,	//0x3F104 ~ 0x3F107	(4 bytes)
+	.R_ILM_CHECKSUM_ADDR      = 0x3F120,	//0x3F120 ~ 0x3F123 (4 bytes)
+	.R_DLM_CHECKSUM_ADDR      = 0x3F124,	//0x3F124 ~ 0x3F127 (4 bytes)
+	.BLD_CRC_EN_ADDR          = 0x3F30E,
+	.DMA_CRC_EN_ADDR          = 0x3F132,
+	.BLD_ILM_DLM_CRC_ADDR     = 0x3F133,
+	.DMA_CRC_FLAG_ADDR        = 0x3F134,
+};
+
+static const struct nvt_ts_mem_map NT36772_memory_map = {
+	.EVENT_BUF_ADDR           = 0x11E00,
+	.RAW_PIPE0_ADDR           = 0x10000,
+	.RAW_PIPE1_ADDR           = 0x12000,
+	.BASELINE_ADDR            = 0x10E70,
+	.BASELINE_BTN_ADDR        = 0x12E70,
+	.DIFF_PIPE0_ADDR          = 0x10830,
+	.DIFF_PIPE1_ADDR          = 0x12830,
+	.RAW_BTN_PIPE0_ADDR       = 0x10E60,
+	.RAW_BTN_PIPE1_ADDR       = 0x12E60,
+	.DIFF_BTN_PIPE0_ADDR      = 0x10E68,
+	.DIFF_BTN_PIPE1_ADDR      = 0x12E68,
+	.READ_FLASH_CHECKSUM_ADDR = 0x14000,
+	.RW_FLASH_DATA_ADDR       = 0x14002,
+	/* Phase 2 Host Download */
+	.BOOT_RDY_ADDR            = 0x1F141,
+	.POR_CD_ADDR              = 0x1F61C,
+	/* BLD CRC */
+	.R_ILM_CHECKSUM_ADDR      = 0x1BF00,
+};
+
+static const struct nvt_ts_mem_map NT36525_memory_map = {
+	.EVENT_BUF_ADDR           = 0x11A00,
+	.RAW_PIPE0_ADDR           = 0x10000,
+	.RAW_PIPE1_ADDR           = 0x12000,
+	.BASELINE_ADDR            = 0x10B08,
+	.BASELINE_BTN_ADDR        = 0x12B08,
+	.DIFF_PIPE0_ADDR          = 0x1064C,
+	.DIFF_PIPE1_ADDR          = 0x1264C,
+	.RAW_BTN_PIPE0_ADDR       = 0x10634,
+	.RAW_BTN_PIPE1_ADDR       = 0x12634,
+	.DIFF_BTN_PIPE0_ADDR      = 0x10AFC,
+	.DIFF_BTN_PIPE1_ADDR      = 0x12AFC,
+	.READ_FLASH_CHECKSUM_ADDR = 0x14000,
+	.RW_FLASH_DATA_ADDR       = 0x14002,
+	/* Phase 2 Host Download */
+	.BOOT_RDY_ADDR            = 0x1F141,
+	.POR_CD_ADDR              = 0x1F61C,
+	/* BLD CRC */
+	.R_ILM_CHECKSUM_ADDR      = 0x1BF00,
+};
+
+static const struct nvt_ts_mem_map NT36676F_memory_map = {
+	.EVENT_BUF_ADDR           = 0x11A00,
+	.RAW_PIPE0_ADDR           = 0x10000,
+	.RAW_PIPE1_ADDR           = 0x12000,
+	.BASELINE_ADDR            = 0x10B08,
+	.BASELINE_BTN_ADDR        = 0x12B08,
+	.DIFF_PIPE0_ADDR          = 0x1064C,
+	.DIFF_PIPE1_ADDR          = 0x1264C,
+	.RAW_BTN_PIPE0_ADDR       = 0x10634,
+	.RAW_BTN_PIPE1_ADDR       = 0x12634,
+	.DIFF_BTN_PIPE0_ADDR      = 0x10AFC,
+	.DIFF_BTN_PIPE1_ADDR      = 0x12AFC,
+	.READ_FLASH_CHECKSUM_ADDR = 0x14000,
+	.RW_FLASH_DATA_ADDR       = 0x14002,
+};
+
+static struct nvt_ts_hw_info NT36675_hw_info = {
+	.carrier_system = 2,
+	.hw_crc         = 2,
+};
+
+static struct nvt_ts_hw_info NT36672A_hw_info = {
+	.carrier_system = 0,
+	.hw_crc         = 1,
+};
+
+static struct nvt_ts_hw_info NT36772_hw_info = {
+	.carrier_system = 0,
+	.hw_crc         = 0,
+};
+
+static struct nvt_ts_hw_info NT36525_hw_info = {
+	.carrier_system = 0,
+	.hw_crc         = 0,
+};
+
+static struct nvt_ts_hw_info NT36676F_hw_info = {
+	.carrier_system = 0,
+	.hw_crc         = 0,
+};
+
+#define NVT_ID_BYTE_MAX 6
+struct nvt_ts_trim_id_table {
+	uint8_t id[NVT_ID_BYTE_MAX];
+	uint8_t mask[NVT_ID_BYTE_MAX];
+	const struct nvt_ts_mem_map *mmap;
+	const struct nvt_ts_hw_info *hwinfo;
+};
+
+static const struct nvt_ts_trim_id_table trim_id_table[] = {
+	{.id = {0xFF, 0xFF, 0xFF, 0x75, 0x66, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36675_memory_map,  .hwinfo = &NT36675_hw_info},
+	{.id = {0x0B, 0xFF, 0xFF, 0x72, 0x66, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0B, 0xFF, 0xFF, 0x82, 0x66, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0B, 0xFF, 0xFF, 0x25, 0x65, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0A, 0xFF, 0xFF, 0x72, 0x65, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0A, 0xFF, 0xFF, 0x72, 0x66, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0A, 0xFF, 0xFF, 0x82, 0x66, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0A, 0xFF, 0xFF, 0x70, 0x66, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0B, 0xFF, 0xFF, 0x70, 0x66, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x0A, 0xFF, 0xFF, 0x72, 0x67, 0x03}, .mask = {1, 0, 0, 1, 1, 1},
+		.mmap = &NT36672A_memory_map, .hwinfo = &NT36672A_hw_info},
+	{.id = {0x55, 0x00, 0xFF, 0x00, 0x00, 0x00}, .mask = {1, 1, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0x55, 0x72, 0xFF, 0x00, 0x00, 0x00}, .mask = {1, 1, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xAA, 0x00, 0xFF, 0x00, 0x00, 0x00}, .mask = {1, 1, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xAA, 0x72, 0xFF, 0x00, 0x00, 0x00}, .mask = {1, 1, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x72, 0x67, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x70, 0x66, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x70, 0x67, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x72, 0x66, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36772_memory_map,  .hwinfo = &NT36772_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x25, 0x65, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36525_memory_map,  .hwinfo = &NT36525_hw_info},
+	{.id = {0xFF, 0xFF, 0xFF, 0x76, 0x66, 0x03}, .mask = {0, 0, 0, 1, 1, 1},
+		.mmap = &NT36676F_memory_map, .hwinfo = &NT36676F_hw_info}
+};
diff --git a/drivers/input/touchscreen/sec_ts/Kconfig b/drivers/input/touchscreen/sec_ts/Kconfig
new file mode 100644
index 000000000000..dbc8750214c0
--- /dev/null
+++ b/drivers/input/touchscreen/sec_ts/Kconfig
@@ -0,0 +1,14 @@
+#
+# Samsung Electronics TOUCH driver configuration
+#
+
+config TOUCHSCREEN_SEC_TS_1223
+        tristate "Samsung Electronics Touchscreen 1223"
+	default y
+        depends on I2C
+        help
+          Say Y here if you want support for SEC touchscreen controllers.
+          If unsure, say N.
+
+          To compile this driver as a module, choose M here: the
+          module will be called sec_ts.
diff --git a/drivers/input/touchscreen/sec_ts/Makefile b/drivers/input/touchscreen/sec_ts/Makefile
new file mode 100644
index 000000000000..0e5c6eeb51d8
--- /dev/null
+++ b/drivers/input/touchscreen/sec_ts/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_TOUCHSCREEN_SEC_TS_1223)	+= sec_ts.o
+sec_ts-objs += sec_ts_main.o sec_ts_fw.o sec_ts_fn.o
+#sec_ts-objs += sec_ts_selftest.o
diff --git a/drivers/input/touchscreen/sec_ts/sec_ts.c b/drivers/input/touchscreen/sec_ts/sec_ts.c
new file mode 100644
index 000000000000..5686ffd189b0
--- /dev/null
+++ b/drivers/input/touchscreen/sec_ts/sec_ts.c
@@ -0,0 +1,3152 @@
+/* drivers/input/touchscreen/sec_ts.c
+ *
+ * Copyright (C) 2011 Samsung Electronics Co., Ltd.
+ * http://www.samsungsemi.com/
+ *
+ * Core file for Samsung TSC driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+struct sec_ts_data *tsp_info;
+
+#include "sec_ts.h"
+
+#ifdef CONFIG_SECURE_TOUCH
+enum subsystem {
+	TZ = 1,
+	APSS = 3
+};
+
+#define TZ_BLSP_MODIFY_OWNERSHIP_ID 3
+#endif
+
+struct sec_ts_data *ts_dup;
+
+#ifdef USE_POWER_RESET_WORK
+static void sec_ts_reset_work(struct work_struct *work);
+#endif
+static void sec_ts_read_info_work(struct work_struct *work);
+
+#ifdef USE_OPEN_CLOSE
+static int sec_ts_input_open(struct input_dev *dev);
+static void sec_ts_input_close(struct input_dev *dev);
+#endif
+
+#ifdef CONFIG_INPUT_WACOM
+extern void epen_disable_mode(int mode);
+#endif
+
+int sec_ts_read_information(struct sec_ts_data *ts);
+
+#ifdef CONFIG_SECURE_TOUCH
+static int sec_ts_change_pipe_owner(struct sec_ts_data *ts, enum subsystem subsystem)
+{
+	/* scm call disciptor */
+	struct scm_desc desc;
+	int ret = 0;
+
+	/* number of arguments */
+	desc.arginfo = SCM_ARGS(2);
+	/* BLSPID (1 - 12) */
+	desc.args[0] = (u64)(ts->client->adapter->nr) - 1;
+	/* Owner if TZ or APSS */
+	desc.args[1] = subsystem;
+
+	ret = scm_call2(SCM_SIP_FNID(SCM_SVC_TZ, TZ_BLSP_MODIFY_OWNERSHIP_ID), &desc);
+	if (ret) {
+		input_err(true, &ts->client->dev, "%s: ret: %d\n", __func__, ret);
+		return ret;
+	}
+
+	input_dbg(true, &ts->client->dev, "%s: return: %llu\n", __func__, desc.ret[0]);
+
+	return desc.ret[0];
+}
+
+static irqreturn_t sec_ts_irq_thread(int irq, void *ptr);
+
+static irqreturn_t secure_filter_interrupt(struct sec_ts_data *ts)
+{
+	if (atomic_read(&ts->secure_enabled) == SECURE_TOUCH_ENABLE) {
+		if (atomic_cmpxchg(&ts->secure_pending_irqs, 0, 1) == 0) {
+			sysfs_notify(&ts->input_dev->dev.kobj, NULL, "secure_touch");
+
+#if defined(CONFIG_TRUSTONIC_TRUSTED_UI) || defined(CONFIG_TRUSTONIC_TRUSTED_UI_QC)
+			complete(&ts->st_irq_received);
+#endif
+		} else {
+			input_info(true, &ts->client->dev, "%s: pending irq:%d\n",
+					__func__, (int)atomic_read(&ts->secure_pending_irqs));
+		}
+
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+static int secure_touch_clk_prepare_enable(struct sec_ts_data *ts)
+{
+	int ret;
+
+	if (!ts->core_clk || !ts->iface_clk) {
+		input_err(true, &ts->client->dev, "%s: error clk\n", __func__);
+		return -ENODEV;
+	}
+
+	ret = clk_prepare_enable(ts->core_clk);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: failed core clk\n", __func__);
+		goto err_core_clk;
+	}
+
+	ret = clk_prepare_enable(ts->iface_clk);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: failed iface clk\n", __func__);
+		goto err_iface_clk;
+	}
+
+	return 0;
+
+err_iface_clk:
+	clk_disable_unprepare(ts->core_clk);
+err_core_clk:
+	return -ENODEV;
+}
+
+static void secure_touch_clk_unprepare_disable(struct sec_ts_data *ts)
+{
+	if (!ts->core_clk || !ts->iface_clk) {
+		input_err(true, &ts->client->dev, "%s: error clk\n", __func__);
+		return;
+	}
+
+	clk_disable_unprepare(ts->core_clk);
+	clk_disable_unprepare(ts->iface_clk);
+}
+
+/**
+ * Sysfs attr group for secure touch & interrupt handler for Secure world.
+ * @atomic : syncronization for secure_enabled
+ * @pm_runtime : set rpm_resume or rpm_ilde
+ */
+static ssize_t secure_touch_enable_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%d", atomic_read(&ts->secure_enabled));
+}
+
+static ssize_t secure_touch_enable_store(struct device *dev,
+		struct device_attribute *addr, const char *buf, size_t count)
+{
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+	int ret;
+	unsigned long data;
+
+	if (count > 2) {
+		input_err(true, &ts->client->dev,
+				"%s: cmd length is over (%s,%d)!!\n",
+				__func__, buf, (int)strlen(buf));
+		return -EINVAL;
+	}
+
+	ret = kstrtoul(buf, 10, &data);
+	if (ret != 0) {
+		input_err(true, &ts->client->dev, "%s: failed to read:%d\n",
+				__func__, ret);
+		return -EINVAL;
+	}
+
+	if (data == 1) {
+		if (ts->reset_is_on_going) {
+			input_err(true, &ts->client->dev, "%s: reset is on going because i2c fail\n", __func__);
+			return -EBUSY;
+		}
+
+		/* Enable Secure World */
+		if (atomic_read(&ts->secure_enabled) == SECURE_TOUCH_ENABLE) {
+			input_err(true, &ts->client->dev, "%s: already enabled\n", __func__);
+			return -EBUSY;
+		}
+
+		/* syncronize_irq -> disable_irq + enable_irq
+		 * concern about timing issue.
+		 */
+		disable_irq(ts->client->irq);
+
+		/* Fix normal active mode : idle mode is failed to i2c for 1 time */
+		ret = sec_ts_fix_tmode(ts, TOUCH_SYSTEM_MODE_TOUCH, TOUCH_MODE_STATE_TOUCH);
+		if (ret < 0) {
+			input_err(true, &ts->client->dev, "%s: failed to fix tmode\n",
+					__func__);
+			return -EIO;
+		}
+
+		/* Release All Finger */
+		sec_ts_unlocked_release_all_finger(ts);
+
+		if (pm_runtime_get_sync(ts->client->adapter->dev.parent) < 0) {
+			input_err(true, &ts->client->dev, "%s: failed to get pm_runtime\n", __func__);
+			return -EIO;
+		}
+
+		if (secure_touch_clk_prepare_enable(ts) < 0) {
+			pm_runtime_put_sync(ts->client->adapter->dev.parent);
+			input_err(true, &ts->client->dev, "%s: failed to clk enable\n", __func__);
+			return -ENXIO;
+		}
+
+		sec_ts_change_pipe_owner(ts, TZ);
+
+		reinit_completion(&ts->secure_powerdown);
+		reinit_completion(&ts->secure_interrupt);
+#if defined(CONFIG_TRUSTONIC_TRUSTED_UI) || defined(CONFIG_TRUSTONIC_TRUSTED_UI_QC)
+		reinit_completion(&ts->st_irq_received);
+#endif
+		atomic_set(&ts->secure_enabled, 1);
+		atomic_set(&ts->secure_pending_irqs, 0);
+
+		enable_irq(ts->client->irq);
+
+		input_info(true, &ts->client->dev, "%s: secure touch enable\n", __func__);
+	} else if (data == 0) {
+		/* Disable Secure World */
+		if (atomic_read(&ts->secure_enabled) == SECURE_TOUCH_DISABLE) {
+			input_err(true, &ts->client->dev, "%s: already disabled\n", __func__);
+			return count;
+		}
+
+		sec_ts_change_pipe_owner(ts, APSS);
+
+		secure_touch_clk_unprepare_disable(ts);
+		pm_runtime_put_sync(ts->client->adapter->dev.parent);
+		atomic_set(&ts->secure_enabled, 0);
+
+		sysfs_notify(&ts->input_dev->dev.kobj, NULL, "secure_touch");
+
+		sec_ts_delay(10);
+
+		sec_ts_irq_thread(ts->client->irq, ts);
+		complete(&ts->secure_interrupt);
+		complete(&ts->secure_powerdown);
+#if defined(CONFIG_TRUSTONIC_TRUSTED_UI) || defined(CONFIG_TRUSTONIC_TRUSTED_UI_QC)
+		complete(&ts->st_irq_received);
+#endif
+
+		input_info(true, &ts->client->dev, "%s: secure touch disable\n", __func__);
+
+		ret = sec_ts_release_tmode(ts);
+		if (ret < 0) {
+			input_err(true, &ts->client->dev, "%s: failed to release tmode\n",
+					__func__);
+			return -EIO;
+		}
+
+	} else {
+		input_err(true, &ts->client->dev, "%s: unsupport value:%d\n", __func__, data);
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+#if defined(CONFIG_TRUSTONIC_TRUSTED_UI) || defined(CONFIG_TRUSTONIC_TRUSTED_UI_QC)
+static int secure_get_irq(struct device *dev)
+{
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+	int val = 0;
+
+	if (atomic_read(&ts->secure_enabled) == SECURE_TOUCH_DISABLE) {
+		input_err(true, &ts->client->dev, "%s: disabled\n", __func__);
+		return -EBADF;
+	}
+
+	if (atomic_cmpxchg(&ts->secure_pending_irqs, -1, 0) == -1) {
+		input_err(true, &ts->client->dev, "%s: pending irq -1\n", __func__);
+		return -EINVAL;
+	}
+
+	if (atomic_cmpxchg(&ts->secure_pending_irqs, 1, 0) == 1)
+		val = 1;
+
+	input_err(true, &ts->client->dev, "%s: pending irq is %d\n",
+			__func__, atomic_read(&ts->secure_pending_irqs));
+
+	complete(&ts->secure_interrupt);
+
+	return val;
+}
+#endif
+
+static ssize_t secure_touch_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+	int val = 0;
+
+	if (atomic_read(&ts->secure_enabled) == SECURE_TOUCH_DISABLE) {
+		input_err(true, &ts->client->dev, "%s: disabled\n", __func__);
+		return -EBADF;
+	}
+
+	if (atomic_cmpxchg(&ts->secure_pending_irqs, -1, 0) == -1) {
+		input_err(true, &ts->client->dev, "%s: pending irq -1\n", __func__);
+		return -EINVAL;
+	}
+
+	if (atomic_cmpxchg(&ts->secure_pending_irqs, 1, 0) == 1)
+		val = 1;
+
+	input_err(true, &ts->client->dev, "%s: pending irq is %d\n",
+			__func__, atomic_read(&ts->secure_pending_irqs));
+
+	complete(&ts->secure_interrupt);
+
+	return snprintf(buf, PAGE_SIZE, "%u", val);
+}
+
+static ssize_t secure_ownership_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "1");
+}
+
+static DEVICE_ATTR(secure_touch_enable, (S_IRUGO | S_IWUSR | S_IWGRP),
+		secure_touch_enable_show, secure_touch_enable_store);
+static DEVICE_ATTR(secure_touch, S_IRUGO, secure_touch_show, NULL);
+
+static DEVICE_ATTR(secure_ownership, S_IRUGO, secure_ownership_show, NULL);
+
+static struct attribute *secure_attr[] = {
+	&dev_attr_secure_touch_enable.attr,
+	&dev_attr_secure_touch.attr,
+	&dev_attr_secure_ownership.attr,
+	NULL,
+};
+
+static struct attribute_group secure_attr_group = {
+	.attrs = secure_attr,
+};
+
+
+static int secure_touch_init(struct sec_ts_data *ts)
+{
+	input_info(true, &ts->client->dev, "%s\n", __func__);
+
+	init_completion(&ts->secure_interrupt);
+	init_completion(&ts->secure_powerdown);
+#if defined(CONFIG_TRUSTONIC_TRUSTED_UI) || defined(CONFIG_TRUSTONIC_TRUSTED_UI_QC)
+	init_completion(&ts->st_irq_received);
+#endif
+
+	ts->core_clk = clk_get(&ts->client->adapter->dev, "core_clk");
+	if (IS_ERR_OR_NULL(ts->core_clk)) {
+		input_err(true, &ts->client->dev, "%s: failed to get core_clk: %ld\n",
+				__func__, PTR_ERR(ts->core_clk));
+		goto err_core_clk;
+	}
+
+	ts->iface_clk = clk_get(&ts->client->adapter->dev, "iface_clk");
+	if (IS_ERR_OR_NULL(ts->iface_clk)) {
+		input_err(true, &ts->client->dev, "%s: failed to get iface_clk: %ld\n",
+				__func__, PTR_ERR(ts->iface_clk));
+		goto err_iface_clk;
+	}
+
+#if defined(CONFIG_TRUSTONIC_TRUSTED_UI) || defined(CONFIG_TRUSTONIC_TRUSTED_UI_QC)
+	register_tui_hal_ts(&ts->input_dev->dev, &ts->secure_enabled,
+			&ts->st_irq_received, secure_get_irq,
+			secure_touch_enable_store);
+#endif
+
+	return 0;
+
+err_iface_clk:
+	clk_put(ts->core_clk);
+err_core_clk:
+	ts->core_clk = NULL;
+	ts->iface_clk = NULL;
+
+	return -ENODEV;
+}
+
+static void secure_touch_remove(struct sec_ts_data *ts)
+{
+	if (!IS_ERR_OR_NULL(ts->core_clk))
+		clk_put(ts->core_clk);
+
+	if (!IS_ERR_OR_NULL(ts->iface_clk))
+		clk_put(ts->iface_clk);
+}
+
+static void secure_touch_stop(struct sec_ts_data *ts, bool stop)
+{
+	if (atomic_read(&ts->secure_enabled)) {
+		atomic_set(&ts->secure_pending_irqs, -1);
+
+		sysfs_notify(&ts->input_dev->dev.kobj, NULL, "secure_touch");
+
+#if defined(CONFIG_TRUSTONIC_TRUSTED_UI) || defined(CONFIG_TRUSTONIC_TRUSTED_UI_QC)
+		complete(&ts->st_irq_received);
+#endif
+
+		if (stop)
+			wait_for_completion_interruptible(&ts->secure_powerdown);
+
+		input_info(true, &ts->client->dev, "%s: %d\n", __func__, stop);
+	}
+}
+#endif
+
+int sec_ts_i2c_write(struct sec_ts_data *ts, u8 reg, u8 *data, int len)
+{
+	u8 buf[I2C_WRITE_BUFFER_SIZE + 1];
+	int ret;
+	unsigned char retry;
+	struct i2c_msg msg;
+
+#ifdef CONFIG_SECURE_TOUCH
+	if (atomic_read(&ts->secure_enabled) == SECURE_TOUCH_ENABLE) {
+		input_err(true, &ts->client->dev,
+				"%s: TSP no accessible from Linux, TUI is enabled!\n", __func__);
+		return -EBUSY;
+	}
+#endif
+#ifdef CONFIG_TRUSTONIC_TRUSTED_UI
+	if (TRUSTEDUI_MODE_INPUT_SECURED & trustedui_get_current_mode()) {
+		input_err(true, &ts->client->dev,
+				"%s: TSP no accessible from Linux, TRUSTED_UI is enabled!\n", __func__);
+		return -EIO;
+	}
+#endif
+
+	if (len > I2C_WRITE_BUFFER_SIZE) {
+		input_err(true, &ts->client->dev, "%s: len is larger than buffer size\n", __func__);
+		return -EINVAL;
+	}
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev, "%s: POWER_STATUS : OFF\n", __func__);
+		goto err;
+	}
+
+	buf[0] = reg;
+	memcpy(buf + 1, data, len);
+
+	msg.addr = ts->client->addr;
+	msg.flags = 0;
+	msg.len = len + 1;
+	msg.buf = buf;
+	mutex_lock(&ts->i2c_mutex);
+	for (retry = 0; retry < SEC_TS_I2C_RETRY_CNT; retry++) {
+		ret = i2c_transfer(ts->client->adapter, &msg, 1);
+		if (ret > 0)
+			break;
+
+		if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+			input_err(true, &ts->client->dev, "%s: POWER_STATUS : OFF, retry:%d\n", __func__, retry);
+			mutex_unlock(&ts->i2c_mutex);
+			goto err;
+		}
+
+		usleep_range(1 * 1000, 1 * 1000);
+
+		if (retry > 1) {
+			input_err(true, &ts->client->dev, "%s: I2C retry %d, ret:%d\n", __func__, retry + 1, ret);
+			ts->comm_err_count++;
+		}
+	}
+
+	mutex_unlock(&ts->i2c_mutex);
+
+	if (retry == SEC_TS_I2C_RETRY_CNT) {
+		input_err(true, &ts->client->dev, "%s: I2C write over retry limit\n", __func__);
+		ret = -EIO;
+#ifdef USE_POR_AFTER_I2C_RETRY
+		if (ts->probe_done && !ts->reset_is_on_going)
+			schedule_delayed_work(&ts->reset_work, msecs_to_jiffies(TOUCH_RESET_DWORK_TIME));
+#endif
+	}
+
+	if (ret > 0)
+		return 0;
+err:
+	return -EIO;
+}
+
+int sec_ts_i2c_read(struct sec_ts_data *ts, u8 reg, u8 *data, int len)
+{
+	u8 buf[4];
+	int ret;
+	unsigned char retry;
+	struct i2c_msg msg[2];
+	int remain = len;
+
+#ifdef CONFIG_SECURE_TOUCH
+	if (atomic_read(&ts->secure_enabled) == SECURE_TOUCH_ENABLE) {
+		input_err(true, &ts->client->dev,
+				"%s: TSP no accessible from Linux, TUI is enabled!\n", __func__);
+		return -EBUSY;
+	}
+#endif
+#ifdef CONFIG_TRUSTONIC_TRUSTED_UI
+	if (TRUSTEDUI_MODE_INPUT_SECURED & trustedui_get_current_mode()) {
+		input_err(true, &ts->client->dev,
+				"%s: TSP no accessible from Linux, TRUSTED_UI is enabled!\n", __func__);
+		return -EIO;
+	}
+#endif
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev, "%s: POWER_STATUS : OFF\n", __func__);
+		goto err;
+	}
+
+	buf[0] = reg;
+
+	msg[0].addr = ts->client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf;
+
+	msg[1].addr = ts->client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	mutex_lock(&ts->i2c_mutex);
+
+	if (len <= ts->i2c_burstmax) {
+
+		for (retry = 0; retry < SEC_TS_I2C_RETRY_CNT; retry++) {
+			ret = i2c_transfer(ts->client->adapter, msg, 2);
+			if (ret > 0)
+				break;
+			usleep_range(1 * 1000, 1 * 1000);
+			if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+				input_err(true, &ts->client->dev, "%s: POWER_STATUS : OFF, retry:%d\n", __func__, retry);
+				mutex_unlock(&ts->i2c_mutex);
+				goto err;
+			}
+
+			if (retry > 1) {
+				input_err(true, &ts->client->dev, "%s: I2C retry %d, ret:%d\n", __func__, retry + 1, ret);
+				ts->comm_err_count++;
+			}
+		}
+
+	} else {
+		/*
+		 * I2C read buffer is 256 byte. do not support long buffer over than 256.
+		 * So, try to seperate reading data about 256 bytes.
+		 */
+
+		for (retry = 0; retry < SEC_TS_I2C_RETRY_CNT; retry++) {
+			ret = i2c_transfer(ts->client->adapter, msg, 1);
+			if (ret > 0)
+				break;
+			usleep_range(1 * 1000, 1 * 1000);
+			if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+				input_err(true, &ts->client->dev, "%s: POWER_STATUS : OFF, retry:%d\n", __func__, retry);
+				mutex_unlock(&ts->i2c_mutex);
+				goto err;
+			}
+
+			if (retry > 1) {
+				input_err(true, &ts->client->dev, "%s: I2C retry %d, ret:%d\n", __func__, retry + 1, ret);
+				ts->comm_err_count++;
+			}
+		}
+
+		do {
+			if (remain > ts->i2c_burstmax)
+				msg[1].len = ts->i2c_burstmax;
+			else
+				msg[1].len = remain;
+
+			remain -= ts->i2c_burstmax;
+
+			for (retry = 0; retry < SEC_TS_I2C_RETRY_CNT; retry++) {
+				ret = i2c_transfer(ts->client->adapter, &msg[1], 1);
+				if (ret > 0)
+					break;
+				usleep_range(1 * 1000, 1 * 1000);
+				if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+					input_err(true, &ts->client->dev, "%s: POWER_STATUS : OFF, retry:%d\n", __func__, retry);
+					mutex_unlock(&ts->i2c_mutex);
+					goto err;
+				}
+
+				if (retry > 1) {
+					input_err(true, &ts->client->dev, "%s: I2C retry %d, ret:%d\n", __func__, retry + 1, ret);
+					ts->comm_err_count++;
+				}
+			}
+
+			msg[1].buf += msg[1].len;
+
+		} while (remain > 0);
+
+	}
+
+	mutex_unlock(&ts->i2c_mutex);
+
+	if (retry == SEC_TS_I2C_RETRY_CNT) {
+		input_err(true, &ts->client->dev, "%s: I2C read over retry limit\n", __func__);
+		ret = -EIO;
+#ifdef USE_POR_AFTER_I2C_RETRY
+		if (ts->probe_done && !ts->reset_is_on_going)
+			schedule_delayed_work(&ts->reset_work, msecs_to_jiffies(TOUCH_RESET_DWORK_TIME));
+#endif
+
+	}
+
+	return ret;
+
+err:
+	return -EIO;
+}
+
+static int sec_ts_i2c_write_burst(struct sec_ts_data *ts, u8 *data, int len)
+{
+	int ret;
+	int retry;
+
+#ifdef CONFIG_SECURE_TOUCH
+	if (atomic_read(&ts->secure_enabled) == SECURE_TOUCH_ENABLE) {
+		input_err(true, &ts->client->dev,
+				"%s: TSP no accessible from Linux, TUI is enabled\n", __func__);
+		return -EBUSY;
+	}
+#endif
+
+	mutex_lock(&ts->i2c_mutex);
+	for (retry = 0; retry < SEC_TS_I2C_RETRY_CNT; retry++) {
+		ret = i2c_master_send(ts->client, data, len);
+		if (ret > 0)
+			break;
+
+		usleep_range(1 * 1000, 1 * 1000);
+
+		if (retry > 1) {
+			input_err(true, &ts->client->dev, "%s: I2C retry %d, ret:%d\n", __func__, retry + 1, ret);
+			ts->comm_err_count++;
+		}
+	}
+
+	mutex_unlock(&ts->i2c_mutex);
+	if (retry == SEC_TS_I2C_RETRY_CNT) {
+		input_err(true, &ts->client->dev, "%s: I2C write over retry limit\n", __func__);
+		ret = -EIO;
+	}
+
+	return ret;
+}
+
+static int sec_ts_i2c_read_bulk(struct sec_ts_data *ts, u8 *data, int len)
+{
+	int ret;
+	unsigned char retry;
+	int remain = len;
+	struct i2c_msg msg;
+
+#ifdef CONFIG_SECURE_TOUCH
+	if (atomic_read(&ts->secure_enabled) == SECURE_TOUCH_ENABLE) {
+		input_err(true, &ts->client->dev,
+				"%s: TSP no accessible from Linux, TUI is enabled\n", __func__);
+		return -EBUSY;
+	}
+#endif
+
+	msg.addr = ts->client->addr;
+	msg.flags = I2C_M_RD;
+	msg.len = len;
+	msg.buf = data;
+
+	mutex_lock(&ts->i2c_mutex);
+
+	do {
+		if (remain > ts->i2c_burstmax)
+			msg.len = ts->i2c_burstmax;
+		else
+			msg.len = remain;
+
+		remain -= ts->i2c_burstmax;
+
+		for (retry = 0; retry < SEC_TS_I2C_RETRY_CNT; retry++) {
+			ret = i2c_transfer(ts->client->adapter, &msg, 1);
+			if (ret > 0)
+				break;
+			usleep_range(1 * 1000, 1 * 1000);
+
+			if (retry > 1) {
+				input_err(true, &ts->client->dev, "%s: I2C retry %d, ret:%d\n", __func__, retry + 1, ret);
+				ts->comm_err_count++;
+			}
+		}
+
+		if (retry == SEC_TS_I2C_RETRY_CNT) {
+			input_err(true, &ts->client->dev, "%s: I2C read over retry limit\n", __func__);
+			ret = -EIO;
+
+			break;
+		}
+		msg.buf += msg.len;
+
+	} while (remain > 0);
+
+	mutex_unlock(&ts->i2c_mutex);
+
+	if (ret > 0)
+		return 0;
+
+	return -EIO;
+}
+static int sec_ts_read_from_sponge(struct sec_ts_data *ts, u8 *data, int len)
+{
+	int ret;
+
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SPONGE_READ_PARAM, data, 2);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: fail to read sponge command\n", __func__);
+
+	ret = sec_ts_i2c_read(ts, SEC_TS_CMD_SPONGE_READ_PARAM, (u8 *)data, len);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: fail to read sponge command\n", __func__);
+
+	return ret;
+}
+
+#if defined(CONFIG_TOUCHSCREEN_DUMP_MODE)
+#include <linux/sec_debug.h>
+extern struct tsp_dump_callbacks dump_callbacks;
+static struct delayed_work *p_ghost_check;
+
+static void sec_ts_check_rawdata(struct work_struct *work)
+{
+	struct sec_ts_data *ts = container_of(work, struct sec_ts_data, ghost_check.work);
+
+	if (ts->tsp_dump_lock == 1) {
+		input_err(true, &ts->client->dev, "%s: ignored ## already checking..\n", __func__);
+		return;
+	}
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev, "%s: ignored ## IC is power off\n", __func__);
+		return;
+	}
+
+	sec_ts_run_rawdata_all(ts, true);
+}
+
+static void dump_tsp_log(void)
+{
+	pr_info("%s: %s %s: start\n", SEC_TS_I2C_NAME, SECLOG, __func__);
+
+#ifdef CONFIG_BATTERY_SAMSUNG
+	if (lpcharge == 1) {
+		pr_err("%s: %s %s: ignored ## lpm charging Mode!!\n", SEC_TS_I2C_NAME, SECLOG, __func__);
+		return;
+	}
+#endif
+
+	if (p_ghost_check == NULL) {
+		pr_err("%s: %s %s: ignored ## tsp probe fail!!\n", SEC_TS_I2C_NAME, SECLOG, __func__);
+		return;
+	}
+	schedule_delayed_work(p_ghost_check, msecs_to_jiffies(100));
+}
+#endif
+
+
+void sec_ts_delay(unsigned int ms)
+{
+	if (ms < 20)
+		usleep_range(ms * 1000, ms * 1000);
+	else
+		msleep(ms);
+}
+
+int sec_ts_wait_for_ready(struct sec_ts_data *ts, unsigned int ack)
+{
+	int rc = -1;
+	int retry = 0;
+	u8 tBuff[SEC_TS_EVENT_BUFF_SIZE] = {0,};
+
+	while (sec_ts_i2c_read(ts, SEC_TS_READ_ONE_EVENT, tBuff, SEC_TS_EVENT_BUFF_SIZE)) {
+		if (((tBuff[0] >> 2) & 0xF) == TYPE_STATUS_EVENT_INFO) {
+			if (tBuff[1] == ack) {
+				rc = 0;
+				break;
+			}
+		} else if (((tBuff[0] >> 2) & 0xF) == TYPE_STATUS_EVENT_VENDOR_INFO) {
+			if (tBuff[1] == ack) {
+				rc = 0;
+				break;
+			}
+		}
+
+		if (retry++ > SEC_TS_WAIT_RETRY_CNT) {
+			input_err(true, &ts->client->dev, "%s: Time Over\n", __func__);
+			break;
+		}
+		sec_ts_delay(20);
+	}
+
+	input_info(true, &ts->client->dev,
+			"%s: %02X, %02X, %02X, %02X, %02X, %02X, %02X, %02X [%d]\n",
+			__func__, tBuff[0], tBuff[1], tBuff[2], tBuff[3],
+			tBuff[4], tBuff[5], tBuff[6], tBuff[7], retry);
+
+	return rc;
+}
+
+int sec_ts_read_calibration_report(struct sec_ts_data *ts)
+{
+	int ret;
+	u8 buf[5] = { 0 };
+
+	buf[0] = SEC_TS_READ_CALIBRATION_REPORT;
+
+	ret = sec_ts_i2c_read(ts, buf[0], &buf[1], 4);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: failed to read, %d\n", __func__, ret);
+		return ret;
+	}
+
+	input_info(true, &ts->client->dev, "%s: count:%d, pass count:%d, fail count:%d, status:0x%X\n",
+			__func__, buf[1], buf[2], buf[3], buf[4]);
+
+	return buf[4];
+}
+
+void sec_ts_reinit(struct sec_ts_data *ts)
+{
+	u8 w_data[2] = {0x00, 0x00};
+	int ret = 0;
+
+	input_info(true, &ts->client->dev,
+			"%s : charger=0x%x, Cover=0x%x, Power mode=0x%x\n",
+			__func__, ts->charger_mode, ts->touch_functions, ts->lowpower_status);
+
+	/* charger mode */
+	if (ts->charger_mode != SEC_TS_BIT_CHARGER_MODE_NO) {
+		w_data[0] = ts->charger_mode;
+		ret = ts->sec_ts_i2c_write(ts, SET_TS_CMD_SET_CHARGER_MODE, (u8 *)&w_data[0], 1);
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "%s: Failed to send command(0x%x)",
+					__func__, SET_TS_CMD_SET_CHARGER_MODE);
+	}
+
+	/* Cover mode */
+	if (ts->touch_functions & SEC_TS_BIT_SETFUNC_COVER) {
+		w_data[0] = ts->cover_cmd;
+		ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_COVERTYPE, (u8 *)&w_data[0], 1);
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "%s: Failed to send command(0x%x)",
+					__func__, SEC_TS_CMD_SET_COVERTYPE);
+
+		ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_TOUCHFUNCTION, (u8 *)&(ts->touch_functions), 2);
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "%s: Failed to send command(0x%x)",
+					__func__, SEC_TS_CMD_SET_TOUCHFUNCTION);
+	}
+
+	if (ts->use_sponge)
+		sec_ts_set_custom_library(ts);
+
+	/* Power mode */
+	if (ts->lowpower_status == TO_LOWPOWER_MODE) {
+		w_data[0] = (ts->lowpower_mode & SEC_TS_MODE_LOWPOWER_FLAG) >> 1;
+		ret = sec_ts_i2c_write(ts, SEC_TS_CMD_WAKEUP_GESTURE_MODE, (u8 *)&w_data[0], 1);
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "%s: Failed to send command(0x%x)",
+					__func__, SEC_TS_CMD_WAKEUP_GESTURE_MODE);
+
+		w_data[0] = TO_LOWPOWER_MODE;
+		ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_POWER_MODE, (u8 *)&w_data[0], 1);
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "%s: Failed to send command(0x%x)",
+					__func__, SEC_TS_CMD_SET_POWER_MODE);
+
+		sec_ts_delay(50);
+
+		if (ts->lowpower_mode & SEC_TS_MODE_SPONGE_AOD) {
+			int i, ret;
+			u8 data[10] = {0x02, 0};
+
+			for (i = 0; i < 4; i++) {
+				data[i * 2 + 2] = ts->rect_data[i] & 0xFF;
+				data[i * 2 + 3] = (ts->rect_data[i] >> 8) & 0xFF;
+			}
+
+			ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SPONGE_WRITE_PARAM, &data[0], 10);
+			if (ret < 0)
+				input_err(true, &ts->client->dev, "%s: Failed to write offset\n", __func__);
+
+			ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SPONGE_NOTIFY_PACKET, NULL, 0);
+			if (ret < 0)
+				input_err(true, &ts->client->dev, "%s: Failed to send notify\n", __func__);
+
+		}
+
+	} else {
+
+		sec_ts_set_grip_type(ts, ONLY_EDGE_HANDLER);
+
+		if (ts->dex_mode) {
+			input_info(true, &ts->client->dev, "%s: set dex mode\n", __func__);
+			ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SET_DEX_MODE, &ts->dex_mode, 1);
+			if (ret < 0)
+				input_err(true, &ts->client->dev,
+						"%s: failed to set dex mode %x\n", __func__, ts->dex_mode);
+		}
+
+		if (ts->brush_mode) {
+			input_info(true, &ts->client->dev, "%s: set brush mode\n", __func__);
+			ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SET_BRUSH_MODE, &ts->brush_mode, 1);
+			if (ret < 0)
+				input_err(true, &ts->client->dev,
+						"%s: failed to set brush mode\n", __func__);
+		}
+
+		if (ts->touchable_area) {
+			input_info(true, &ts->client->dev, "%s: set 16:9 mode\n", __func__);
+			ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SET_TOUCHABLE_AREA, &ts->touchable_area, 1);
+			if (ret < 0)
+				input_err(true, &ts->client->dev,
+						"%s: failed to set 16:9 mode\n", __func__);
+		}
+
+	}
+	return;
+}
+
+#define MAX_EVENT_COUNT 32
+static void sec_ts_read_event(struct sec_ts_data *ts)
+{
+	int ret;
+	u8 t_id;
+	u8 event_id;
+	u8 left_event_count;
+	u8 read_event_buff[MAX_EVENT_COUNT][SEC_TS_EVENT_BUFF_SIZE] = { { 0 } };
+	u8 *event_buff;
+	struct sec_ts_event_coordinate *p_event_coord;
+	struct sec_ts_gesture_status *p_gesture_status;
+	struct sec_ts_event_status *p_event_status;
+	int curr_pos;
+	int remain_event_count = 0;
+	int pre_ttype = 0;
+	static bool error_report;
+
+	if (ts->power_status == SEC_TS_STATE_LPM) {
+
+		wake_lock_timeout(&ts->wakelock, msecs_to_jiffies(3 * MSEC_PER_SEC));
+		/* waiting for blsp block resuming, if not occurs i2c error */
+		ret = wait_for_completion_interruptible_timeout(&ts->resume_done, msecs_to_jiffies(3 * MSEC_PER_SEC));
+		if (ret == 0) {
+			input_err(true, &ts->client->dev, "%s: LPM: pm resume is not handled\n", __func__);
+			return;
+		}
+
+		if (ret < 0) {
+			input_err(true, &ts->client->dev, "%s: LPM: -ERESTARTSYS if interrupted, %d\n", __func__, ret);
+			return;
+		}
+
+		input_info(true, &ts->client->dev, "%s: run LPM interrupt handler, %d\n", __func__, ret);
+		/* run lpm interrupt handler */
+	}
+
+	ret = t_id = event_id = curr_pos = remain_event_count = 0;
+	/* repeat READ_ONE_EVENT until buffer is empty(No event) */
+	ret = sec_ts_i2c_read(ts, SEC_TS_READ_ONE_EVENT, (u8 *)read_event_buff[0], SEC_TS_EVENT_BUFF_SIZE);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: i2c read one event failed\n", __func__);
+		return;
+	}
+
+	if (ts->debug_flag & SEC_TS_DEBUG_PRINT_ONEEVENT)
+		input_info(true, &ts->client->dev, "ONE: %02X %02X %02X %02X %02X %02X %02X %02X\n",
+				read_event_buff[0][0], read_event_buff[0][1],
+				read_event_buff[0][2], read_event_buff[0][3],
+				read_event_buff[0][4], read_event_buff[0][5],
+				read_event_buff[0][6], read_event_buff[0][7]);
+
+	if (read_event_buff[0][0] == 0) {
+		input_info(true, &ts->client->dev, "%s: event buffer is empty\n", __func__);
+		return;
+	}
+
+	left_event_count = read_event_buff[0][7] & 0x3F;
+	remain_event_count = left_event_count;
+
+	if (left_event_count > MAX_EVENT_COUNT - 1) {
+		input_err(true, &ts->client->dev, "%s: event buffer overflow\n", __func__);
+
+		/* write clear event stack command when read_event_count > MAX_EVENT_COUNT */
+		ret = sec_ts_i2c_write(ts, SEC_TS_CMD_CLEAR_EVENT_STACK, NULL, 0);
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "%s: i2c write clear event failed\n", __func__);
+		return;
+	}
+
+	if (left_event_count > 0) {
+		ret = sec_ts_i2c_read(ts, SEC_TS_READ_ALL_EVENT, (u8 *)read_event_buff[1],
+				sizeof(u8) * (SEC_TS_EVENT_BUFF_SIZE) * (left_event_count));
+		if (ret < 0) {
+			input_err(true, &ts->client->dev, "%s: i2c read one event failed\n", __func__);
+			return;
+		}
+	}
+
+	do {
+		event_buff = read_event_buff[curr_pos];
+		event_id = event_buff[0] & 0x3;
+
+		if (ts->debug_flag & SEC_TS_DEBUG_PRINT_ALLEVENT)
+			input_info(true, &ts->client->dev, "ALL: %02X %02X %02X %02X %02X %02X %02X %02X\n",
+					event_buff[0], event_buff[1], event_buff[2], event_buff[3],
+					event_buff[4], event_buff[5], event_buff[6], event_buff[7]);
+
+		switch (event_id) {
+		case SEC_TS_STATUS_EVENT:
+			p_event_status = (struct sec_ts_event_status *)event_buff;
+
+			/* tchsta == 0 && ttype == 0 && eid == 0 : buffer empty */
+			if (p_event_status->stype > 0)
+				input_info(true, &ts->client->dev, "%s: STATUS %x %x %x %x %x %x %x %x\n", __func__,
+						event_buff[0], event_buff[1], event_buff[2],
+						event_buff[3], event_buff[4], event_buff[5],
+						event_buff[6], event_buff[7]);
+
+			/* watchdog reset -> send SENSEON command */
+			if ((p_event_status->stype == TYPE_STATUS_EVENT_INFO) &&
+					(p_event_status->status_id == SEC_TS_ACK_BOOT_COMPLETE) &&
+					(p_event_status->status_data_1 == 0x20)) {
+
+				sec_ts_unlocked_release_all_finger(ts);
+
+				ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SENSE_ON, NULL, 0);
+				if (ret < 0)
+					input_err(true, &ts->client->dev, "%s: fail to write Sense_on\n", __func__);
+				sec_ts_reinit(ts);
+			}
+
+			/* event queue full-> all finger release */
+			if ((p_event_status->stype == TYPE_STATUS_EVENT_ERR) &&
+					(p_event_status->status_id == SEC_TS_ERR_EVENT_QUEUE_FULL)) {
+				input_err(true, &ts->client->dev, "%s: IC Event Queue is full\n", __func__);
+				sec_ts_unlocked_release_all_finger(ts);
+			}
+
+			if ((p_event_status->stype == TYPE_STATUS_EVENT_ERR) &&
+					(p_event_status->status_id == SEC_TS_ERR_EVENT_ESD)) {
+				input_err(true, &ts->client->dev, "%s: ESD detected. run reset\n", __func__);
+#ifdef USE_RESET_DURING_POWER_ON
+				schedule_work(&ts->reset_work.work);
+#endif
+			}
+
+			if ((p_event_status->stype == TYPE_STATUS_EVENT_INFO) &&
+					(p_event_status->status_id == SEC_TS_ACK_WET_MODE)) {
+				ts->wet_mode = p_event_status->status_data_1;
+				input_info(true, &ts->client->dev, "%s: water wet mode %d\n",
+						__func__, ts->wet_mode);
+				if (ts->wet_mode)
+					ts->wet_count++;
+			}
+
+			if ((p_event_status->stype == TYPE_STATUS_EVENT_VENDOR_INFO) &&
+					(p_event_status->status_id == SEC_TS_VENDOR_ACK_NOISE_STATUS_NOTI)) {
+
+				ts->touch_noise_status = !!p_event_status->status_data_1;
+				input_info(true, &ts->client->dev, "%s: TSP NOISE MODE %s[%d]\n",
+						__func__, ts->touch_noise_status == 0 ? "OFF" : "ON",
+						p_event_status->status_data_1);
+
+				if (ts->touch_noise_status)
+					ts->noise_count++;
+			}
+
+			break;
+
+		case SEC_TS_COORDINATE_EVENT:
+			if (!error_report && ts->abc_err_flag) {
+				error_report = true;
+#ifdef CONFIG_SEC_ABC
+				sec_abc_send_event("MODULE=tsp@ERROR=power_status_mismatch");
+#endif
+			}
+			error_report = false;
+
+			if (ts->input_closed) {
+				input_err(true, &ts->client->dev, "%s: device is closed\n", __func__);
+				break;
+			}
+
+			p_event_coord = (struct sec_ts_event_coordinate *)event_buff;
+
+			t_id = (p_event_coord->tid - 1);
+
+			if (t_id < MAX_SUPPORT_TOUCH_COUNT + MAX_SUPPORT_HOVER_COUNT) {
+				pre_ttype = ts->coord[t_id].ttype;
+				ts->coord[t_id].id = t_id;
+				ts->coord[t_id].action = p_event_coord->tchsta;
+				ts->coord[t_id].x = (p_event_coord->x_11_4 << 4) | (p_event_coord->x_3_0);
+				ts->coord[t_id].y = (p_event_coord->y_11_4 << 4) | (p_event_coord->y_3_0);
+				ts->coord[t_id].z = p_event_coord->z & 0x3F;
+				ts->coord[t_id].ttype = p_event_coord->ttype_3_2 << 2 | p_event_coord->ttype_1_0 << 0;
+				ts->coord[t_id].major = p_event_coord->major;
+				ts->coord[t_id].minor = p_event_coord->minor;
+
+				if (!ts->coord[t_id].palm && (ts->coord[t_id].ttype == SEC_TS_TOUCHTYPE_PALM))
+					ts->coord[t_id].palm_count++;
+
+				ts->coord[t_id].palm = (ts->coord[t_id].ttype == SEC_TS_TOUCHTYPE_PALM);
+				ts->coord[t_id].left_event = p_event_coord->left_event;
+
+				if (ts->coord[t_id].z <= 0)
+					ts->coord[t_id].z = 1;
+
+				if ((ts->coord[t_id].ttype == SEC_TS_TOUCHTYPE_NORMAL)
+						|| (ts->coord[t_id].ttype == SEC_TS_TOUCHTYPE_PALM)
+						|| (ts->coord[t_id].ttype == SEC_TS_TOUCHTYPE_WET)
+						|| (ts->coord[t_id].ttype == SEC_TS_TOUCHTYPE_GLOVE)) {
+
+					if (ts->coord[t_id].action == SEC_TS_COORDINATE_ACTION_RELEASE) {
+						do_gettimeofday(&ts->time_released[t_id]);
+
+						if (ts->time_longest < (ts->time_released[t_id].tv_sec - ts->time_pressed[t_id].tv_sec))
+							ts->time_longest = (ts->time_released[t_id].tv_sec - ts->time_pressed[t_id].tv_sec);
+
+						input_mt_slot(ts->input_dev, t_id);
+						if (ts->plat_data->support_mt_pressure)
+							input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 0);
+						input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
+
+						if (ts->touch_count > 0)
+							ts->touch_count--;
+						if (ts->touch_count == 0) {
+							input_report_key(ts->input_dev, BTN_TOUCH, 0);
+							input_report_key(ts->input_dev, BTN_TOOL_FINGER, 0);
+							ts->check_multi = 0;
+						}
+
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+						input_info(true, &ts->client->dev,
+								"%s[R] tID:%d mc:%d tc:%d lx:%d ly:%d v:%02X%02X cal:%02X(%02X) id(%d,%d) p:%d noise:%x lp:(%x/%d)F%02X%02X D%05X, C%02XT01%02X.%4s%s\n",
+								ts->dex_name,
+								t_id, ts->coord[t_id].mcount, ts->touch_count,
+								ts->coord[t_id].x, ts->coord[t_id].y,
+								ts->plat_data->img_version_of_ic[2],
+								ts->plat_data->img_version_of_ic[3],
+								ts->cal_status, ts->nv, ts->tspid_val,
+								ts->tspicid_val, ts->coord[t_id].palm_count,
+								ts->touch_noise_status, ts->lowpower_mode,
+								ts->pressure_caller_id,	ts->pressure_cal_base,
+								ts->pressure_cal_delta, ts->defect_probability,
+								ts->tdata->cal_count, ts->tdata->tune_fix_ver,
+								ts->tdata->tclm_string[ts->tdata->cal_position].f_name,
+								(ts->tdata->tclm_level == TCLM_LEVEL_LOCKDOWN) ? ".L" : " ");
+#else
+						input_info(true, &ts->client->dev,
+								"%s[R] tID:%d mc:%d tc:%d v:%02X%02X cal:%02X(%02X) id(%d,%d) p:%d noise:%x lp:(%x/%d) F%02X%02X D%05X, C%02XT01%02X.%4s%s\n",
+								ts->dex_name,
+								t_id, ts->coord[t_id].mcount, ts->touch_count,
+								ts->plat_data->img_version_of_ic[2],
+								ts->plat_data->img_version_of_ic[3],
+								ts->cal_status, ts->nv, ts->tspid_val,
+								ts->tspicid_val, ts->coord[t_id].palm_count,
+								ts->touch_noise_status, ts->lowpower_mode,
+								ts->pressure_caller_id, ts->pressure_cal_base,
+								ts->pressure_cal_delta, ts->defect_probability,
+								ts->tdata->cal_count, ts->tdata->tune_fix_ver,
+								ts->tdata->tclm_string[ts->tdata->cal_position].f_name,
+								(ts->tdata->tclm_level == TCLM_LEVEL_LOCKDOWN) ? ".L" : " ");
+#endif
+						ts->coord[t_id].action = SEC_TS_COORDINATE_ACTION_NONE;
+						ts->coord[t_id].mcount = 0;
+						ts->coord[t_id].palm_count = 0;
+
+
+					} else if (ts->coord[t_id].action == SEC_TS_COORDINATE_ACTION_PRESS) {
+						do_gettimeofday(&ts->time_pressed[t_id]);
+
+						ts->touch_count++;
+						ts->all_finger_count++;
+
+						ts->max_z_value = max((unsigned int)ts->coord[t_id].z, ts->max_z_value);
+						ts->min_z_value = min((unsigned int)ts->coord[t_id].z, ts->min_z_value);
+						ts->sum_z_value += (unsigned int)ts->coord[t_id].z;
+
+						input_mt_slot(ts->input_dev, t_id);
+						input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 1);
+						input_report_key(ts->input_dev, BTN_TOUCH, 1);
+						input_report_key(ts->input_dev, BTN_TOOL_FINGER, 1);
+
+						input_report_abs(ts->input_dev, ABS_MT_POSITION_X, ts->coord[t_id].x);
+						input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, ts->coord[t_id].y);
+						input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, ts->coord[t_id].major);
+						input_report_abs(ts->input_dev, ABS_MT_TOUCH_MINOR, ts->coord[t_id].minor);
+						if (ts->brush_mode)
+							input_report_abs(ts->input_dev, ABS_MT_CUSTOM, (ts->coord[t_id].z << 1) | ts->coord[t_id].palm);
+						else
+							input_report_abs(ts->input_dev, ABS_MT_CUSTOM, (BRUSH_Z_DATA << 1) | ts->coord[t_id].palm);
+						if (ts->plat_data->support_mt_pressure)
+							input_report_abs(ts->input_dev, ABS_MT_PRESSURE, ts->coord[t_id].z);
+
+						if ((ts->touch_count > 4) && (ts->check_multi == 0)) {
+							ts->check_multi = 1;
+							ts->multi_count++;
+						}
+
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+						input_info(true, &ts->client->dev,
+								"%s[P] tID:%d x:%d y:%d z:%d major:%d minor:%d tc:%d type:%X noise:%x\n",
+								ts->dex_name, t_id, ts->coord[t_id].x,
+								ts->coord[t_id].y, ts->coord[t_id].z,
+								ts->coord[t_id].major, ts->coord[t_id].minor,
+								ts->touch_count,
+								ts->coord[t_id].ttype, ts->touch_noise_status);
+#else
+						input_info(true, &ts->client->dev,
+								"%s[P] tID:%d z:%d major:%d minor:%d tc:%d type:%X noise:%x\n",
+								ts->dex_name,
+								t_id, ts->coord[t_id].z, ts->coord[t_id].major,
+								ts->coord[t_id].minor, ts->touch_count,
+								ts->coord[t_id].ttype, ts->touch_noise_status);
+#endif
+					} else if (ts->coord[t_id].action == SEC_TS_COORDINATE_ACTION_MOVE) {
+						if ((ts->coord[t_id].ttype == SEC_TS_TOUCHTYPE_GLOVE) && !ts->touchkey_glove_mode_status) {
+							ts->touchkey_glove_mode_status = true;
+							input_report_switch(ts->input_dev, SW_GLOVE, 1);
+						} else if ((ts->coord[t_id].ttype != SEC_TS_TOUCHTYPE_GLOVE) && ts->touchkey_glove_mode_status) {
+							ts->touchkey_glove_mode_status = false;
+							input_report_switch(ts->input_dev, SW_GLOVE, 0);
+						}
+
+						input_mt_slot(ts->input_dev, t_id);
+						input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 1);
+						input_report_key(ts->input_dev, BTN_TOUCH, 1);
+						input_report_key(ts->input_dev, BTN_TOOL_FINGER, 1);
+
+						input_report_abs(ts->input_dev, ABS_MT_POSITION_X, ts->coord[t_id].x);
+						input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, ts->coord[t_id].y);
+						input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, ts->coord[t_id].major);
+						input_report_abs(ts->input_dev, ABS_MT_TOUCH_MINOR, ts->coord[t_id].minor);
+						if (ts->brush_mode)
+							input_report_abs(ts->input_dev, ABS_MT_CUSTOM, (ts->coord[t_id].z << 1) | ts->coord[t_id].palm);
+						else
+							input_report_abs(ts->input_dev, ABS_MT_CUSTOM, (BRUSH_Z_DATA << 1) | ts->coord[t_id].palm);
+
+						if (ts->plat_data->support_mt_pressure)
+							input_report_abs(ts->input_dev, ABS_MT_PRESSURE, ts->coord[t_id].z);
+						ts->coord[t_id].mcount++;
+					} else {
+						input_dbg(true, &ts->client->dev,
+								"%s: do not support coordinate action(%d)\n", __func__, ts->coord[t_id].action);
+					}
+
+					if ((ts->coord[t_id].action == SEC_TS_COORDINATE_ACTION_PRESS)
+							|| (ts->coord[t_id].action == SEC_TS_COORDINATE_ACTION_MOVE)) {
+
+						if (ts->coord[t_id].ttype != pre_ttype) {
+							input_info(true, &ts->client->dev, "%s : tID:%d ttype(%x->%x)\n",
+									__func__, ts->coord[t_id].id,
+									pre_ttype, ts->coord[t_id].ttype);
+						}
+					}
+
+				} else {
+					input_dbg(true, &ts->client->dev,
+							"%s: do not support coordinate type(%d)\n", __func__, ts->coord[t_id].ttype);
+				}
+			} else {
+				input_err(true, &ts->client->dev, "%s: tid(%d) is out of range\n", __func__, t_id);
+			}
+			break;
+
+		case SEC_TS_GESTURE_EVENT:
+			p_gesture_status = (struct sec_ts_gesture_status *)event_buff;
+
+			switch (p_gesture_status->stype) {
+			case SEC_TS_GESTURE_CODE_SPAY:
+				ts->scrub_id = SPONGE_EVENT_TYPE_SPAY;
+				input_info(true, &ts->client->dev, "%s: SPAY: %d\n", __func__, ts->scrub_id);
+				input_report_key(ts->input_dev, KEY_BLACK_UI_GESTURE, 1);
+				ts->all_spay_count++;
+				break;
+			case SEC_TS_GESTURE_CODE_DOUBLE_TAP:
+				ts->scrub_id = SPONGE_EVENT_TYPE_AOD_DOUBLETAB;
+				ts->scrub_x = (p_gesture_status->gesture_data_1 << 4)
+							| (p_gesture_status->gesture_data_3 >> 4);
+				ts->scrub_y = (p_gesture_status->gesture_data_2 << 4)
+							| (p_gesture_status->gesture_data_3 & 0x0F);
+
+#ifdef CONFIG_SAMSUNG_PRODUCT_SHIP
+				input_info(true, &ts->client->dev, "%s: AOD: %d\n", __func__, ts->scrub_id);
+#else
+				input_info(true, &ts->client->dev, "%s: AOD: %d, %d, %d\n",
+								__func__, ts->scrub_id, ts->scrub_x, ts->scrub_y);
+#endif
+				input_report_key(ts->input_dev, KEY_BLACK_UI_GESTURE, 1);
+				ts->all_aod_tap_count++;
+				break;
+			case SEC_TS_GESTURE_CODE_SINGLE_TAP:
+				ts->scrub_id = SPONGE_EVENT_TYPE_SINGLE_TAP;
+				ts->scrub_x = (p_gesture_status->gesture_data_1 << 4)
+							| (p_gesture_status->gesture_data_3 >> 4);
+				ts->scrub_y = (p_gesture_status->gesture_data_2 << 4)
+							| (p_gesture_status->gesture_data_3 & 0x0F);
+#ifdef CONFIG_SAMSUNG_PRODUCT_SHIP
+				input_info(true, &ts->client->dev, "%s: SINGLE TAP: %d\n", __func__, ts->scrub_id);
+#else
+				input_info(true, &ts->client->dev, "%s: SINGLE TAP: %d, %d, %d\n",
+						__func__, ts->scrub_id, ts->scrub_x, ts->scrub_y);
+#endif
+				input_report_key(ts->input_dev, KEY_BLACK_UI_GESTURE, 1);
+				break;
+			case SEC_TS_GESTURE_CODE_FORCE:
+				if (ts->power_status == SEC_TS_STATE_POWER_ON) {
+					if (p_gesture_status->gesture_id == SEC_TS_EVENT_PRESSURE_TOUCHED) {
+						ts->all_force_count++;
+						ts->scrub_id = SPONGE_EVENT_TYPE_PRESSURE_TOUCHED;
+					} else {
+						if (ts->scrub_id == SPONGE_EVENT_TYPE_AOD_HOMEKEY_PRESS) {
+							input_report_key(ts->input_dev, KEY_HOMEPAGE, 0);
+							ts->scrub_id = SPONGE_EVENT_TYPE_AOD_HOMEKEY_RELEASE;
+						} else {
+							ts->scrub_id = SPONGE_EVENT_TYPE_PRESSURE_RELEASED;
+						}
+					}
+					input_report_key(ts->input_dev, KEY_BLACK_UI_GESTURE, 1);
+				} else {
+					if (p_gesture_status->gesture_id == SEC_TS_EVENT_PRESSURE_RELEASED) {
+						input_report_key(ts->input_dev, KEY_HOMEPAGE, 0);
+						input_report_key(ts->input_dev, KEY_BLACK_UI_GESTURE, 1);
+						ts->scrub_id = SPONGE_EVENT_TYPE_AOD_HOMEKEY_RELEASE_NO_HAPTIC;
+						input_sync(ts->input_dev);
+
+						haptic_homekey_release();
+					} else {
+						input_report_key(ts->input_dev, KEY_HOMEPAGE, 1);
+						ts->scrub_id = SPONGE_EVENT_TYPE_AOD_HOMEKEY_PRESS;
+						input_sync(ts->input_dev);
+
+						haptic_homekey_press();
+						ts->all_force_count++;
+					}
+				}
+
+				ts->scrub_x = (p_gesture_status->gesture_data_1 << 4)
+							| (p_gesture_status->gesture_data_3 >> 4);
+				ts->scrub_y = (p_gesture_status->gesture_data_2 << 4)
+							| (p_gesture_status->gesture_data_3 & 0x0F);
+
+#ifdef CONFIG_SAMSUNG_PRODUCT_SHIP
+				input_info(true, &ts->client->dev, "%s: FORCE: %d\n", __func__, ts->scrub_id);
+#else
+				input_info(true, &ts->client->dev, "%s: FORCE: %d, %d, %d\n",
+								__func__, ts->scrub_id, ts->scrub_x, ts->scrub_y);
+#endif
+				break;
+			}
+
+			input_sync(ts->input_dev);
+			input_report_key(ts->input_dev, KEY_BLACK_UI_GESTURE, 0);
+			break;
+
+		default:
+			input_err(true, &ts->client->dev, "%s: unknown event %x %x %x %x %x %x\n", __func__,
+					event_buff[0], event_buff[1], event_buff[2],
+					event_buff[3], event_buff[4], event_buff[5]);
+			break;
+		}
+
+		curr_pos++;
+		remain_event_count--;
+	} while (remain_event_count >= 0);
+
+	input_sync(ts->input_dev);
+}
+
+static irqreturn_t sec_ts_irq_thread(int irq, void *ptr)
+{
+	struct sec_ts_data *ts = (struct sec_ts_data *)ptr;
+
+#ifdef CONFIG_SECURE_TOUCH
+	if (secure_filter_interrupt(ts) == IRQ_HANDLED) {
+		wait_for_completion_interruptible_timeout(&ts->secure_interrupt,
+				msecs_to_jiffies(5 * MSEC_PER_SEC));
+
+		input_info(true, &ts->client->dev,
+				"%s: secure interrupt handled\n", __func__);
+
+		return IRQ_HANDLED;
+	}
+#endif
+
+	mutex_lock(&ts->eventlock);
+
+	sec_ts_read_event(ts);
+
+	mutex_unlock(&ts->eventlock);
+
+	return IRQ_HANDLED;
+}
+
+int get_tsp_status(void)
+{
+	return 0;
+}
+EXPORT_SYMBOL(get_tsp_status);
+
+void sec_ts_set_charger(bool enable)
+{
+	return;
+#if 0
+	int ret;
+	u8 noise_mode_on[] = {0x01};
+	u8 noise_mode_off[] = {0x00};
+
+	if (enable) {
+		input_info(true, &ts->client->dev, "sec_ts_set_charger : charger CONNECTED!!\n");
+		ret = sec_ts_i2c_write(ts, SEC_TS_CMD_NOISE_MODE, noise_mode_on, sizeof(noise_mode_on));
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "sec_ts_set_charger: fail to write NOISE_ON\n");
+	} else {
+		input_info(true, &ts->client->dev, "sec_ts_set_charger : charger DISCONNECTED!!\n");
+		ret = sec_ts_i2c_write(ts, SEC_TS_CMD_NOISE_MODE, noise_mode_off, sizeof(noise_mode_off));
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "sec_ts_set_charger: fail to write NOISE_OFF\n");
+	}
+#endif
+}
+EXPORT_SYMBOL(sec_ts_set_charger);
+
+int sec_ts_glove_mode_enables(struct sec_ts_data *ts, int mode)
+{
+	int ret;
+
+	if (mode)
+		ts->touch_functions = (ts->touch_functions | SEC_TS_BIT_SETFUNC_GLOVE | SEC_TS_DEFAULT_ENABLE_BIT_SETFUNC);
+	else
+		ts->touch_functions = ((ts->touch_functions & (~SEC_TS_BIT_SETFUNC_GLOVE)) | SEC_TS_DEFAULT_ENABLE_BIT_SETFUNC);
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev, "%s: pwr off, glove:%d, status:%x\n", __func__,
+				mode, ts->touch_functions);
+		goto glove_enable_err;
+	}
+
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_TOUCHFUNCTION, (u8 *)&ts->touch_functions, 2);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: Failed to send command", __func__);
+		goto glove_enable_err;
+	}
+
+	input_info(true, &ts->client->dev, "%s: glove:%d, status:%x\n", __func__,
+			mode, ts->touch_functions);
+
+	return 0;
+
+glove_enable_err:
+	return -EIO;
+}
+EXPORT_SYMBOL(sec_ts_glove_mode_enables);
+
+int sec_ts_set_cover_type(struct sec_ts_data *ts, bool enable)
+{
+	int ret;
+
+	input_info(true, &ts->client->dev, "%s: %d\n", __func__, ts->cover_type);
+
+
+	switch (ts->cover_type) {
+	case SEC_TS_VIEW_WIRELESS:
+	case SEC_TS_VIEW_COVER:
+	case SEC_TS_VIEW_WALLET:
+	case SEC_TS_FLIP_WALLET:
+	case SEC_TS_LED_COVER:
+	case SEC_TS_MONTBLANC_COVER:
+	case SEC_TS_CLEAR_FLIP_COVER:
+	case SEC_TS_QWERTY_KEYBOARD_EUR:
+	case SEC_TS_QWERTY_KEYBOARD_KOR:
+		ts->cover_cmd = (u8)ts->cover_type;
+		break;
+	case SEC_TS_CHARGER_COVER:
+	case SEC_TS_COVER_NOTHING1:
+	case SEC_TS_COVER_NOTHING2:
+	default:
+		ts->cover_cmd = 0;
+		input_err(true, &ts->client->dev, "%s: not chage touch state, %d\n",
+				__func__, ts->cover_type);
+		break;
+	}
+
+	if (enable)
+		ts->touch_functions = (ts->touch_functions | SEC_TS_BIT_SETFUNC_COVER | SEC_TS_DEFAULT_ENABLE_BIT_SETFUNC);
+	else
+		ts->touch_functions = ((ts->touch_functions & (~SEC_TS_BIT_SETFUNC_COVER)) | SEC_TS_DEFAULT_ENABLE_BIT_SETFUNC);
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev, "%s: pwr off, close:%d, status:%x\n", __func__,
+				enable, ts->touch_functions);
+		goto cover_enable_err;
+	}
+
+	if (enable) {
+		ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_COVERTYPE, &ts->cover_cmd, 1);
+		if (ret < 0) {
+			input_err(true, &ts->client->dev, "%s: Failed to send covertype command: %d", __func__, ts->cover_cmd);
+			goto cover_enable_err;
+		}
+	}
+
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_TOUCHFUNCTION, (u8 *)&(ts->touch_functions), 2);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: Failed to send command", __func__);
+		goto cover_enable_err;
+	}
+
+	input_info(true, &ts->client->dev, "%s: close:%d, status:%x\n", __func__,
+			enable, ts->touch_functions);
+
+	return 0;
+
+cover_enable_err:
+	return -EIO;
+
+
+}
+EXPORT_SYMBOL(sec_ts_set_cover_type);
+
+void sec_ts_set_grip_type(struct sec_ts_data *ts, u8 set_type)
+{
+	u8 mode = G_NONE;
+
+	input_info(true, &ts->client->dev, "%s: re-init grip(%d), edh:%d, edg:%d, lan:%d\n", __func__,
+			set_type, ts->grip_edgehandler_direction, ts->grip_edge_range, ts->grip_landscape_mode);
+
+	/* edge handler */
+	if (ts->grip_edgehandler_direction != 0)
+		mode |= G_SET_EDGE_HANDLER;
+
+	if (set_type == GRIP_ALL_DATA) {
+		/* edge */
+		if (ts->grip_edge_range != 60)
+			mode |= G_SET_EDGE_ZONE;
+
+		/* dead zone */
+		if (ts->grip_landscape_mode == 1)	/* default 0 mode, 32 */
+			mode |= G_SET_LANDSCAPE_MODE;
+		else
+			mode |= G_SET_NORMAL_MODE;
+	}
+
+	if (mode)
+		set_grip_data_to_ic(ts, mode);
+
+}
+
+/* for debugging--------------------------------------------------------------------------------------*/
+
+static int sec_ts_pinctrl_configure(struct sec_ts_data *ts, bool enable)
+{
+	struct pinctrl_state *state;
+
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, enable ? "ACTIVE" : "SUSPEND");
+
+	if (enable) {
+		state = pinctrl_lookup_state(ts->plat_data->pinctrl, "on_state");
+		if (IS_ERR(ts->plat_data->pinctrl))
+			input_err(true, &ts->client->dev, "%s: could not get active pinstate\n", __func__);
+	} else {
+		state = pinctrl_lookup_state(ts->plat_data->pinctrl, "off_state");
+		if (IS_ERR(ts->plat_data->pinctrl))
+			input_err(true, &ts->client->dev, "%s: could not get suspend pinstate\n", __func__);
+	}
+
+	if (!IS_ERR_OR_NULL(state))
+		return pinctrl_select_state(ts->plat_data->pinctrl, state);
+
+	return 0;
+
+}
+
+static int sec_ts_power(void *data, bool on)
+{
+	struct sec_ts_data *ts = (struct sec_ts_data *)data;
+	const struct sec_ts_plat_data *pdata = ts->plat_data;
+	struct regulator *regulator_dvdd = NULL;
+	struct regulator *regulator_avdd = NULL;
+	static bool enabled;
+	int ret = 0;
+
+	if (enabled == on)
+		return ret;
+
+	if (pdata->use_gpio_ldo) {
+		regulator_avdd = regulator_get(NULL, pdata->regulator_avdd);
+		if (IS_ERR_OR_NULL(regulator_avdd)) {
+			input_err(true, &ts->client->dev, "%s: Failed to get %s regulator.\n",
+				 __func__, pdata->regulator_avdd);
+			ret = PTR_ERR(regulator_avdd);
+			goto use_gpio_ldo_error;
+		}
+
+		if (on) {
+			ret = regulator_enable(regulator_avdd);
+			if (ret) {
+				input_err(true, &ts->client->dev, "%s: Failed to enable vdd: %d\n", __func__, ret);
+				goto use_gpio_ldo_out;
+			}
+		} else {
+			regulator_disable(regulator_avdd);
+		}
+
+		enabled = on;
+
+use_gpio_ldo_out:
+		input_err(true, &ts->client->dev, "%s: %s: avdd:%s\n", __func__, on ? "on" : "off",
+			regulator_is_enabled(regulator_avdd) ? "on" : "off");
+
+use_gpio_ldo_error:
+		regulator_put(regulator_avdd);
+	} else {
+		regulator_dvdd = regulator_get(NULL, pdata->regulator_dvdd);
+		if (IS_ERR_OR_NULL(regulator_dvdd)) {
+			input_err(true, &ts->client->dev, "%s: Failed to get %s regulator.\n",
+				 __func__, pdata->regulator_dvdd);
+			ret = PTR_ERR(regulator_dvdd);
+			goto error;
+		}
+
+		regulator_avdd = regulator_get(NULL, pdata->regulator_avdd);
+		if (IS_ERR_OR_NULL(regulator_avdd)) {
+			input_err(true, &ts->client->dev, "%s: Failed to get %s regulator.\n",
+				 __func__, pdata->regulator_avdd);
+			ret = PTR_ERR(regulator_avdd);
+			goto error;
+		}
+
+		if (on) {
+			ret = regulator_enable(regulator_dvdd);
+			if (ret) {
+				input_err(true, &ts->client->dev, "%s: Failed to enable avdd: %d\n", __func__, ret);
+				goto out;
+			}
+
+			sec_ts_delay(1);
+
+			ret = regulator_enable(regulator_avdd);
+			if (ret) {
+				input_err(true, &ts->client->dev, "%s: Failed to enable vdd: %d\n", __func__, ret);
+				goto out;
+			}
+		} else {
+			regulator_disable(regulator_dvdd);
+			regulator_disable(regulator_avdd);
+		}
+
+		enabled = on;
+
+out:
+		input_err(true, &ts->client->dev, "%s: %s: avdd:%s, dvdd:%s\n", __func__, on ? "on" : "off",
+			regulator_is_enabled(regulator_avdd) ? "on" : "off",
+			regulator_is_enabled(regulator_dvdd) ? "on" : "off");
+
+error:
+		regulator_put(regulator_dvdd);
+		regulator_put(regulator_avdd);
+	}
+
+	return ret;
+}
+
+static int sec_ts_parse_dt(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct sec_ts_plat_data *pdata = dev->platform_data;
+	struct device_node *np = dev->of_node;
+	u32 coords[2];
+	int ret = 0;
+	int count = 0;
+	u32 ic_match_value;
+#if !defined(CONFIG_EXYNOS_DECON_MDNIE_LITE)
+	int lcdtype = 0;
+#endif
+#if 0 /*defined(CONFIG_EXYNOS_DECON_FB)*/
+	int connected;
+#endif
+
+	pdata->tsp_icid = of_get_named_gpio(np, "sec,tsp-icid_gpio", 0);
+	if (gpio_is_valid(pdata->tsp_icid)) {
+		input_info(true, dev, "%s: TSP_ICID : %d\n", __func__, gpio_get_value(pdata->tsp_icid));
+		if (of_property_read_u32(np, "sec,icid_match_value", &ic_match_value)) {
+			input_err(true, dev, "%s: Failed to get icid match value\n", __func__);
+			return -EINVAL;
+		}
+
+		if (gpio_get_value(pdata->tsp_icid) != ic_match_value) {
+			input_err(true, dev, "%s: Do not match TSP_ICID\n", __func__);
+			return -EINVAL;
+		}
+	} else {
+		input_err(true, dev, "%s: Failed to get tsp-icid gpio\n", __func__);
+	}
+
+	pdata->tsp_vsync = of_get_named_gpio(np, "sec,tsp_vsync_gpio", 0);
+	if (gpio_is_valid(pdata->tsp_vsync))
+		input_info(true, &client->dev, "%s: vsync %s\n", __func__,
+				gpio_get_value(pdata->tsp_vsync) ? "disable" : "enable");
+
+	pdata->irq_gpio = of_get_named_gpio(np, "sec,irq_gpio", 0);
+	if (gpio_is_valid(pdata->irq_gpio)) {
+		ret = gpio_request_one(pdata->irq_gpio, GPIOF_DIR_IN, "sec,tsp_int");
+		if (ret) {
+			input_err(true, &client->dev, "%s: Unable to request tsp_int [%d]\n", __func__, pdata->irq_gpio);
+			return -EINVAL;
+		}
+	} else {
+		input_err(true, &client->dev, "%s: Failed to get irq gpio\n", __func__);
+		return -EINVAL;
+	}
+
+	client->irq = gpio_to_irq(pdata->irq_gpio);
+
+	if (of_property_read_u32(np, "sec,irq_type", &pdata->irq_type)) {
+		input_err(true, dev, "%s: Failed to get irq_type property\n", __func__);
+		pdata->irq_type = IRQF_TRIGGER_LOW | IRQF_ONESHOT;
+	}
+
+	if (of_property_read_u32(np, "sec,i2c-burstmax", &pdata->i2c_burstmax)) {
+		input_dbg(false, &client->dev, "%s: Failed to get i2c_burstmax property\n", __func__);
+		pdata->i2c_burstmax = 256;
+	}
+
+	if (of_property_read_u32_array(np, "sec,max_coords", coords, 2)) {
+		input_err(true, &client->dev, "%s: Failed to get max_coords property\n", __func__);
+		return -EINVAL;
+	}
+	pdata->max_x = coords[0] - 1;
+	pdata->max_y = coords[1] - 1;
+
+	pdata->tsp_id = of_get_named_gpio(np, "sec,tsp-id_gpio", 0);
+	if (gpio_is_valid(pdata->tsp_id))
+		input_info(true, dev, "%s: TSP_ID : %d\n", __func__, gpio_get_value(pdata->tsp_id));
+	else
+		input_err(true, dev, "%s: Failed to get tsp-id gpio\n", __func__);
+
+	count = of_property_count_strings(np, "sec,firmware_name");
+	if (count <= 0) {
+		pdata->firmware_name = NULL;
+	} else {
+		if (gpio_is_valid(pdata->tsp_id))
+			of_property_read_string_index(np, "sec,firmware_name", gpio_get_value(pdata->tsp_id), &pdata->firmware_name);
+		else
+			of_property_read_string_index(np, "sec,firmware_name", 0, &pdata->firmware_name);
+	}
+
+	if (of_property_read_string_index(np, "sec,project_name", 0, &pdata->project_name))
+		input_err(true, &client->dev, "%s: skipped to get project_name property\n", __func__);
+	if (of_property_read_string_index(np, "sec,project_name", 1, &pdata->model_name))
+		input_err(true, &client->dev, "%s: skipped to get model_name property\n", __func__);
+
+#if defined(CONFIG_FB_MSM_MDSS_SAMSUNG)
+	lcdtype = get_lcd_attached("GET");
+	if (lcdtype == 0xFFFFFF) {
+		input_err(true, &client->dev, "%s: lcd is not attached\n", __func__);
+		return -ENODEV;
+	}
+#endif
+
+#if defined(CONFIG_EXYNOS_DECON_MDNIE_LITE)
+	if (lcdtype == 0) {
+		input_err(true, &client->dev, "%s: lcd is not attached\n", __func__);
+		return -ENODEV;
+	}
+#endif
+
+#if 0 /*defined(CONFIG_EXYNOS_DECON_FB)*/
+	connected = get_lcd_info("connected");
+	if (connected < 0) {
+		input_err(true, dev, "%s: Failed to get lcd info\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!connected) {
+		input_err(true, &client->dev, "%s: lcd is disconnected\n", __func__);
+		return -ENODEV;
+	}
+
+	input_info(true, &client->dev, "%s: lcd is connected\n", __func__);
+
+	lcdtype = get_lcd_info("id");
+	if (lcdtype < 0) {
+		input_err(true, dev, "%s: Failed to get lcd info\n", __func__);
+		return -EINVAL;
+	}
+#endif
+
+	input_info(true, &client->dev, "%s: lcdtype 0x%08X\n", __func__, lcdtype);
+
+	if (strncmp(pdata->model_name, "G950", 4) == 0)
+		pdata->panel_revision = 0;
+	else
+		pdata->panel_revision = ((lcdtype >> 8) & 0xFF) >> 4;
+
+	pdata->use_gpio_ldo = of_property_read_bool(np, "sec,use_gpio_ldo");
+
+	if (pdata->use_gpio_ldo) {
+		input_info(true, dev, "%s: use tsp_ldo_en\n", __func__);
+		if (of_property_read_string(np, "sec,regulator_avdd", &pdata->regulator_avdd)) {
+			input_err(true, dev, "%s: Failed to get regulator_avdd name property\n", __func__);
+			return -EINVAL;
+		}
+	} else {
+		if (of_property_read_string(np, "sec,regulator_dvdd", &pdata->regulator_dvdd)) {
+			input_err(true, dev, "%s: Failed to get regulator_dvdd name property\n", __func__);
+			return -EINVAL;
+		}
+
+		if (of_property_read_string(np, "sec,regulator_avdd", &pdata->regulator_avdd)) {
+			input_err(true, dev, "%s: Failed to get regulator_avdd name property\n", __func__);
+			return -EINVAL;
+		}
+	}
+	pdata->power = sec_ts_power;
+
+	if (of_property_read_u32(np, "sec,always_lpmode", &pdata->always_lpmode) < 0)
+		pdata->always_lpmode = 0;
+
+	if (of_property_read_string(np, "pressure-sensor", &pdata->support_pressure) < 0) {
+		input_err(true, dev, "%s: Failed to get pressure-sensor property\n", __func__);
+	}
+
+	if (of_property_read_u32(np, "sec,bringup", &pdata->bringup) < 0)
+		pdata->bringup = 0;
+
+	if (of_property_read_u32(np, "sec,mis_cal_check", &pdata->mis_cal_check) < 0)
+		pdata->mis_cal_check = 0;
+
+	pdata->regulator_boot_on = of_property_read_bool(np, "sec,regulator_boot_on");
+	pdata->support_sidegesture = of_property_read_bool(np, "sec,support_sidegesture");
+	pdata->support_dex = of_property_read_bool(np, "support_dex_mode");
+	pdata->use_ic_resolution = of_property_read_bool(np, "sec,use_ic_resolution");
+
+#ifdef CONFIG_SEC_FACTORY
+	pdata->support_mt_pressure = true;
+#endif
+
+	input_err(true, &client->dev, "%s: i2c buffer limit: %d, lcd_id:%06X, bringup:%d, FW:%s(%d), id:%d,%d, mis_cal:%d dex:%d, gesture:%d pressure:%s\n",
+		__func__, pdata->i2c_burstmax, lcdtype, pdata->bringup, pdata->firmware_name,
+			count, pdata->tsp_id, pdata->tsp_icid, pdata->mis_cal_check,
+			pdata->support_dex, pdata->support_sidegesture, pdata->support_pressure);
+	return ret;
+}
+
+static void sec_tclm_parse_dt(struct i2c_client *client, struct sec_tclm_data *tdata)
+{
+	struct device *dev = &client->dev;
+	struct device_node *np = dev->of_node;
+
+	if (of_property_read_u32(np, "sec,tclm_level", &tdata->tclm_level) < 0) {
+		tdata->tclm_level = 0;
+		input_err(true, dev, "%s: Failed to get tclm_level property\n", __func__);
+	}
+
+	if (of_property_read_u32(np, "sec,afe_base", &tdata->afe_base) < 0) {
+		tdata->afe_base = 0;
+		input_err(true, dev, "%s: Failed to get afe_base property\n", __func__);
+	}
+
+	input_err(true, &client->dev, "%s: tclm_level %d, sec_afe_base 01%02X\n", __func__, tdata->tclm_level, tdata->afe_base);
+
+}
+
+
+int sec_ts_read_information(struct sec_ts_data *ts)
+{
+	unsigned char data[13] = { 0 };
+	int ret;
+
+	memset(data, 0x0, 3);
+	ret = sec_ts_i2c_read(ts, SEC_TS_READ_ID, data, 3);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev,
+				"%s: failed to read device id(%d)\n",
+				__func__, ret);
+		return ret;
+	}
+
+	input_info(true, &ts->client->dev,
+			"%s: %X, %X, %X\n",
+			__func__, data[0], data[1], data[2]);
+	memset(data, 0x0, 11);
+	ret = sec_ts_i2c_read(ts,  SEC_TS_READ_PANEL_INFO, data, 11);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev,
+				"%s: failed to read sub id(%d)\n",
+				__func__, ret);
+		return ret;
+	}
+
+	input_info(true, &ts->client->dev,
+			"%s: nTX:%X, nRX:%X, rY:%d, rX:%d\n",
+			__func__, data[8], data[9],
+			(data[2] << 8) | data[3], (data[0] << 8) | data[1]);
+
+	/* Set X,Y Resolution from IC information. */
+	if (ts->plat_data->use_ic_resolution) {
+		if (((data[0] << 8) | data[1]) > 0)
+			ts->plat_data->max_x = ((data[0] << 8) | data[1]) - 1;
+
+		if (((data[2] << 8) | data[3]) > 0)
+			ts->plat_data->max_y = ((data[2] << 8) | data[3]) - 1;
+	}
+
+	ts->tx_count = data[8];
+	ts->rx_count = data[9];
+
+	data[0] = 0;
+	ret = sec_ts_i2c_read(ts, SEC_TS_READ_BOOT_STATUS, data, 1);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev,
+				"%s: failed to read sub id(%d)\n",
+				__func__, ret);
+		return ret;
+	}
+
+	input_info(true, &ts->client->dev,
+			"%s: STATUS : %X\n",
+			__func__, data[0]);
+
+	memset(data, 0x0, 4);
+	ret = sec_ts_i2c_read(ts, SEC_TS_READ_TS_STATUS, data, 4);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev,
+				"%s: failed to read sub id(%d)\n",
+				__func__, ret);
+		return ret;
+	}
+
+	input_info(true, &ts->client->dev,
+			"%s: TOUCH STATUS : %02X, %02X, %02X, %02X\n",
+			__func__, data[0], data[1], data[2], data[3]);
+	ret = sec_ts_i2c_read(ts, SEC_TS_CMD_SET_TOUCHFUNCTION,  (u8 *)&(ts->touch_functions), 2);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev,
+				"%s: failed to read touch functions(%d)\n",
+				__func__, ret);
+		return ret;
+	}
+
+	input_info(true, &ts->client->dev,
+			"%s: Functions : %02X\n",
+			__func__, ts->touch_functions);
+
+	return ret;
+}
+
+#ifdef SEC_TS_SUPPORT_SPONGELIB
+int sec_ts_set_custom_library(struct sec_ts_data *ts)
+{
+	u8 data[3] = { 0 };
+	int ret;
+
+	input_err(true, &ts->client->dev, "%s: Sponge (0x%02x)\n",
+			__func__, ts->lowpower_mode);
+
+	data[2] = ts->lowpower_mode;
+
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SPONGE_WRITE_PARAM, &data[0], 3);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: Failed to Sponge\n", __func__);
+
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SPONGE_NOTIFY_PACKET, NULL, 0);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: Failed to send NOTIFY SPONGE\n", __func__);
+
+	return ret;
+}
+
+int sec_ts_check_custom_library(struct sec_ts_data *ts)
+{
+	u8 data[10] = { 0 };
+	int ret = -1;
+
+	ret = ts->sec_ts_i2c_read(ts, SEC_TS_CMD_SPONGE_GET_INFO, &data[0], 10);
+
+	input_info(true, &ts->client->dev,
+			"%s: (%d) %c%c%c%c, || %02X, %02X, %02X, %02X, || %02X, %02X\n",
+			__func__, ret, data[0], data[1], data[2], data[3], data[4],
+			data[5], data[6], data[7], data[8], data[9]);
+
+	/* compare model name with device tree */
+	if (ts->plat_data->model_name)
+		ret = strncmp(data, ts->plat_data->model_name, 4);
+
+	if (ret == 0)
+		ts->use_sponge = true;
+	else
+		ts->use_sponge = false;
+
+	input_err(true, &ts->client->dev, "%s: use %s\n",
+			__func__, ts->use_sponge ? "SPONGE" : "VENDOR");
+
+	return ret;
+}
+#endif
+
+static void sec_ts_set_input_prop(struct sec_ts_data *ts, struct input_dev *dev, u8 propbit)
+{
+	static char sec_ts_phys[64] = { 0 };
+
+	snprintf(sec_ts_phys, sizeof(sec_ts_phys), "%s/input1",
+			dev->name);
+	dev->phys = sec_ts_phys;
+	dev->id.bustype = BUS_I2C;
+	dev->dev.parent = &ts->client->dev;
+
+	set_bit(EV_SYN, dev->evbit);
+	set_bit(EV_KEY, dev->evbit);
+	set_bit(EV_ABS, dev->evbit);
+	set_bit(EV_SW, dev->evbit);
+	set_bit(BTN_TOUCH, dev->keybit);
+	set_bit(BTN_TOOL_FINGER, dev->keybit);
+	set_bit(KEY_BLACK_UI_GESTURE, dev->keybit);
+#ifdef SEC_TS_SUPPORT_TOUCH_KEY
+	if (ts->plat_data->support_mskey) {
+		int i;
+
+		for (i = 0 ; i < ts->plat_data->num_touchkey ; i++)
+			set_bit(ts->plat_data->touchkey[i].keycode, dev->keybit);
+
+		set_bit(EV_LED, dev->evbit);
+		set_bit(LED_MISC, dev->ledbit);
+	}
+#endif
+	if (ts->plat_data->support_sidegesture) {
+		set_bit(KEY_SIDE_GESTURE, dev->keybit);
+		set_bit(KEY_SIDE_GESTURE_RIGHT, dev->keybit);
+		set_bit(KEY_SIDE_GESTURE_LEFT, dev->keybit);
+	}
+	set_bit(propbit, dev->propbit);
+	set_bit(KEY_HOMEPAGE, dev->keybit);
+
+	input_set_capability(dev, EV_SW, SW_GLOVE);
+
+	input_set_abs_params(dev, ABS_MT_POSITION_X, 0, ts->plat_data->max_x, 0, 0);
+	input_set_abs_params(dev, ABS_MT_POSITION_Y, 0, ts->plat_data->max_y, 0, 0);
+	input_set_abs_params(dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(dev, ABS_MT_TOUCH_MINOR, 0, 255, 0, 0);
+	input_set_abs_params(dev, ABS_MT_CUSTOM, 0, 0xFFFF, 0, 0);
+	if (ts->plat_data->support_mt_pressure)
+		input_set_abs_params(dev, ABS_MT_PRESSURE, 0, 255, 0, 0);
+
+	if (propbit == INPUT_PROP_POINTER)
+		input_mt_init_slots(dev, MAX_SUPPORT_TOUCH_COUNT, INPUT_MT_POINTER);
+	else
+		input_mt_init_slots(dev, MAX_SUPPORT_TOUCH_COUNT, INPUT_MT_DIRECT);
+
+	input_set_drvdata(dev, ts);
+}
+
+static int sec_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct sec_ts_data *ts;
+	struct sec_ts_plat_data *pdata;
+	struct sec_tclm_data *tdata = NULL;
+	int ret = 0;
+	bool force_update = false;
+	bool valid_firmware_integrity = false;
+	unsigned char data[5] = { 0 };
+	unsigned char deviceID[5] = { 0 };
+	unsigned char result = 0;
+
+	input_info(true, &client->dev, "%s\n", __func__);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		input_err(true, &client->dev, "%s: EIO err!\n", __func__);
+		return -EIO;
+	}
+
+	/* parse dt */
+	if (client->dev.of_node) {
+		pdata = devm_kzalloc(&client->dev,
+				sizeof(struct sec_ts_plat_data), GFP_KERNEL);
+
+		if (!pdata) {
+			input_err(true, &client->dev, "%s: Failed to allocate platform data\n", __func__);
+			goto error_allocate_pdata;
+		}
+
+		client->dev.platform_data = pdata;
+
+		ret = sec_ts_parse_dt(client);
+		if (ret) {
+			input_err(true, &client->dev, "%s: Failed to parse dt\n", __func__);
+			goto error_allocate_mem;
+		}
+		tdata = devm_kzalloc(&client->dev,
+				sizeof(struct sec_tclm_data), GFP_KERNEL);
+		if (!tdata)
+			goto error_allocate_tdata;
+
+		sec_tclm_parse_dt(client, tdata);
+	} else {
+		pdata = client->dev.platform_data;
+		if (!pdata) {
+			input_err(true, &client->dev, "%s: No platform data found\n", __func__);
+			goto error_allocate_pdata;
+		}
+	}
+
+	if (!pdata->power) {
+		input_err(true, &client->dev, "%s: No power contorl found\n", __func__);
+		goto error_allocate_mem;
+	}
+
+	pdata->pinctrl = devm_pinctrl_get(&client->dev);
+	if (IS_ERR(pdata->pinctrl))
+		input_err(true, &client->dev, "%s: could not get pinctrl\n", __func__);
+
+	ts = kzalloc(sizeof(struct sec_ts_data), GFP_KERNEL);
+	if (!ts)
+		goto error_allocate_mem;
+
+	ts->client = client;
+	ts->plat_data = pdata;
+	ts->crc_addr = 0x0001FE00;
+	ts->fw_addr = 0x00002000;
+	ts->para_addr = 0x18000;
+	ts->flash_page_size = SEC_TS_FW_BLK_SIZE_DEFAULT;
+	ts->sec_ts_i2c_read = sec_ts_i2c_read;
+	ts->sec_ts_i2c_write = sec_ts_i2c_write;
+	ts->sec_ts_i2c_write_burst = sec_ts_i2c_write_burst;
+	ts->sec_ts_i2c_read_bulk = sec_ts_i2c_read_bulk;
+	ts->i2c_burstmax = pdata->i2c_burstmax;
+
+	ts->tdata = tdata;
+	if (!ts->tdata)
+		goto err_null_tdata;
+	sec_tclm_initialize(ts->tdata);
+#ifdef TCLM_CONCEPT
+	ts->tdata->client = ts->client;
+	ts->tdata->tclm_read = sec_tclm_data_read;
+	ts->tdata->tclm_write = sec_tclm_data_write;
+	ts->tdata->tclm_execute_force_calibration = sec_tclm_execute_force_calibration;
+	ts->tdata->irq = client->irq;
+#endif
+
+#ifdef USE_POWER_RESET_WORK
+	INIT_DELAYED_WORK(&ts->reset_work, sec_ts_reset_work);
+#endif
+	INIT_DELAYED_WORK(&ts->work_read_info, sec_ts_read_info_work);
+
+	i2c_set_clientdata(client, ts);
+
+	if (gpio_is_valid(ts->plat_data->tsp_id))
+		ts->tspid_val = gpio_get_value(ts->plat_data->tsp_id);
+
+	if (gpio_is_valid(ts->plat_data->tsp_icid))
+		ts->tspicid_val = gpio_get_value(ts->plat_data->tsp_icid);
+
+	ts->input_dev = input_allocate_device();
+	if (!ts->input_dev) {
+		input_err(true, &ts->client->dev, "%s: allocate device err!\n", __func__);
+		ret = -ENOMEM;
+		goto err_allocate_input_dev;
+	}
+
+	if (ts->plat_data->support_dex) {
+		ts->input_dev_pad = input_allocate_device();
+		if (!ts->input_dev_pad) {
+			input_err(true, &ts->client->dev, "%s: allocate device err!\n", __func__);
+			ret = -ENOMEM;
+			goto err_allocate_input_dev_pad;
+		}
+	}
+
+	ts->touch_count = 0;
+	ts->sec_ts_i2c_write = sec_ts_i2c_write;
+	ts->sec_ts_i2c_read = sec_ts_i2c_read;
+	ts->sec_ts_read_sponge = sec_ts_read_from_sponge;
+
+	ts->max_z_value = 0;
+	ts->min_z_value = 0xFFFFFFFF;
+	ts->sum_z_value = 0;
+
+	mutex_init(&ts->lock);
+	mutex_init(&ts->device_mutex);
+	mutex_init(&ts->i2c_mutex);
+	mutex_init(&ts->eventlock);
+	mutex_init(&ts->modechange);
+
+	wake_lock_init(&ts->wakelock, WAKE_LOCK_SUSPEND, "tsp_wakelock");
+	init_completion(&ts->resume_done);
+	complete_all(&ts->resume_done);
+
+	if (pdata->support_pressure) {
+		ts->lowpower_mode |= SEC_TS_MODE_SPONGE_FORCE_KEY;
+		ts->pressure_caller_id = -1;
+	} else {
+		ts->pressure_caller_id = 0;
+	}
+
+	input_info(true, &client->dev, "%s: init resource\n", __func__);
+
+	sec_ts_pinctrl_configure(ts, true);
+
+	/* power enable */
+	sec_ts_power(ts, true);
+	if (!pdata->regulator_boot_on)
+		sec_ts_delay(70);
+	ts->power_status = SEC_TS_STATE_POWER_ON;
+	ts->tdata->external_factory = false;
+
+	sec_ts_wait_for_ready(ts, SEC_TS_ACK_BOOT_COMPLETE);
+
+	input_info(true, &client->dev, "%s: power enable\n", __func__);
+
+	ret = sec_ts_i2c_read(ts, SEC_TS_READ_DEVICE_ID, deviceID, 5);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: failed to read device ID(%d)\n", __func__, ret);
+	else
+		input_info(true, &ts->client->dev,
+				"%s: TOUCH DEVICE ID : %02X, %02X, %02X, %02X, %02X\n", __func__,
+				deviceID[0], deviceID[1], deviceID[2], deviceID[3], deviceID[4]);
+
+	ret = sec_ts_i2c_read(ts, SEC_TS_READ_FIRMWARE_INTEGRITY, &result, 1);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: failed to integrity check (%d)\n", __func__, ret);
+	} else {
+		if (result & 0x80) {
+			valid_firmware_integrity = true;
+		} else if (result & 0x40) {
+			valid_firmware_integrity = false;
+			input_err(true, &ts->client->dev, "%s: invalid firmware (0x%x)\n", __func__, result);
+		} else {
+			valid_firmware_integrity = false;
+			input_err(true, &ts->client->dev, "%s: invalid integrity result (0x%x)\n", __func__, result);
+		}
+	}
+
+	ret = sec_ts_i2c_read(ts, SEC_TS_READ_BOOT_STATUS, &data[0], 1);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev,
+				"%s: failed to read sub id(%d)\n",
+				__func__, ret);
+	} else {
+		ret = sec_ts_i2c_read(ts, SEC_TS_READ_TS_STATUS, &data[1], 4);
+		if (ret < 0) {
+			input_err(true, &ts->client->dev,
+					"%s: failed to touch status(%d)\n",
+					__func__, ret);
+		}
+	}
+	input_info(true, &ts->client->dev,
+			"%s: TOUCH STATUS : %02X || %02X, %02X, %02X, %02X\n",
+			__func__, data[0], data[1], data[2], data[3], data[4]);
+
+	if (data[0] == SEC_TS_STATUS_BOOT_MODE)
+		ts->checksum_result = 1;
+
+	if ((data[0] == SEC_TS_STATUS_APP_MODE && data[2] == TOUCH_SYSTEM_MODE_FLASH) ||
+			!valid_firmware_integrity)
+		force_update = true;
+	else
+		force_update = false;
+
+#ifdef SEC_TS_FW_UPDATE_ON_PROBE
+	ret = sec_ts_firmware_update_on_probe(ts, force_update);
+	if (ret < 0)
+		goto err_init;
+#else
+	input_info(true, &ts->client->dev, "%s: fw update on probe disabled!\n", __func__);
+#endif
+
+	ret = sec_ts_read_information(ts);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: fail to read information 0x%x\n", __func__, ret);
+		goto err_init;
+	}
+
+	ts->touch_functions |= SEC_TS_DEFAULT_ENABLE_BIT_SETFUNC;
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_TOUCHFUNCTION, (u8 *)&ts->touch_functions, 2);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: Failed to send touch func_mode command", __func__);
+
+	/* Sense_on */
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SENSE_ON, NULL, 0);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: fail to write Sense_on\n", __func__);
+		goto err_init;
+	}
+
+	ts->pFrame = kzalloc(ts->tx_count * ts->rx_count * 2, GFP_KERNEL);
+	if (!ts->pFrame) {
+		ret = -ENOMEM;
+		goto err_allocate_frame;
+	}
+
+	if (ts->plat_data->support_dex) {
+		ts->input_dev_pad->name = "sec_touchpad";
+		sec_ts_set_input_prop(ts, ts->input_dev_pad, INPUT_PROP_POINTER);
+	}
+	ts->dex_name = "";
+
+	ts->input_dev->name = "sec_touchscreen";
+	sec_ts_set_input_prop(ts, ts->input_dev, INPUT_PROP_DIRECT);
+#ifdef USE_OPEN_CLOSE
+	ts->input_dev->open = sec_ts_input_open;
+	ts->input_dev->close = sec_ts_input_close;
+#endif
+	ts->input_dev_touch = ts->input_dev;
+
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		input_err(true, &ts->client->dev, "%s: Unable to register %s input device\n", __func__, ts->input_dev->name);
+		goto err_input_register_device;
+	}
+	if (ts->plat_data->support_dex) {
+		ret = input_register_device(ts->input_dev_pad);
+		if (ret) {
+			input_err(true, &ts->client->dev, "%s: Unable to register %s input device\n", __func__, ts->input_dev_pad->name);
+			goto err_input_pad_register_device;
+		}
+	}
+
+	input_info(true, &ts->client->dev, "%s: request_irq = %d\n", __func__, client->irq);
+
+	ret = request_threaded_irq(client->irq, NULL, sec_ts_irq_thread,
+			ts->plat_data->irq_type, SEC_TS_I2C_NAME, ts);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: Unable to request threaded irq\n", __func__);
+		goto err_irq;
+	}
+
+#ifdef CONFIG_TRUSTONIC_TRUSTED_UI
+	tsp_info = ts;
+
+	trustedui_set_tsp_irq(client->irq);
+	input_info(true, &client->dev, "%s[%d] called!\n",
+			__func__, client->irq);
+#endif
+
+	/* need remove below resource @ remove driver */
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+	sec_ts_raw_device_init(ts);
+#endif
+	sec_ts_fn_init(ts);
+
+#ifdef CONFIG_SECURE_TOUCH
+	if (sysfs_create_group(&ts->input_dev->dev.kobj, &secure_attr_group) < 0)
+		input_err(true, &ts->client->dev, "%s: do not make secure group\n", __func__);
+	else
+		secure_touch_init(ts);
+#endif
+
+	device_init_wakeup(&client->dev, true);
+
+#ifdef SEC_TS_SUPPORT_SPONGELIB
+	sec_ts_check_custom_library(ts);
+	if (ts->use_sponge)
+		sec_ts_set_custom_library(ts);
+
+#endif
+
+	schedule_delayed_work(&ts->work_read_info, msecs_to_jiffies(5000));
+
+#if defined(CONFIG_TOUCHSCREEN_DUMP_MODE)
+	dump_callbacks.inform_dump = dump_tsp_log;
+	INIT_DELAYED_WORK(&ts->ghost_check, sec_ts_check_rawdata);
+	p_ghost_check = &ts->ghost_check;
+#endif
+
+	ts_dup = ts;
+	ts->probe_done = true;
+
+	input_err(true, &ts->client->dev, "%s: done\n", __func__);
+	input_log_fix();
+
+	return 0;
+
+	/* need to be enabled when new goto statement is added */
+#if 0
+#ifdef CONFIG_SECURE_TOUCH
+	secure_touch_remove(ts);
+#endif
+	sec_ts_fn_remove(ts);
+	free_irq(client->irq, ts);
+#endif
+err_irq:
+	if (ts->plat_data->support_dex) {
+		input_unregister_device(ts->input_dev_pad);
+		ts->input_dev_pad = NULL;
+	}
+err_input_pad_register_device:
+	input_unregister_device(ts->input_dev);
+	ts->input_dev = NULL;
+	ts->input_dev_touch = NULL;
+err_input_register_device:
+	kfree(ts->pFrame);
+err_allocate_frame:
+err_init:
+	wake_lock_destroy(&ts->wakelock);
+	sec_ts_power(ts, false);
+	if (ts->plat_data->support_dex) {
+		if (ts->input_dev_pad)
+			input_free_device(ts->input_dev_pad);
+	}
+err_allocate_input_dev_pad:
+	if (ts->input_dev)
+		input_free_device(ts->input_dev);
+err_allocate_input_dev:
+err_null_tdata:
+	kfree(ts);
+
+error_allocate_mem:
+	if (gpio_is_valid(pdata->irq_gpio))
+		gpio_free(pdata->irq_gpio);
+	if (gpio_is_valid(pdata->tsp_id))
+		gpio_free(pdata->tsp_id);
+	if (gpio_is_valid(pdata->tsp_icid))
+		gpio_free(pdata->tsp_icid);
+
+error_allocate_tdata:
+error_allocate_pdata:
+	if (ret == -ECONNREFUSED)
+		sec_ts_delay(100);
+	ret = -ENODEV;
+#ifdef CONFIG_TOUCHSCREEN_DUMP_MODE
+	p_ghost_check = NULL;
+#endif
+	ts_dup = NULL;
+#ifdef CONFIG_TRUSTONIC_TRUSTED_UI
+	tsp_info = NULL;
+#endif
+	input_err(true, &client->dev, "%s: failed(%d)\n", __func__, ret);
+	input_log_fix();
+	return ret;
+}
+
+void sec_ts_unlocked_release_all_finger(struct sec_ts_data *ts)
+{
+	int i;
+
+	for (i = 0; i < MAX_SUPPORT_TOUCH_COUNT; i++) {
+		input_mt_slot(ts->input_dev, i);
+		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+
+		if ((ts->coord[i].action == SEC_TS_COORDINATE_ACTION_PRESS) ||
+				(ts->coord[i].action == SEC_TS_COORDINATE_ACTION_MOVE)) {
+
+			ts->coord[i].action = SEC_TS_COORDINATE_ACTION_RELEASE;
+			input_info(true, &ts->client->dev,
+					"%s: [RA] tID:%d mc:%d tc:%d v:%02X%02X, id(%d,%d) p:%d, D%05X, C%02XT01%02X.%4s%s\n",
+					__func__, i, ts->coord[i].mcount, ts->touch_count,
+					ts->plat_data->img_version_of_ic[2],
+					ts->plat_data->img_version_of_ic[3],
+					ts->tspid_val, ts->tspicid_val,
+					ts->coord[i].palm_count, ts->defect_probability,
+					ts->tdata->cal_count, ts->tdata->tune_fix_ver,
+					ts->tdata->tclm_string[ts->tdata->cal_position].f_name,
+					(ts->tdata->tclm_level == TCLM_LEVEL_LOCKDOWN)?".L":" ");
+
+			do_gettimeofday(&ts->time_released[i]);
+
+			if (ts->time_longest < (ts->time_released[i].tv_sec - ts->time_pressed[i].tv_sec))
+				ts->time_longest = (ts->time_released[i].tv_sec - ts->time_pressed[i].tv_sec);
+		}
+
+		ts->coord[i].mcount = 0;
+		ts->coord[i].palm_count = 0;
+
+	}
+
+	input_mt_slot(ts->input_dev, 0);
+
+	input_report_key(ts->input_dev, BTN_TOUCH, false);
+	input_report_key(ts->input_dev, BTN_TOOL_FINGER, false);
+	input_report_switch(ts->input_dev, SW_GLOVE, false);
+	ts->touchkey_glove_mode_status = false;
+	ts->touch_count = 0;
+	ts->check_multi = 0;
+
+	if (ts->plat_data->support_sidegesture) {
+		input_report_key(ts->input_dev, KEY_SIDE_GESTURE, 0);
+		input_report_key(ts->input_dev, KEY_SIDE_GESTURE_LEFT, 0);
+		input_report_key(ts->input_dev, KEY_SIDE_GESTURE_RIGHT, 0);
+	}
+
+	input_report_key(ts->input_dev, KEY_HOMEPAGE, 0);
+	input_sync(ts->input_dev);
+
+}
+
+void sec_ts_locked_release_all_finger(struct sec_ts_data *ts)
+{
+	int i;
+
+	mutex_lock(&ts->eventlock);
+
+	for (i = 0; i < MAX_SUPPORT_TOUCH_COUNT; i++) {
+		input_mt_slot(ts->input_dev, i);
+		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+
+		if ((ts->coord[i].action == SEC_TS_COORDINATE_ACTION_PRESS) ||
+				(ts->coord[i].action == SEC_TS_COORDINATE_ACTION_MOVE)) {
+
+			ts->coord[i].action = SEC_TS_COORDINATE_ACTION_RELEASE;
+			input_info(true, &ts->client->dev,
+					"%s: [RA] tID:%d mc: %d tc:%d, v:%02X%02X, cal:%X(%X) C%02XT01%02X.%4s%s id(%d,%d), p:%d, D%05X\n",
+					__func__, i, ts->coord[i].mcount, ts->touch_count,
+					ts->plat_data->img_version_of_ic[2],
+					ts->plat_data->img_version_of_ic[3],
+					ts->cal_status, ts->nv,
+					ts->tdata->cal_count, ts->tdata->tune_fix_ver,
+					ts->tdata->tclm_string[ts->tdata->cal_position].f_name,
+					(ts->tdata->tclm_level == TCLM_LEVEL_LOCKDOWN) ? ".L" : " ",
+					ts->tspid_val, ts->tspicid_val, ts->coord[i].palm_count,
+					ts->defect_probability);
+
+			do_gettimeofday(&ts->time_released[i]);
+
+			if (ts->time_longest < (ts->time_released[i].tv_sec - ts->time_pressed[i].tv_sec))
+				ts->time_longest = (ts->time_released[i].tv_sec - ts->time_pressed[i].tv_sec);
+		}
+
+		ts->coord[i].mcount = 0;
+		ts->coord[i].palm_count = 0;
+
+	}
+
+	input_mt_slot(ts->input_dev, 0);
+
+	input_report_key(ts->input_dev, BTN_TOUCH, false);
+	input_report_key(ts->input_dev, BTN_TOOL_FINGER, false);
+	input_report_switch(ts->input_dev, SW_GLOVE, false);
+	ts->touchkey_glove_mode_status = false;
+	ts->touch_count = 0;
+	ts->check_multi = 0;
+
+	if (ts->plat_data->support_sidegesture) {
+		input_report_key(ts->input_dev, KEY_SIDE_GESTURE, 0);
+		input_report_key(ts->input_dev, KEY_SIDE_GESTURE_LEFT, 0);
+		input_report_key(ts->input_dev, KEY_SIDE_GESTURE_RIGHT, 0);
+	}
+
+	input_report_key(ts->input_dev, KEY_HOMEPAGE, 0);
+	input_sync(ts->input_dev);
+
+	mutex_unlock(&ts->eventlock);
+
+}
+
+#ifdef USE_POWER_RESET_WORK
+static void sec_ts_reset_work(struct work_struct *work)
+{
+	struct sec_ts_data *ts = container_of(work, struct sec_ts_data,
+			reset_work.work);
+
+#ifdef CONFIG_SECURE_TOUCH
+	if (atomic_read(&ts->secure_enabled) == SECURE_TOUCH_ENABLE) {
+		input_err(true, &ts->client->dev, "%s: secure touch enabled\n", __func__);
+		return;
+	}
+#endif
+	ts->reset_is_on_going = true;
+	input_info(true, &ts->client->dev, "%s\n", __func__);
+
+	sec_ts_stop_device(ts);
+
+	sec_ts_delay(30);
+
+	sec_ts_start_device(ts);
+
+	if (ts->input_dev_touch->disabled) {
+		input_err(true, &ts->client->dev, "%s: call input_close\n", __func__);
+
+		sec_ts_input_close(ts->input_dev);
+
+		if ((ts->lowpower_mode & SEC_TS_MODE_SPONGE_AOD) && ts->use_sponge) {
+			int i, ret;
+			u8 data[10] = {0x02, 0};
+
+			for (i = 0; i < 4; i++) {
+				data[i * 2 + 2] = ts->rect_data[i] & 0xFF;
+				data[i * 2 + 3] = (ts->rect_data[i] >> 8) & 0xFF;
+			}
+
+			disable_irq(ts->client->irq);
+			ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SPONGE_WRITE_PARAM, &data[0], 10);
+			if (ret < 0)
+				input_err(true, &ts->client->dev, "%s: Failed to write offset\n", __func__);
+
+			ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SPONGE_NOTIFY_PACKET, NULL, 0);
+			if (ret < 0)
+				input_err(true, &ts->client->dev, "%s: Failed to send notify\n", __func__);
+			enable_irq(ts->client->irq);
+		}
+	}
+	ts->reset_is_on_going = false;
+}
+#endif
+
+static void sec_ts_read_info_work(struct work_struct *work)
+{
+	struct sec_ts_data *ts = container_of(work, struct sec_ts_data,
+			work_read_info.work);
+#ifdef TCLM_CONCEPT
+	int ret;
+#endif
+
+	mutex_lock(&ts->modechange);
+	ts->nv = get_tsp_nvm_data(ts, SEC_TS_NVM_OFFSET_FAC_RESULT);
+	ts->pressure_cal_base = get_tsp_nvm_data(ts, SEC_TS_NVM_OFFSET_PRESSURE_BASE_CAL_COUNT);
+	ts->pressure_cal_delta = get_tsp_nvm_data(ts, SEC_TS_NVM_OFFSET_PRESSURE_DELTA_CAL_COUNT);
+	ts->pressure_cal_index = get_tsp_nvm_data(ts, SEC_TS_NVM_OFFSET_PRESSURE_STRENGTH_INDEX);
+
+	input_info(true, &ts->client->dev, "%s: fac_nv:%02X, force_index:%d\n", __func__, ts->nv, ts->pressure_cal_index);
+
+#ifdef TCLM_CONCEPT
+	ret = sec_tclm_check_cal_case(ts->tdata);
+	if (!ret) /* already read in calibration */
+		ret = sec_tclm_get_nvm_all(ts->tdata);
+
+	if (ret) {
+		ts->tdata->tune_fix_ver = ts->tdata->tclm_read(ts->tdata->client, SEC_TCLM_NVM_OFFSET_TUNE_VERSION);
+		input_info(true, &ts->client->dev, "%s: tune_fix_ver [01%02X]\n",
+			__func__, ts->tdata->tune_fix_ver);
+
+		sec_tclm_position_history(ts->tdata);
+	}
+#endif
+	input_log_fix();
+
+	sec_ts_run_rawdata_all(ts, false);
+
+	mutex_unlock(&ts->modechange);
+
+}
+
+int sec_ts_set_lowpowermode(struct sec_ts_data *ts, u8 mode)
+{
+	int ret;
+	int retrycnt = 0;
+	u8 data;
+	char para = 0;
+
+	input_err(true, &ts->client->dev, "%s: %s(%X)\n", __func__,
+			mode == TO_LOWPOWER_MODE ? "ENTER" : "EXIT", ts->lowpower_mode);
+
+	mutex_lock(&ts->modechange);
+
+	if (mode) {
+		if (ts->use_sponge)
+			sec_ts_set_custom_library(ts);
+
+		data = (ts->lowpower_mode & SEC_TS_MODE_LOWPOWER_FLAG) >> 1;
+		ret = sec_ts_i2c_write(ts, SEC_TS_CMD_WAKEUP_GESTURE_MODE, &data, 1);
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "%s: Failed to set\n", __func__);
+	}
+
+retry_pmode:
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_POWER_MODE, &mode, 1);
+	if (ret < 0)
+		input_err(true, &ts->client->dev,
+				"%s: failed\n", __func__);
+	sec_ts_delay(50);
+
+	/* read data */
+
+	ret = sec_ts_i2c_read(ts, SEC_TS_CMD_SET_POWER_MODE, &para, 1);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: read power mode failed!\n", __func__);
+	else
+		input_info(true, &ts->client->dev, "%s: power mode - write(%d) read(%d)\n", __func__, mode, para);
+
+	if (mode != para) {
+		retrycnt++;
+		if (retrycnt < 5)
+			goto retry_pmode;
+	}
+
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_CLEAR_EVENT_STACK, NULL, 0);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: i2c write clear event failed\n", __func__);
+
+
+	sec_ts_locked_release_all_finger(ts);
+
+	if (device_may_wakeup(&ts->client->dev)) {
+		if (mode)
+			enable_irq_wake(ts->client->irq);
+		else
+			disable_irq_wake(ts->client->irq);
+	}
+
+	ts->lowpower_status = mode;
+	input_info(true, &ts->client->dev, "%s: end\n", __func__);
+
+	mutex_unlock(&ts->modechange);
+
+	return ret;
+}
+
+#ifdef USE_OPEN_CLOSE
+static int sec_ts_input_open(struct input_dev *dev)
+{
+	struct sec_ts_data *ts = input_get_drvdata(dev);
+	int ret;
+
+	if (ts == NULL) {
+		pr_err("%s %s ts is null\n", SECLOG, __func__);
+		return 0;
+	}
+
+	ts->abc_err_flag = false;
+	ts->input_closed = false;
+
+	input_info(true, &ts->client->dev, "%s\n", __func__);
+
+#ifdef CONFIG_TRUSTONIC_TRUSTED_UI
+	if (TRUSTEDUI_MODE_TUI_SESSION & trustedui_get_current_mode()) {
+		input_err(true, &ts->client->dev, "%s TUI cancel event call!\n", __func__);
+		msleep(100);
+		tui_force_close(1);
+		msleep(200);
+		if (TRUSTEDUI_MODE_TUI_SESSION & trustedui_get_current_mode()) {
+			input_err(true, &ts->client->dev, "%s TUI flag force clear!\n",	__func__);
+			trustedui_clear_mask(TRUSTEDUI_MODE_VIDEO_SECURED|TRUSTEDUI_MODE_INPUT_SECURED);
+			trustedui_set_mode(TRUSTEDUI_MODE_OFF);
+		}
+	}
+#endif
+
+#ifdef CONFIG_SECURE_TOUCH
+	secure_touch_stop(ts, 0);
+#endif
+
+	if (ts->lowpower_status) {
+#ifdef USE_RESET_EXIT_LPM
+		schedule_delayed_work(&ts->reset_work, msecs_to_jiffies(TOUCH_RESET_DWORK_TIME));
+#else
+		sec_ts_set_lowpowermode(ts, TO_TOUCH_MODE);
+#endif
+		ts->power_status = SEC_TS_STATE_POWER_ON;
+	} else {
+		ret = sec_ts_start_device(ts);
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "%s: Failed to start device\n", __func__);
+	}
+
+	/* because edge and dead zone will recover soon */
+	sec_ts_set_grip_type(ts, ONLY_EDGE_HANDLER);
+
+	return 0;
+}
+
+static void sec_ts_input_close(struct input_dev *dev)
+{
+	struct sec_ts_data *ts = input_get_drvdata(dev);
+
+	if (ts == NULL) {
+		pr_err("%s %s ts is null\n", SECLOG, __func__);
+		return;
+	}
+
+	ts->input_closed = true;
+
+	input_info(true, &ts->client->dev, "%s\n", __func__);
+
+#ifdef TCLM_CONCEPT
+	sec_tclm_debug_info(ts->tdata);
+#endif
+#ifdef MINORITY_REPORT
+	minority_report_sync_latest_value(ts);
+#endif
+
+#ifdef CONFIG_TRUSTONIC_TRUSTED_UI
+	if (TRUSTEDUI_MODE_TUI_SESSION & trustedui_get_current_mode()) {
+		input_err(true, &ts->client->dev, "%s TUI cancel event call!\n", __func__);
+		msleep(100);
+		tui_force_close(1);
+		msleep(200);
+		if (TRUSTEDUI_MODE_TUI_SESSION & trustedui_get_current_mode()) {
+			input_err(true, &ts->client->dev, "%s TUI flag force clear!\n",	__func__);
+			trustedui_clear_mask(TRUSTEDUI_MODE_VIDEO_SECURED|TRUSTEDUI_MODE_INPUT_SECURED);
+			trustedui_set_mode(TRUSTEDUI_MODE_OFF);
+		}
+	}
+#endif
+
+#ifdef CONFIG_SECURE_TOUCH
+	secure_touch_stop(ts, 1);
+#endif
+#ifdef USE_POWER_RESET_WORK
+	cancel_delayed_work(&ts->reset_work);
+#endif
+
+#ifndef CONFIG_SEC_FACTORY
+	if (ts->plat_data->always_lpmode && ts->plat_data->support_pressure)
+		ts->lowpower_mode |= SEC_TS_MODE_SPONGE_FORCE_KEY;
+#endif
+
+	if (ts->lowpower_mode) {
+		sec_ts_set_lowpowermode(ts, TO_LOWPOWER_MODE);
+		ts->power_status = SEC_TS_STATE_LPM;
+	} else {
+		sec_ts_stop_device(ts);
+	}
+
+	ts->abc_err_flag = true;
+}
+#endif
+
+static int sec_ts_remove(struct i2c_client *client)
+{
+	struct sec_ts_data *ts = i2c_get_clientdata(client);
+
+	input_info(true, &ts->client->dev, "%s\n", __func__);
+
+	cancel_delayed_work_sync(&ts->work_read_info);
+	flush_delayed_work(&ts->work_read_info);
+
+	disable_irq_nosync(ts->client->irq);
+	free_irq(ts->client->irq, ts);
+	input_info(true, &ts->client->dev, "%s: irq disabled\n", __func__);
+
+#ifdef USE_POWER_RESET_WORK
+	cancel_delayed_work_sync(&ts->reset_work);
+	flush_delayed_work(&ts->reset_work);
+
+	input_info(true, &ts->client->dev, "%s: flush queue\n", __func__);
+
+#endif
+
+	sec_ts_fn_remove(ts);
+
+#ifdef CONFIG_TOUCHSCREEN_DUMP_MODE
+	p_ghost_check = NULL;
+#endif
+	device_init_wakeup(&client->dev, false);
+	wake_lock_destroy(&ts->wakelock);
+
+	dev_set_drvdata(&ts->client->dev, NULL);
+
+	ts->lowpower_mode = false;
+	ts->probe_done = false;
+
+	if (ts->plat_data->support_dex) {
+		input_mt_destroy_slots(ts->input_dev_pad);
+		input_unregister_device(ts->input_dev_pad);
+	}
+
+	ts->input_dev = ts->input_dev_touch;
+	input_mt_destroy_slots(ts->input_dev);
+	input_unregister_device(ts->input_dev);
+
+#ifdef CONFIG_SECURE_TOUCH
+	secure_touch_remove(ts);
+#endif
+	ts->input_dev_pad = NULL;
+	ts->input_dev = NULL;
+	ts->input_dev_touch = NULL;
+	ts_dup = NULL;
+	ts->plat_data->power(ts, false);
+
+#ifdef CONFIG_TRUSTONIC_TRUSTED_UI
+	tsp_info = NULL;
+#endif
+
+	kfree(ts);
+	return 0;
+}
+
+static void sec_ts_shutdown(struct i2c_client *client)
+{
+	struct sec_ts_data *ts = i2c_get_clientdata(client);
+
+	if (ts == NULL) {
+		pr_err("%s %s ts is null\n", SECLOG, __func__);
+		return;
+	}
+
+	input_info(true, &ts->client->dev, "%s\n", __func__);
+
+	sec_ts_remove(client);
+}
+
+int sec_ts_stop_device(struct sec_ts_data *ts)
+{
+	input_info(true, &ts->client->dev, "%s\n", __func__);
+
+	mutex_lock(&ts->device_mutex);
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev, "%s: already power off\n", __func__);
+		goto out;
+	}
+
+	ts->power_status = SEC_TS_STATE_POWER_OFF;
+
+	disable_irq(ts->client->irq);
+	sec_ts_locked_release_all_finger(ts);
+
+	ts->plat_data->power(ts, false);
+
+	if (ts->plat_data->enable_sync)
+		ts->plat_data->enable_sync(false);
+
+	sec_ts_pinctrl_configure(ts, false);
+
+out:
+	mutex_unlock(&ts->device_mutex);
+	return 0;
+}
+
+int sec_ts_start_device(struct sec_ts_data *ts)
+{
+	int ret;
+
+	input_info(true, &ts->client->dev, "%s\n", __func__);
+
+	sec_ts_pinctrl_configure(ts, true);
+
+	mutex_lock(&ts->device_mutex);
+
+	if (ts->power_status == SEC_TS_STATE_POWER_ON) {
+		input_err(true, &ts->client->dev, "%s: already power on\n", __func__);
+		goto out;
+	}
+
+	sec_ts_locked_release_all_finger(ts);
+
+	ts->plat_data->power(ts, true);
+	sec_ts_delay(70);
+	ts->power_status = SEC_TS_STATE_POWER_ON;
+	sec_ts_wait_for_ready(ts, SEC_TS_ACK_BOOT_COMPLETE);
+
+	if (ts->plat_data->enable_sync)
+		ts->plat_data->enable_sync(true);
+
+	if (ts->flip_enable) {
+		ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_COVERTYPE, &ts->cover_cmd, 1);
+
+		ts->touch_functions = ts->touch_functions | SEC_TS_BIT_SETFUNC_COVER;
+		input_info(true, &ts->client->dev,
+				"%s: cover cmd write type:%d, mode:%x, ret:%d", __func__, ts->touch_functions, ts->cover_cmd, ret);
+	} else {
+		ts->touch_functions = (ts->touch_functions & (~SEC_TS_BIT_SETFUNC_COVER));
+		input_info(true, &ts->client->dev,
+				"%s: cover open, not send cmd", __func__);
+	}
+
+	ts->touch_functions = ts->touch_functions | SEC_TS_DEFAULT_ENABLE_BIT_SETFUNC;
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_TOUCHFUNCTION, (u8 *)&ts->touch_functions, 2);
+	if (ret < 0)
+		input_err(true, &ts->client->dev,
+				"%s: Failed to send touch function command", __func__);
+
+	if (ts->use_sponge)
+		sec_ts_set_custom_library(ts);
+
+	sec_ts_set_grip_type(ts, ONLY_EDGE_HANDLER);
+
+	if (ts->dex_mode) {
+		input_info(true, &ts->client->dev, "%s: set dex mode\n", __func__);
+		ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SET_DEX_MODE, &ts->dex_mode, 1);
+		if (ret < 0)
+			input_err(true, &ts->client->dev,
+					"%s: failed to set dex mode %x\n", __func__, ts->dex_mode);
+	}
+
+	if (ts->brush_mode) {
+		input_info(true, &ts->client->dev, "%s: set brush mode\n", __func__);
+		ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SET_BRUSH_MODE, &ts->brush_mode, 1);
+		if (ret < 0)
+			input_err(true, &ts->client->dev,
+					"%s: failed to set brush mode\n", __func__);
+	}
+
+	if (ts->touchable_area) {
+		input_info(true, &ts->client->dev, "%s: set 16:9 mode\n", __func__);
+		ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SET_TOUCHABLE_AREA, &ts->touchable_area, 1);
+		if (ret < 0)
+			input_err(true, &ts->client->dev,
+					"%s: failed to set 16:9 mode\n", __func__);
+	}
+
+	/* Sense_on */
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SENSE_ON, NULL, 0);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: fail to write Sense_on\n", __func__);
+
+	enable_irq(ts->client->irq);
+
+out:
+	mutex_unlock(&ts->device_mutex);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int sec_ts_pm_suspend(struct device *dev)
+{
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+#ifdef USE_OPEN_CLOSE
+	int retval;
+#endif
+
+	if (ts == NULL) {
+		pr_err("%s %s ts is null\n", SECLOG, __func__);
+		return 0;
+	}
+
+#ifdef USE_OPEN_CLOSE
+	if (ts->input_dev) {
+		retval = mutex_lock_interruptible(&ts->input_dev->mutex);
+		if (retval) {
+			input_err(true, &ts->client->dev,
+					"%s : mutex error\n", __func__);
+			goto out;
+		}
+
+		if (!ts->input_dev->disabled) {
+			ts->input_dev->disabled = true;
+			if (ts->input_dev->users && ts->input_dev->close) {
+				input_err(true, &ts->client->dev,
+						"%s called without input_close\n",
+						__func__);
+				ts->input_dev->close(ts->input_dev);
+#ifdef CONFIG_SEC_ABC
+				sec_abc_send_event("MODULE=tsp@ERROR=suspend_without_input_close");
+#endif
+			}
+			ts->input_dev->users = 0;
+		}
+
+		mutex_unlock(&ts->input_dev->mutex);
+	}
+
+out:
+#endif
+	if (ts->lowpower_mode)
+		reinit_completion(&ts->resume_done);
+
+	return 0;
+}
+
+static int sec_ts_pm_resume(struct device *dev)
+{
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+
+	if (ts == NULL) {
+		pr_err("%s %s ts is null\n", SECLOG, __func__);
+		return 0;
+	}
+
+	if (ts->lowpower_mode)
+		complete_all(&ts->resume_done);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_TRUSTONIC_TRUSTED_UI
+void trustedui_mode_on(void)
+{
+	if (!tsp_info)
+		return;
+
+	sec_ts_unlocked_release_all_finger(tsp_info);
+
+#ifdef CONFIG_INPUT_WACOM
+	epen_disable_mode(1);
+#endif
+}
+EXPORT_SYMBOL(trustedui_mode_on);
+
+void trustedui_mode_off(void)
+{
+	if (!tsp_info)
+		return;
+
+#ifdef CONFIG_INPUT_WACOM
+	epen_disable_mode(0);
+#endif
+}
+EXPORT_SYMBOL(trustedui_mode_off);
+#endif
+
+static const struct i2c_device_id sec_ts_id[] = {
+	{ SEC_TS_I2C_NAME, 0 },
+	{ },
+};
+
+#ifdef CONFIG_PM
+static const struct dev_pm_ops sec_ts_dev_pm_ops = {
+	.suspend = sec_ts_pm_suspend,
+	.resume = sec_ts_pm_resume,
+};
+#endif
+
+#ifdef CONFIG_OF
+static const struct of_device_id sec_ts_match_table[] = {
+	{ .compatible = "sec,sec_ts",},
+	{ },
+};
+#else
+#define sec_ts_match_table NULL
+#endif
+
+static struct i2c_driver sec_ts_driver = {
+	.probe		= sec_ts_probe,
+	.remove		= sec_ts_remove,
+	.shutdown	= sec_ts_shutdown,
+	.id_table	= sec_ts_id,
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= SEC_TS_I2C_NAME,
+#ifdef CONFIG_OF
+		.of_match_table = sec_ts_match_table,
+#endif
+#ifdef CONFIG_PM
+		.pm = &sec_ts_dev_pm_ops,
+#endif
+	},
+};
+
+static int __init sec_ts_init(void)
+{
+#ifdef CONFIG_BATTERY_SAMSUNG
+	if (lpcharge == 1) {
+		pr_err("%s %s: Do not load driver due to : lpm %d\n",
+				SECLOG, __func__, lpcharge);
+		return -ENODEV;
+	}
+#endif
+	pr_err("%s %s\n", SECLOG, __func__);
+
+	return i2c_add_driver(&sec_ts_driver);
+}
+
+static void __exit sec_ts_exit(void)
+{
+	i2c_del_driver(&sec_ts_driver);
+}
+
+MODULE_AUTHOR("Hyobae, Ahn<hyobae.ahn@samsung.com>");
+MODULE_DESCRIPTION("Samsung Electronics TouchScreen driver");
+MODULE_LICENSE("GPL");
+
+module_init(sec_ts_init);
+module_exit(sec_ts_exit);
diff --git a/drivers/input/touchscreen/sec_ts/sec_ts.h b/drivers/input/touchscreen/sec_ts/sec_ts.h
new file mode 100644
index 000000000000..4ae4ec530a3f
--- /dev/null
+++ b/drivers/input/touchscreen/sec_ts/sec_ts.h
@@ -0,0 +1,529 @@
+/* drivers/input/touchscreen/sec_ts.h
+ *
+ * Copyright (C) 2015 Samsung Electronics Co., Ltd.
+ * http://www.samsungsemi.com/
+ *
+ * Core file for Samsung TSC driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __SEC_TS_H__
+#define __SEC_TS_H__
+
+#ifdef CONFIG_SEC_DEBUG_TSP_LOG
+#endif
+
+/*add for samsung sec class*/
+/*#define SAMSUNG_PROJECT*/
+
+#define SEC_TS_I2C_NAME										"sec_ts"
+#define SEC_TS_DEVICE_NAME								"SEC_TS"
+
+#define USE_OPEN_CLOSE
+#define TOUCH_RESET_DWORK_TIME						10
+#define TOUCH_INTERRUPT_DWORK_TIME				110000
+#define TOUCH_FWUPDATE_DWORK_TIME					4000
+#define CALIBRATION_BY_FACTORY
+
+/* LCD ID  0x ID1 ID2 ID3 */
+#define LCD_ID2_MODEL_MASK								0x003000	/* ID2 - 00110000*/
+
+#define MASK_1_BITS												0x0001
+#define MASK_2_BITS												0x0003
+#define MASK_3_BITS												0x0007
+#define MASK_4_BITS												00x000F
+#define MASK_5_BITS												00x001F
+#define MASK_6_BITS												00x003F
+#define MASK_7_BITS												00x007F
+#define MASK_8_BITS												00x00FF
+
+#define TYPE_STATUS_EVENT_ACK							1
+#define TYPE_STATUS_EVENT_ERR							2
+#define TYPE_STATUS_EVENT_INFO						3
+#define TYPE_STATUS_EVENT_GEST						6
+
+#define SEC_TS_ERR_ESD 										0xFF
+
+#define BIT_STATUS_EVENT_ACK(a)						(a << TYPE_STATUS_EVENT_ACK)
+#define BIT_STATUS_EVENT_ERR(a)						(a << TYPE_STATUS_EVENT_ERR)
+#define BIT_STATUS_EVENT_INFO(a)					(a << TYPE_STATUS_EVENT_INFO)
+#define BIT_STATUS_EVENT_GEST(a)					(a << TYPE_STATUS_EVENT_GEST)
+
+#define DO_FW_CHECKSUM										(0x1 << 0)
+#define DO_PARA_CHECKSUM									(0x1 << 1)
+
+#define MAX_SUPPORT_TOUCH_COUNT 					10
+#define MAX_SUPPORT_HOVER_COUNT 					1
+
+#define SEC_TS_EVENTID_HOVER 							10
+
+#define SEC_TS_STATE_POWER_ON  						1
+#define SEC_TS_STATE_POWER_OFF 						0
+
+#define I2C_WRITE_BUFFER_SIZE 						7
+
+#define SEC_TS_DRV_VERSION 								"g_6ft0.v00"
+
+#define SEC_TS_FW_MAX_BURSTSIZE 					256
+//#define CONFIG_FW_UPDATE_ON_PROBE
+
+//#define POR_AFTER_I2C_RETRY
+/*#define SEC_TS_SUPPORT_SEC_SWIPE */
+
+#define AMBIENT_CAL 											0
+#define OFFSET_CAL_SDC										1
+#define OFFSET_CAL_SEC										2
+
+#define SEC_TS_NVM_OFFSET_FAC_RESULT			0
+#define SEC_TS_NVM_OFFSET_CAL_COUNT				1
+
+/* SEC_TS READ REGISTER ADDRESS */
+#define SEC_TS_READ_FW_STATUS							0x51
+#define SEC_TS_READ_DEVICE_ID							0x52
+#define SEC_TS_READ_SUB_ID								0x53
+#define SEC_TS_READ_BOOT_STATUS						0x55
+#define SEC_TS_READ_RAW_CHANNEL						0x58
+#define SEC_TS_READ_FLASH_ERASE_STATUS		0x59
+#define SEC_TS_READ_SET_TOUCHFUNCTION			0x64
+#define SEC_TS_READ_THRESHOLD							0x6D
+#define SEC_TS_READ_TS_STATUS							0x70
+#define SEC_TS_READ_ONE_EVENT							0x71
+#define SEC_TS_READ_CALIBRATION_REPORT		0x73
+#define SEC_TS_READ_TOUCH_RAWDATA					0x76
+#define SEC_TS_READ_TOUCH_SELF_RAWDAT	A		0x77
+#define SEC_TS_READ_SELFTEST_RESULT				0x80
+#define SEC_TS_READ_NVM										0x85
+#define SEC_TS_READ_FW_INFO								0xA2
+#define SEC_TS_READ_FW_VERSION						0xA3
+#define SEC_TS_READ_PARA_VERSION					0xA4
+#define SEC_TS_READ_IMG_VERSION						0xA5
+#define SEC_TS_READ_LV3										0xD2
+#define SEC_TS_READ_BL_UPDATE_STATUS			0xDB
+
+#define SEC_TS_CMD_DEADZONE_RANGE					0x30
+#define SEC_TS_CMD_LONGPRESSZONE_RANGE		0x31
+#define SEC_TS_CMD_LONGPRESS_DROP_AREA		0x32
+#define SEC_TS_CMD_LONGPRESS_DROP_DIFF		0x33
+#define SEC_TS_CMD_SENSE_ON								0x40
+#define SEC_TS_CMD_SENSE_OFF							0x41
+#define SEC_TS_CMD_SW_RESET								0x42
+#define SEC_TS_CMD_CALIBRATION_AMBIENT		0x43
+#define SEC_TS_CMD_ERASE_FLASH						0x45
+#define SEC_TS_CMD_STATEMANAGE_ON					0x48
+#define SEC_TS_CMD_CALIBRATION_OFFSET_SDC	0x4C
+#define SEC_TS_CMD_CALIBRATION_OFFSET_SEC	0x4F
+#define SEC_TS_CMD_SELFTEST								0x51
+#define SEC_TS_CMD_WRITE_FW_BLK						0x53
+#define SEC_TS_CMD_WRITE_FW_SHORT					0x54
+#define SEC_TS_CMD_WRITE_FW_LONG					0x5A
+#define SEC_TS_CMD_ENTER_FW_MODE					0x57
+#define SEC_TS_CMD_SELFTEST_TYPE					0x5F
+#define SEC_TS_CMD_CLEAR_EVENT_STACK			0x60
+#define SEC_TS_CMD_SET_TOUCHFUNCTION			0x63
+#define SEC_TS_CMD_SET_POWER_MODE					0x65
+#define SEC_TS_CMD_STATUS_EVENT_TYPE			0x6B
+#define SEC_TS_CMD_GESTURE_MODE						0x6C
+#define SEC_TS_CMD_EDGE_DEADZONE					0x6E
+#define SEC_TS_CMD_NOISE_MODE							0x77
+#define SEC_TS_CMD_NVM										0x85
+#define SEC_TS_CMD_SELFTEST_PTOP					0x82
+#define SEC_TS_CMD_GET_CHECKSUM						0xA6
+#define SEC_TS_CMD_CHG_SYSMODE						0xD7
+
+#define SEC_TS_CMD_MUTU_RAW_TYPE					0xF4
+#define SEC_TS_CMD_SELF_RAW_TYPE					0xFA
+
+#define SEC_TS_SELFTEST_REPORT_SIZE				17508
+
+#define SEC_TS_ID_ON_FW										0xAC
+#define SEC_TS_ID_ON_BOOT									0xD0
+
+#define SEC_TS_Status_Event								0
+#define SEC_TS_Coordinate_Event						1
+#define SEC_TS_Gesture_Event							2
+#define SEC_TS_Event_Buff_Size						8
+#define SEC_TS_SID_GESTURE								0x14
+#define SEC_TS_GESTURE_CODE_AOD						0x00
+#define SEC_TS_GESTURE_CODE_SPAY					0x0A
+#define SEC_TS_GESTURE_CODE_SIDE_GESTURE	0x11
+
+#define SEC_TS_Coordinate_Action_None			0
+#define SEC_TS_Coordinate_Action_Press		1
+#define SEC_TS_Coordinate_Action_Release	3
+#define SEC_TS_Coordinate_Action_Move 		2
+
+#define SEC_TS_TOUCHTYPE_NORMAL						0
+#define SEC_TS_TOUCHTYPE_PROXIMITY				1
+#define SEC_TS_TOUCHTYPE_GLOVE						3
+#define SEC_TS_TOUCHTYPE_STYLUS						4
+#define SEC_TS_TOUCHTYPE_HOVER						5
+#define SEC_TS_TOUCHTYPE_PALM							6
+
+/* SEC_TS_ACK : acknowledge event */
+#define SEC_TS_ACK_OFFSET_CAL_DONE				0x01
+#define SEC_TS_ACK_SELF_TEST_DONE					0x0A
+#define SEC_TS_ACK_BOOT_COMPLETE					0x0C
+
+#define SEC_TS_BIT_SETFUNC_TOUCH					(0x1<<0)
+#define SEC_TS_BIT_SETFUNC_MUTUAL					(0x1<<0)
+#define SEC_TS_BIT_SETFUNC_HOVER					(0x1<<1)
+#define SEC_TS_BIT_SETFUNC_GLOVE					(0x1<<3)
+#define SEC_TS_BIT_SETFUNC_CHARGER				(0x1<<4)
+#define SEC_TS_BIT_SETFUNC_STYLUS					(0x1<<5)
+
+#define SEC_TS_STATUS_NOT_CALIBRATION			0x50
+#define SEC_TS_STATUS_CALIBRATION_SDC			0xA1
+#define SEC_TS_STATUS_CALIBRATION_SEC			0xA2
+
+#define STATE_MANAGE_ON										1
+#define STATE_MANAGE_OFF									0
+
+#define SEC_TS_MAX_FW_PATH								64
+#define SEC_TS_FW_BLK_SIZE								256
+#define SEC_TS_FW_HEADER_SIGN							0x53494654
+#define SEC_TS_FW_CHUNK_SIGN							0x53434654
+#define SEC_TS_DEFAULT_FW_NAME						"app.bin"
+#define SEC_TS_DEFAULT_PARA_NAME					"para.bin"
+#define SEC_TS_DEFAULT_UMS_FW							"lsi.bin"
+
+#define SEC_TS_INTERRUPT_EN 							1
+#define SEC_TS_INTERRUPT_DIS							0
+
+#define CONFIG_6FT0
+
+enum {
+	BUILT_IN = 0,
+	UMS,
+	NONE,
+	FFU,
+};
+
+struct fw_header {
+	u32 signature;			/*signature*/
+	u32 version;				/*img_version*/
+	u32 FlashInfo0;			/*max flash size*/
+	u32 FlashInfo1;			/*parameter area*/
+	u32 flag;						/*mode select/bootloader mode*/
+	u32 setting;				/*HWB settings*/
+	u32 checksum;				/*checksum*/
+	u32 BootStartAddr[3];
+	u32 FlashLoadAddr[3];
+	u32 NumberOfChunk[3];
+};
+
+struct fw_chunk {
+	u32 signature;
+	u32 addr;
+	u32 size;
+	u32 reserved;
+};
+
+enum TOUCH_SYSTEM_MODE {
+	TOUCH_SYSTEM_MODE_BOOT = 0,
+	TOUCH_SYSTEM_MODE_CALIBRATION = 1,
+	TOUCH_SYSTEM_MODE_TOUCH = 2,
+	TOUCH_SYSTEM_MODE_SELFTEST = 3,
+	TOUCH_SYSTEM_MODE_FLASH = 4,
+	TOUCH_SYSTEM_MODE_LOWPOWER = 5,
+	TOUCH_SYSTEM_MODE_LISTEN
+};
+
+enum TOUCH_MODE_STATE {
+	TOUCH_MODE_STATE_IDLE = 0,
+	TOUCH_MODE_STATE_HOVER = 1,
+	TOUCH_MODE_STATE_TOUCH = 2,
+	TOUCH_MODE_STATE_NOISY = 3,
+	TOUCH_MODE_STATE_CAL = 4,
+	TOUCH_MODE_STATE_CAL2 = 5,
+	TOUCH_MODE_STATE_WAKEUP = 10
+};
+
+enum switch_system_mode {
+	TO_TOUCH_MODE = 0,
+	TO_LOWPOWER_MODE,
+	TO_SELFTEST_MODE,
+	TO_FLASH_MODE = 3,
+};
+
+#define CMD_STR_LEN 						256
+#define CMD_PARAM_NUM 					8
+#define CMD_RESULT_STR_LEN		 	4095
+#define SEC_CMD_BUF_SIZE				4095
+#define CMD_RESULT_WORD_LEN			10
+
+#define SEC_TS_I2C_RETRY_CNT 		10
+#define SEC_TS_WAIT_RETRY_CNT 	100
+
+#define SEC_TS_LOWP_FLAG_AOD							(1 << 4)
+#define SEC_TS_LOWP_FLAG_SPAY							(1 << 5)
+#define SEC_TS_LOWP_FLAG_SIDE_GESTURE			(1 << 6)
+
+extern struct sec_ts_callbacks *charger_callbacks;
+struct sec_ts_callbacks {
+	void (*inform_charger)(struct sec_ts_callbacks *, int type);
+};
+
+/* ----------------------------------------
+ * write 0xE4 [ 11 | 10 | 01 | 00 ]
+ * MSB <-------------------> LSB
+ * read 0xE4
+ * mapping sequnce : LSB -> MSB
+ * struct sec_ts_test_result {
+ * * assy : front + OCTA assay
+ * * module : only OCTA
+ *	 union {
+ *		 struct {
+ *			 u8 assy_count:2;		-> 00
+ *			 u8 assy_result:2;		-> 01
+ *			 u8 module_count:2;	-> 10
+ *			 u8 module_result:2;	-> 11
+ *		 } __attribute__ ((packed));
+ *		 unsigned char data[1];
+ *	 };
+ *};
+ * ---------------------------------------- */
+struct sec_ts_test_result {
+	union {
+		struct {
+			u8 assy_count:2;
+			u8 assy_result:2;
+			u8 module_count:2;
+			u8 module_result:2;
+		} __packed;
+		unsigned char data[1];
+	};
+};
+
+struct sec_ts_coordinate {
+	u16 x;
+	u16 y;
+	u16 mcount;
+	u8 id;
+	u8 ttype;
+	u8 action;
+	u8 touch_width;
+	u8 hover_flag;
+	u8 glove_flag;
+	u8 touch_height;
+	u8 major;
+	u8 minor;
+	u8 palm;
+};
+
+struct sec_ts_event_coordinate {
+	u8 tchsta:3;
+	u8 ttype:3;
+	u8 eid:2;
+
+	u8 tid:4;
+	u8 nt:4;
+
+	u8 x_11_4;
+
+	u8 y_11_4;
+
+	u8 y_3_0:4;
+	u8 x_3_0:4;
+
+	u8 z;
+	u8 major;
+	u8 minor;
+/*	u8 reserved_7:7; */
+} __packed;
+
+#define TEST_MODE_MIN_MAX		false
+#define TEST_MODE_ALL_NODE		true
+#define TEST_MODE_READ_FRAME		false
+#define TEST_MODE_READ_CHANNEL		true
+
+/* factory test mode */
+struct sec_ts_test_mode {
+	u8 type;
+	short min;
+	short max;
+	bool allnode;
+	bool frame_channel;
+};
+
+struct sec_ts_data {
+	u32 isr_pin;
+
+	u32 crc_addr;
+	u32 fw_addr;
+	u32 para_addr;
+
+	u8 boot_ver[3];
+
+	struct device *dev;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct sec_ts_plat_data *plat_data;
+	struct factory_data *f_data;
+	struct sec_ts_coordinate coord[MAX_SUPPORT_TOUCH_COUNT + 1];
+	struct completion init_done;
+#if defined(CONFIG_FB)
+	struct notifier_block fb_notif;
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	struct early_suspend early_suspend;
+#endif
+	uint32_t flags;
+	unsigned char lowpower_flag;
+	bool lowpower_mode;
+	int lowpower_status;
+	int touch_count;
+	int tx_count;
+	int rx_count;
+	int i2c_burstmax;
+	int ta_status;
+	int power_status;
+	int raw_status;
+	int event_errcnt;
+	int touchkey_glove_mode_status;
+	u8 touch_functions;
+	u8 hover_enables;
+	u8 interrupt_enable;
+	struct sec_ts_event_coordinate touchtype;
+	bool touched[11];
+	u8 gesture_status[SEC_TS_Event_Buff_Size];
+	u8 cal_status;
+	bool fw_workdone;
+	bool force_fwup;
+
+	struct sec_ts_callbacks callbacks;
+
+	struct mutex lock;
+	struct mutex device_mutex;
+	struct mutex i2c_mutex;
+
+	struct delayed_work reset_work;
+	struct delayed_work interrupt_work;
+	struct delayed_work fwupdate_work;
+	struct delayed_work  open_work;
+
+	int irq;
+	bool enabled;
+
+	/* factory_data */
+	struct device *fac_dev_ts;
+	bool cmd_is_running;
+	unsigned char cmd_state;
+	char cmd[CMD_STR_LEN];
+	int cmd_param[CMD_PARAM_NUM];
+	char cmd_buff[CMD_STR_LEN];
+	char cmd_result[CMD_RESULT_STR_LEN];
+	int cmd_buffer_size;
+	struct mutex cmd_lock;
+	struct list_head cmd_list_head;
+	void (*sec_ts_fn_init)(void *device_data);
+	int SenseChannelLength;
+	int ForceChannelLength;
+	short *pFrame;
+	short *sFrame;
+	unsigned char *cx_data;
+	int delayed_cmd_param[2];
+
+	struct delayed_work read_nv_work;
+
+	bool touch_stopped;
+	bool reinit_done;
+	bool flip_enable;
+	bool probe_done;
+#ifdef FTS_SUPPORT_2NDSCREEN
+	u8 SIDE_Flag;
+	u8 previous_SIDE_value;
+#endif
+
+	unsigned int scrub_id;
+	unsigned int scrub_x;
+	unsigned int scrub_y;
+
+	int nv;
+	int cal_count;
+
+#ifdef CONFIG_SEC_DEBUG_TSP_LOG
+	struct delayed_work ghost_check;
+	u8 tsp_dump_lock;
+#endif
+
+	int tspid_val;
+	int tspid2_val;
+
+	int (*sec_ts_i2c_write)(struct sec_ts_data *ts, u8 reg, u8 *data, int len);
+	int (*sec_ts_i2c_read)(struct sec_ts_data *ts, u8 reg, u8 *data, int len);
+	int (*sec_ts_i2c_read_bulk)(struct sec_ts_data *ts, u8 *data, int len);
+	int (*sec_ts_i2c_write_burst)(struct sec_ts_data *ts, u8 *data, int len);
+};
+
+struct sec_ts_plat_data {
+	int max_x;
+	int max_y;
+	/*int intx_pin;*/
+	int num_tx;
+	int num_rx;
+	unsigned gpio;
+	unsigned gpio_det;
+	int irq_type;
+	int i2c_burstmax;
+
+	const char *firmware_name;
+	const char *parameter_name;
+	const char *model_name;
+	const char *project_name;
+	const char *regulator_dvdd;
+	const char *regulator_avdd;
+
+	int panel_revision;
+	u8 img_version_of_ic[4];
+	u8 img_version_of_bin[4];
+	u8 para_version_of_ic[4];
+	u8 para_version_of_bin[4];
+
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_default;
+	struct pinctrl_state *pins_sleep;
+
+	int (*power)(void *data, bool on);
+	void (*recovery_mode)(bool on);
+	void (*enable_sync)(bool on);
+	void (*register_cb)(struct sec_ts_callbacks *);
+
+	unsigned tspid;
+	unsigned tspid2;
+};
+
+int sec_ts_firmware_update_on_probe(struct sec_ts_data *ts);
+int sec_ts_firmwarei_update_on_probe(struct sec_ts_data *ts);
+int sec_ts_firmware_update_on_hidden_menu(struct sec_ts_data *ts, int update_type);
+int sec_ts_check_firmware_version(struct sec_ts_data *ts, const u8 *fw_info);
+int sec_ts_glove_mode_enables(struct sec_ts_data *ts, int mode);
+int sec_ts_hover_enables(struct sec_ts_data *ts, int enables);
+int sec_ts_wait_for_ready(struct sec_ts_data *ts, unsigned int ack);
+int sec_ts_function(int(*func_init)(void *device_data), void(*func_remove)(void));
+int sec_ts_read_calibration_report(struct sec_ts_data *ts);
+int sec_ts_execute_force_calibration(struct sec_ts_data *ts, int cal_mode);
+int get_tsp_nvm_data(struct sec_ts_data *ts, u8 offset);
+void sec_ts_release_all_finger(struct sec_ts_data *ts);
+
+int sec_ts_sw_reset(struct sec_ts_data *ts);
+void sec_ts_delay(unsigned int ms);
+int sec_ts_fn_init(struct sec_ts_data *ts);
+u8 *sec_get_fwdata(void);
+
+extern struct class *sec_class;
+
+#if defined(CONFIG_SEC_DEBUG_TSP_LOG)
+extern void sec_ts_run_rawdata_all(struct sec_ts_data *ts);
+#endif
+#ifndef input_dbg
+#define input_dbg(mode, dev, fmt, ...) dev_dbg(dev, fmt, ## __VA_ARGS__)
+#endif
+#ifndef input_info
+#define input_info(mode, dev, fmt, ...)	dev_info(dev, fmt, ## __VA_ARGS__)
+#endif
+#ifndef input_err
+#define input_err(mode, dev, fmt, ...) dev_err(dev, fmt, ## __VA_ARGS__)
+#endif
+#endif
diff --git a/drivers/input/touchscreen/sec_ts/sec_ts_fn.c b/drivers/input/touchscreen/sec_ts/sec_ts_fn.c
new file mode 100644
index 000000000000..30e6dea0beea
--- /dev/null
+++ b/drivers/input/touchscreen/sec_ts/sec_ts_fn.c
@@ -0,0 +1,1570 @@
+/* Samsung Touchscreen Controller Driver.
+ *
+ * Copyright (c) 2007-2012, Samsung Electronics
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/unaligned.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/hrtimer.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#ifdef SAMSUNG_PROJECT
+#include <linux/sec_sysfs.h>
+#endif
+#include "sec_ts.h"
+#include <linux/uaccess.h>
+
+#define tostring(x) (#x)
+
+#define FT_CMD(name, func) .cmd_name = name, .cmd_func = func
+
+/*extern struct class *sec_class;*/
+
+enum {
+	TYPE_RAW_DATA = 0, /*  Tota cap - offset(19) = remnant dta */
+	TYPE_SIGNAL_DATA = 1,
+	TYPE_AMBIENT_BASELINE = 2, /* Cap Baseline */
+	TYPE_AMBIENT_DATA = 3,		 /* Cap Ambient */
+	TYPE_REMV_BASELINE_DATA = 4,
+	TYPE_DECODED_DATA = 5,
+	TYPE_REMV_AMB_DATA = 6,
+	TYPE_OFFSET_DATA_SEC = 19, /* Cap Offset for Normal Touch */
+	TYPE_OFFSET_DATA_SDC = 29, /* Cap Offset in SDC */
+	TYPE_INVALID_DATA = 0xFF,	/* Invalid data type for release factory mode*/
+};
+
+enum CMD_STATUS {
+	CMD_STATUS_WAITING = 0,
+	CMD_STATUS_RUNNING,
+	CMD_STATUS_OK,
+	CMD_STATUS_FAIL,
+	CMD_STATUS_NOT_APPLICABLE,
+};
+
+struct ft_cmd {
+	struct list_head list;
+	const char *cmd_name;
+	void (*cmd_func)(void *device_data);
+};
+
+static ssize_t cmd_store(struct device *dev, struct device_attribute *attr,
+												 const char *buf, size_t count);
+static ssize_t cmd_status_show(struct device *dev,
+															 struct device_attribute *attr, char *buf);
+static ssize_t cmd_result_show(struct device *dev,
+															 struct device_attribute *attr, char *buf);
+static ssize_t cmd_list_show(struct device *dev, struct device_attribute *attr,
+														 char *buf);
+static ssize_t scrub_position_show(struct device *dev,
+																	 struct device_attribute *attr, char *buf);
+static ssize_t edge_x_position(struct device *dev,
+															 struct device_attribute *attr, char *buf);
+
+static DEVICE_ATTR(cmd, S_IWUSR | S_IWGRP, NULL, cmd_store);
+static DEVICE_ATTR(cmd_status, S_IRUGO, cmd_status_show, NULL);
+static DEVICE_ATTR(cmd_result, S_IRUGO, cmd_result_show, NULL);
+static DEVICE_ATTR(cmd_list, S_IRUGO, cmd_list_show, NULL);
+static DEVICE_ATTR(scrub_pos, S_IRUGO, scrub_position_show, NULL);
+static DEVICE_ATTR(edge_pos, S_IRUGO, edge_x_position, NULL);
+
+static int execute_selftest(struct sec_ts_data *ts);
+
+static void fw_update(void *device_data);
+static void get_fw_ver_bin(void *device_data);
+static void get_fw_ver_ic(void *device_data);
+static void get_config_ver(void *device_data);
+static void get_threshold(void *device_data);
+static void module_off_master(void *device_data);
+static void module_on_master(void *device_data);
+static void get_chip_vendor(void *device_data);
+static void get_chip_name(void *device_data);
+static void get_x_num(void *device_data);
+static void get_y_num(void *device_data);
+static void get_x_cross_routing(void *device_data);
+static void get_y_cross_routing(void *device_data);
+static void get_checksum_data(void *device_data);
+static void run_force_calibration(void *device_data);
+static void get_force_calibration(void *device_data);
+static void glove_mode(void *device_data);
+static void hover_enable(void *device_data);
+static void set_lowpower_mode(void *device_data);
+static void set_log_level(void *device_data);
+static void not_support_cmd(void *device_data);
+
+struct ft_cmd ft_cmds[] = {
+		{
+				FT_CMD("fw_update", fw_update),
+		},
+		{
+				FT_CMD("get_fw_ver_bin", get_fw_ver_bin),
+		},
+		{
+				FT_CMD("get_fw_ver_ic", get_fw_ver_ic),
+		},
+		{
+				FT_CMD("get_config_ver", get_config_ver),
+		},
+		{
+				FT_CMD("get_threshold", get_threshold),
+		},
+		{
+				FT_CMD("module_off_master", module_off_master),
+		},
+		{
+				FT_CMD("module_on_master", module_on_master),
+		},
+		{
+				FT_CMD("get_chip_vendor", get_chip_vendor),
+		},
+		{
+				FT_CMD("get_chip_name", get_chip_name),
+		},
+		{
+				FT_CMD("get_x_num", get_x_num),
+		},
+		{
+				FT_CMD("get_y_num", get_y_num),
+		},
+		{
+				FT_CMD("get_x_cross_routing", get_x_cross_routing),
+		},
+		{
+				FT_CMD("get_y_cross_routing", get_y_cross_routing),
+		},
+		{
+				FT_CMD("get_checksum_data", get_checksum_data),
+		},
+		{
+				FT_CMD("run_force_calibration", run_force_calibration),
+		},
+		{
+				FT_CMD("get_force_calibration", get_force_calibration),
+		},
+		{
+				FT_CMD("glove_mode", glove_mode),
+		},
+		{
+				FT_CMD("hover_enable", hover_enable),
+		},
+		{
+				FT_CMD("set_lowpower_mode", set_lowpower_mode),
+		},
+		{
+				FT_CMD("set_log_level", set_log_level),
+		},
+		{
+				FT_CMD("not_support_cmd", not_support_cmd),
+		},
+};
+
+static struct attribute *cmd_attributes[] = {
+		&dev_attr_cmd.attr,
+		&dev_attr_cmd_status.attr,
+		&dev_attr_cmd_list.attr,
+		&dev_attr_cmd_result.attr,
+		&dev_attr_scrub_pos.attr,
+		&dev_attr_edge_pos.attr,
+		NULL,
+};
+
+static struct attribute_group cmd_attr_group = {
+		.attrs = cmd_attributes,
+};
+
+static void set_default_result(struct sec_ts_data *data) {
+	char delim = ':';
+
+	memset(data->cmd_result, 0x00, CMD_RESULT_STR_LEN);
+	memcpy(data->cmd_result, data->cmd, strnlen(data->cmd, CMD_STR_LEN));
+	strncat(data->cmd_result, &delim, 1);
+}
+
+static void set_cmd_result(struct sec_ts_data *data, char *buf, int length) {
+	strncat(data->cmd_result, buf, length);
+}
+
+static ssize_t cmd_store(struct device *dev, struct device_attribute *attr,
+												 const char *buf, size_t count) {
+	unsigned char param_cnt = 0;
+	char *start;
+	char *end;
+	char *pos;
+	char delim = ',';
+	char buffer[CMD_STR_LEN];
+	bool cmd_found = false;
+	int *param;
+	int length;
+	struct ft_cmd *ft_cmd_ptr = NULL;
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+	int i;
+
+	if (!ts) {
+		pr_err("%s: No platform data found\n", __func__);
+		return -EINVAL;
+	}
+
+#if 1
+	if (ts->cmd_is_running == true) {
+		input_err(true, &ts->client->dev, "%s: other cmd is running.\n", __func__);
+
+		return -EBUSY;
+	} else if (ts->reinit_done == false) {
+		input_err(true, &ts->client->dev, "ft_cmd: reinit is working\n");
+	}
+#endif
+	mutex_lock(&ts->cmd_lock);
+	ts->cmd_is_running = true;
+	mutex_unlock(&ts->cmd_lock);
+
+	ts->cmd_state = CMD_STATUS_RUNNING;
+
+	length = (int)count;
+	if (*(buf + length - 1) == '\n')
+		length--;
+
+	memset(ts->cmd, 0x00, sizeof(ts->cmd));
+	memcpy(ts->cmd, buf, length);
+	memset(ts->cmd_param, 0, sizeof(ts->cmd_param));
+	memset(buffer, 0x00, sizeof(buffer));
+
+	pos = strchr(buf, (int)delim);
+	if (pos)
+		memcpy(buffer, buf, pos - buf);
+	else
+		memcpy(buffer, buf, length);
+
+	/* find command */
+	list_for_each_entry(ft_cmd_ptr, &ts->cmd_list_head, list) {
+		if (!strcmp(buffer, ft_cmd_ptr->cmd_name)) {
+			cmd_found = true;
+			break;
+		}
+	}
+
+	/* set not_support_cmd */
+	if (!cmd_found) {
+		list_for_each_entry(ft_cmd_ptr, &ts->cmd_list_head, list) {
+			if (!strcmp("not_support_cmd", ft_cmd_ptr->cmd_name))
+				break;
+		}
+	}
+
+	/* parsing parameters */
+	if (cmd_found && pos) {
+		pos++;
+		start = pos;
+		memset(buffer, 0x00, sizeof(buffer));
+		do {
+			if ((*pos == delim) || (pos - buf == length)) {
+				end = pos;
+				memcpy(buffer, start, end - start);
+				*(buffer + strlen(buffer)) = '\0';
+				param = ts->cmd_param + param_cnt;
+				if (kstrtoint(buffer, 10, param) < 0)
+					goto err_out;
+				param_cnt++;
+				memset(buffer, 0x00, sizeof(buffer));
+				start = pos + 1;
+			}
+			pos++;
+		} while (pos - buf <= length);
+	}
+
+	input_err(true, &ts->client->dev, "%s: Command = %s\n", __func__, buf);
+	for (i = 0; i < param_cnt; i++)
+		input_info(true, &ts->client->dev, "cmd param %d= %d\n", i,
+							 ts->cmd_param[i]);
+
+	ft_cmd_ptr->cmd_func(ts);
+
+err_out:
+	return count;
+}
+
+static ssize_t cmd_status_show(struct device *dev,
+															 struct device_attribute *attr, char *buf) {
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+	char buffer[16];
+
+	input_err(true, &ts->client->dev, "%s: Command status = %d\n", __func__,
+						ts->cmd_state);
+
+	switch (ts->cmd_state) {
+	case CMD_STATUS_WAITING:
+		snprintf(buffer, sizeof(buffer), "%s", tostring(WAITING));
+		break;
+	case CMD_STATUS_RUNNING:
+		snprintf(buffer, sizeof(buffer), "%s", tostring(RUNNING));
+		break;
+	case CMD_STATUS_OK:
+		snprintf(buffer, sizeof(buffer), "%s", tostring(OK));
+		break;
+	case CMD_STATUS_FAIL:
+		snprintf(buffer, sizeof(buffer), "%s", tostring(FAIL));
+		break;
+	case CMD_STATUS_NOT_APPLICABLE:
+		snprintf(buffer, sizeof(buffer), "%s", tostring(NOT_APPLICABLE));
+		break;
+	default:
+		snprintf(buffer, sizeof(buffer), "%s", tostring(NOT_APPLICABLE));
+		break;
+	}
+
+	return snprintf(buf, CMD_RESULT_STR_LEN, "%s\n", buffer);
+}
+
+static ssize_t cmd_result_show(struct device *dev,
+															 struct device_attribute *attr, char *buf) {
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+
+	input_info(true, &ts->client->dev, "%s: Command result = %s\n", __func__,
+						 ts->cmd_result);
+
+	mutex_lock(&ts->cmd_lock);
+	ts->cmd_is_running = false;
+	mutex_unlock(&ts->cmd_lock);
+
+	ts->cmd_state = CMD_STATUS_WAITING;
+
+	return snprintf(buf, CMD_RESULT_STR_LEN, "%s\n", ts->cmd_result);
+}
+
+static ssize_t cmd_list_show(struct device *dev, struct device_attribute *attr,
+														 char *buf) {
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+	char buffer[ts->cmd_buffer_size];
+	char buffer_name[CMD_STR_LEN];
+	int ii = 0;
+
+	snprintf(buffer, CMD_STR_LEN, "++factory command list++\n");
+	while (strncmp(ft_cmds[ii].cmd_name, "not_support_cmd", 16) != 0) {
+		snprintf(buffer_name, CMD_STR_LEN, "%s\n", ft_cmds[ii].cmd_name);
+		strcat(buffer, buffer_name);
+		ii++;
+	}
+
+	input_info(true, &ts->client->dev, "%s: length : %u / %d\n", __func__,
+						 (unsigned int)strlen(buffer), ts->cmd_buffer_size + CMD_STR_LEN);
+
+	return snprintf(buf, SEC_CMD_BUF_SIZE, "%s\n", buffer);
+}
+
+static ssize_t scrub_position_show(struct device *dev,
+																	 struct device_attribute *attr, char *buf) {
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+	char buff[256] = {0};
+
+	input_info(true, &ts->client->dev, "%s: scrub_id: %d, X:%d, Y:%d\n", __func__,
+						 ts->scrub_id, ts->scrub_x, ts->scrub_y);
+
+	snprintf(buff, sizeof(buff), "%d %d %d", ts->scrub_id, ts->scrub_x,
+					 ts->scrub_y);
+
+	ts->scrub_id = 0;
+	ts->scrub_x = 0;
+	ts->scrub_y = 0;
+
+	return snprintf(buf, PAGE_SIZE, "%s", buff);
+}
+
+static ssize_t edge_x_position(struct device *dev,
+															 struct device_attribute *attr, char *buf) {
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+	char buff[256] = {0};
+	int edge_position_left = 0, edge_position_right = 0;
+
+	if (!ts) {
+		pr_err("%s: No platform data found\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!ts->input_dev) {
+		pr_err("%s: No input_dev data found\n", __func__);
+		return -EINVAL;
+	}
+
+	input_info(true, &ts->client->dev, "%s: %d,%d\n", __func__,
+						 edge_position_left, edge_position_right);
+	snprintf(buff, sizeof(buff), "%d,%d", edge_position_left,
+					 edge_position_right);
+
+	return snprintf(buf, SEC_CMD_BUF_SIZE, "%s\n", buff);
+}
+static void fw_update(void *device_data) {
+#ifdef CONFIG_6FT0
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[64] = {0};
+	int retval = 0;
+
+	set_default_result(ts);
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_info(true, &ts->client->dev, "%s: [ERROR] Touch is stopped\n",
+							 __func__);
+		snprintf(buff, sizeof(buff), "%s", "TSP turned off");
+		set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+		ts->cmd_state = CMD_STATUS_NOT_APPLICABLE;
+		return;
+	}
+
+	retval = sec_ts_firmware_update_on_hidden_menu(ts, ts->cmd_param[0]);
+	if (retval < 0) {
+		snprintf(buff, sizeof(buff), "%s", "NA");
+		set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+		ts->cmd_state = CMD_STATUS_FAIL;
+		input_info(true, &ts->client->dev, "%s: failed [%d]\n", __func__, retval);
+	} else {
+		snprintf(buff, sizeof(buff), "%s", "OK");
+		set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+		ts->cmd_state = CMD_STATUS_OK;
+		input_info(true, &ts->client->dev, "%s: success [%d]\n", __func__, retval);
+	}
+#endif
+}
+
+void sec_ts_print_frame(struct sec_ts_data *ts, short *min, short *max) {
+	int i = 0;
+	int j = 0;
+	unsigned char *pStr = NULL;
+	unsigned char pTmp[16] = {0};
+
+	pStr = kzalloc(6 * (ts->tx_count + 1), GFP_KERNEL);
+	if (pStr == NULL) {
+		pr_err("%s: kzalloc %d bytes failed for pStr\n", __func__,
+					 6 * (ts->tx_count + 1));
+		return;
+	}
+
+	snprintf(pTmp, sizeof(pTmp), "    ");
+	strncat(pStr, pTmp, 6 * ts->tx_count);
+
+	for (i = 0; i < ts->tx_count; i++) {
+		snprintf(pTmp, sizeof(pTmp), "Tx%02d  ", i);
+		strncat(pStr, pTmp, 6 * ts->tx_count);
+	}
+
+	input_info(true, &ts->client->dev, "SEC_TS %s\n", pStr);
+	memset(pStr, 0x0, 6 * (ts->tx_count + 1));
+	snprintf(pTmp, sizeof(pTmp), " +");
+	strncat(pStr, pTmp, 6 * ts->tx_count);
+
+	for (i = 0; i < ts->tx_count; i++) {
+		snprintf(pTmp, sizeof(pTmp), "------");
+		strncat(pStr, pTmp, 6 * ts->rx_count);
+	}
+
+	input_info(true, &ts->client->dev, "SEC_TS %s\n", pStr);
+
+	for (i = 0; i < ts->rx_count; i++) {
+		memset(pStr, 0x0, 6 * (ts->tx_count + 1));
+		snprintf(pTmp, sizeof(pTmp), "Rx%02d | ", i);
+		strncat(pStr, pTmp, 6 * ts->tx_count);
+
+		for (j = 0; j < ts->tx_count; j++) {
+			snprintf(pTmp, sizeof(pTmp), "%5d ", ts->pFrame[(j * ts->rx_count) + i]);
+
+			if (i > 0) {
+				if (ts->pFrame[(j * ts->rx_count) + i] < *min)
+					*min = ts->pFrame[(j * ts->rx_count) + i];
+
+				if (ts->pFrame[(j * ts->rx_count) + i] > *max)
+					*max = ts->pFrame[(j * ts->rx_count) + i];
+			}
+			strncat(pStr, pTmp, 6 * ts->rx_count);
+		}
+		input_info(true, &ts->client->dev, "SEC_TS %s\n", pStr);
+	}
+	kfree(pStr);
+}
+
+int sec_ts_read_frame(struct sec_ts_data *ts, u8 type, short *min, short *max) {
+	unsigned int readbytes = 0xFF;
+	unsigned char *pRead = NULL;
+	u8 mode = TYPE_INVALID_DATA;
+	int rc = 0;
+	int ret = 0;
+	int i = 0;
+	int j = 0;
+	short *temp = NULL;
+
+	input_info(true, &ts->client->dev, "%s\n", __func__);
+
+	/* set data length, allocation buffer memory */
+	readbytes = ts->rx_count * ts->tx_count * 2;
+
+	pRead = kzalloc(readbytes, GFP_KERNEL);
+	if (pRead == NULL) {
+		rc = 1;
+		pr_err("%s: kzalloc %d bytes failed for pRead\n", __func__, readbytes);
+		return rc;
+	}
+
+	/* set OPCODE and data type */
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_MUTU_RAW_TYPE, &type, 1);
+	if (ret < 0) {
+		input_info(true, &ts->client->dev, "Set rawdata type failed\n");
+		rc = 2;
+		goto ErrorExit;
+	}
+
+	sec_ts_delay(50);
+	if (type == TYPE_OFFSET_DATA_SDC) {
+		/* excute selftest for real cap offset data,
+		* because real cap data is not memory data in normal touch.
+		*/
+		char para = TO_TOUCH_MODE;
+
+		disable_irq(ts->client->irq);
+		execute_selftest(ts);
+		ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SET_POWER_MODE, &para, 1);
+		if (ret < 0) {
+			input_err(true, &ts->client->dev, "%s: set rawdata type failed!\n",
+								__func__);
+			enable_irq(ts->client->irq);
+			goto ErrorRelease;
+		}
+		enable_irq(ts->client->irq);
+		/* end */
+	}
+
+	/* read data */
+	ret = ts->sec_ts_i2c_read(ts, SEC_TS_READ_TOUCH_RAWDATA, pRead, readbytes);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: read rawdata failed!\n", __func__);
+		rc = 3;
+		goto ErrorRelease;
+	}
+
+	memset(ts->pFrame, 0x00, readbytes);
+
+	for (i = 0; i < readbytes; i += 2)
+		ts->pFrame[i / 2] = pRead[i + 1] + (pRead[i] << 8);
+
+	*min = *max = ts->pFrame[0];
+
+#ifdef DEBUG_MSG
+	input_info(true, &ts->client->dev, "02X%02X%02X readbytes=%d\n", pRead[0],
+						 pRead[1], pRead[2], readbytes);
+#endif
+	sec_ts_print_frame(ts, min, max);
+
+	temp = kzalloc(readbytes, GFP_KERNEL);
+	if (temp == NULL) {
+		pr_err("%s: kzalloc %d bytes failed for temp\n", __func__, readbytes);
+		goto ErrorRelease;
+	}
+
+	memcpy(temp, ts->pFrame, readbytes);
+	memset(ts->pFrame, 0x00, readbytes);
+
+	for (i = 0; i < ts->tx_count; i++) {
+		for (j = 0; j < ts->rx_count; j++)
+			ts->pFrame[(j * ts->tx_count) + i] = temp[(i * ts->rx_count) + j];
+	}
+
+	kfree(temp);
+
+ErrorRelease:
+	/* release data monitory (unprepare AFE data memory) */
+	ret = ts->sec_ts_i2c_read(ts, SEC_TS_CMD_MUTU_RAW_TYPE, &mode, 1);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: set rawdata failed!\n", __func__);
+
+ErrorExit:
+	kfree(pRead);
+
+	return rc;
+}
+
+void sec_ts_print_self_frame(struct sec_ts_data *ts, short *min, short *max,
+														 unsigned int num_long_ch,
+														 unsigned int num_short_ch) {
+	int i = 0;
+	unsigned char *pStr = NULL;
+	unsigned char pTmp[16] = {0};
+
+	pStr = kzalloc(6 * (num_short_ch + 1), GFP_KERNEL);
+	if (pStr == NULL) {
+		pr_err("%s: kzalloc %d bytes failed for pStr\n", __func__,
+					 6 * (num_short_ch + 1));
+		return;
+	}
+
+	snprintf(pTmp, sizeof(pTmp), "          ");
+	strncat(pStr, pTmp, 6 * num_short_ch);
+
+	for (i = 0; i < num_short_ch; i++) {
+		snprintf(pTmp, sizeof(pTmp), "Sc%02d  ", i);
+		strncat(pStr, pTmp, 6 * num_short_ch);
+	}
+
+	input_info(true, &ts->client->dev, "SEC_TS %s\n", pStr);
+	memset(pStr, 0x0, 6 * (num_short_ch + 1));
+	snprintf(pTmp, sizeof(pTmp), "      +");
+	strncat(pStr, pTmp, 6 * num_short_ch);
+
+	for (i = 0; i < num_short_ch; i++) {
+		snprintf(pTmp, sizeof(pTmp), "------");
+		strncat(pStr, pTmp, 6 * num_short_ch);
+	}
+
+	input_info(true, &ts->client->dev, "SEC_TS %s\n", pStr);
+
+	memset(pStr, 0x0, 6 * (num_short_ch + 1));
+	for (i = 0; i < num_short_ch; i++) {
+		snprintf(pTmp, sizeof(pTmp), "%5d ", ts->sFrame[i]);
+		strncat(pStr, pTmp, 6 * num_short_ch);
+		if (ts->sFrame[i] < *min)
+			*min = ts->sFrame[i];
+		if (ts->sFrame[i] > *max)
+			*max = ts->sFrame[i];
+	}
+
+	input_info(true, &ts->client->dev, "SEC_TS        %s\n", pStr);
+
+	for (i = 0; i < num_long_ch; i++) {
+		memset(pStr, 0x0, 6 * (num_short_ch + 1));
+		snprintf(pTmp, sizeof(pTmp), "Lc%02d | ", i);
+		strncat(pStr, pTmp, 6 * num_short_ch);
+		snprintf(pTmp, sizeof(pTmp), "%5d ", ts->sFrame[num_short_ch + i]);
+		strncat(pStr, pTmp, 6 * num_short_ch);
+
+		if (ts->sFrame[num_short_ch + i] < *min)
+			*min = ts->sFrame[num_short_ch + i];
+		if (ts->sFrame[num_short_ch + i] > *max)
+			*max = ts->sFrame[num_short_ch + i];
+
+		input_info(true, &ts->client->dev, "SEC_TS %s\n", pStr);
+	}
+	kfree(pStr);
+}
+
+#define PRE_DEFINED_DATA_LENGTH 208
+static void get_fw_ver_bin(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[16] = {0};
+
+	set_default_result(ts);
+
+	sprintf(buff, "SE%02X%02X%02X", ts->plat_data->panel_revision,
+					ts->plat_data->img_version_of_bin[2],
+					ts->plat_data->img_version_of_bin[3]);
+
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = CMD_STATUS_OK;
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+
+static void get_fw_ver_ic(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[16] = {0};
+	u8 img_ver[4];
+	int ret;
+
+	set_default_result(ts);
+
+	ret = ts->sec_ts_i2c_read(ts, SEC_TS_READ_IMG_VERSION, img_ver, 4);
+	if (ret < 0) {
+		input_info(true, &ts->client->dev, "%s: Image version read error\n ",
+							 __func__);
+		ts->cmd_state = CMD_STATUS_FAIL;
+	}
+
+	sprintf(buff, "SE%02X%02X%02X", ts->plat_data->panel_revision, img_ver[2],
+					img_ver[3]);
+
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = CMD_STATUS_OK;
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+
+static void get_config_ver(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[20] = {0};
+
+	set_default_result(ts);
+
+	sprintf(buff, "%s_SE_%02X%02X",
+					ts->plat_data->project_name ?: ts->plat_data->model_name
+																						 ?: SEC_TS_DEVICE_NAME,
+					ts->plat_data->para_version_of_ic[2],
+					ts->plat_data->para_version_of_ic[3]);
+
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = CMD_STATUS_OK;
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+
+static void get_threshold(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[20] = {0};
+
+	char w_param[1];
+	char r_param[2];
+	int threshold = 0;
+	int ret;
+
+	set_default_result(ts);
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		char buff[CMD_STR_LEN] = {0};
+
+		input_info(true, &ts->client->dev, "%s: [ERROR] Touch is stopped\n",
+							 __func__);
+		snprintf(buff, sizeof(buff), "%s", "TSP turned off");
+		set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+		ts->cmd_state = CMD_STATUS_NOT_APPLICABLE;
+		return;
+	}
+
+	w_param[0] = 0;
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_READ_THRESHOLD, w_param, 1);
+	if (ret < 0)
+		input_err(true, &ts->client->dev,
+							"%s: threshold write type failed. ret: %d\n", __func__, ret);
+
+	ret = ts->sec_ts_i2c_read_bulk(ts, r_param, 2);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s threshold read failed. ret: %d\n",
+							__func__, ret);
+
+	threshold = (r_param[0] << 8 | r_param[1]);
+	snprintf(buff, sizeof(buff), "%d", threshold);
+
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = CMD_STATUS_OK;
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+
+static void module_off_master(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[3] = {0};
+	int ret = 0;
+
+	mutex_lock(&ts->lock);
+	if (ts->power_status) {
+		disable_irq(ts->client->irq);
+		ts->power_status = SEC_TS_STATE_POWER_OFF;
+	}
+	mutex_unlock(&ts->lock);
+
+	if (ts->plat_data->power)
+		ts->plat_data->power(ts, false);
+	else
+		ret = 1;
+
+	if (ret == 0)
+		snprintf(buff, sizeof(buff), "%s", "OK");
+	else
+		snprintf(buff, sizeof(buff), "%s", "NG");
+
+	set_default_result(ts);
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	if (strncmp(buff, "OK", 2) == 0)
+		ts->cmd_state = CMD_STATUS_OK;
+	else
+		ts->cmd_state = CMD_STATUS_FAIL;
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+
+static void module_on_master(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[3] = {0};
+	int ret = 0;
+
+	mutex_lock(&ts->lock);
+	if (!ts->power_status) {
+		enable_irq(ts->client->irq);
+		ts->power_status = SEC_TS_STATE_POWER_ON;
+	}
+	mutex_unlock(&ts->lock);
+
+	if (ts->plat_data->power) {
+		ts->plat_data->power(ts, true);
+		ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SENSE_ON, NULL, 0);
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "%s: fail to write Sense_on\n",
+								__func__);
+	} else
+		ret = 1;
+
+	if (ret == 0)
+		snprintf(buff, sizeof(buff), "%s", "OK");
+	else
+		snprintf(buff, sizeof(buff), "%s", "NG");
+
+	set_default_result(ts);
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	if (strncmp(buff, "OK", 2) == 0)
+		ts->cmd_state = CMD_STATUS_OK;
+	else
+		ts->cmd_state = CMD_STATUS_FAIL;
+
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+
+static void get_chip_vendor(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[16] = {0};
+
+	strncpy(buff, "SEC", sizeof(buff));
+	set_default_result(ts);
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = CMD_STATUS_OK;
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+
+static void get_chip_name(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[16] = {0};
+
+	if (ts->plat_data->img_version_of_ic[0] == 2)
+		strncpy(buff, "MC44", sizeof(buff));
+	else if (ts->plat_data->img_version_of_ic[0] == 5)
+		strncpy(buff, "A552", sizeof(buff));
+
+	set_default_result(ts);
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = CMD_STATUS_OK;
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+
+static void get_x_num(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[16] = {0};
+
+	set_default_result(ts);
+	snprintf(buff, sizeof(buff), "%d", ts->tx_count);
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = 2;
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+
+static void get_y_num(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[16] = {0};
+
+	set_default_result(ts);
+	snprintf(buff, sizeof(buff), "%d", ts->rx_count);
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = CMD_STATUS_OK;
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+
+static void get_x_cross_routing(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[16] = {0};
+
+	set_default_result(ts);
+	snprintf(buff, sizeof(buff), "NG");
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = CMD_STATUS_OK;
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+
+static void get_y_cross_routing(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[16] = {0};
+	int ret;
+
+	set_default_result(ts);
+
+	ret = strncmp(ts->plat_data->model_name, "G935", 4);
+	if (ret == 0)
+		snprintf(buff, sizeof(buff), "13,14");
+	else
+		snprintf(buff, sizeof(buff), "NG");
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = CMD_STATUS_OK;
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+
+static void get_checksum_data(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[16] = {0};
+	char csum_result[4] = {0};
+	u8 nv_result;
+	u8 cal_result;
+	u8 temp = 0;
+	u8 csum = 0;
+	int ret, i;
+
+	set_default_result(ts);
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_info(true, &ts->client->dev, "%s: [ERROR] Touch is stopped\n",
+							 __func__);
+		snprintf(buff, sizeof(buff), "%s", "TSP turned off");
+		goto err;
+	}
+
+	temp = DO_FW_CHECKSUM | DO_PARA_CHECKSUM;
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_GET_CHECKSUM, &temp, 1);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: send get_checksum_cmd fail!\n",
+							__func__);
+		snprintf(buff, sizeof(buff), "%s", "SendCMDfail");
+		goto err;
+	}
+
+	sec_ts_delay(20);
+
+	ret = ts->sec_ts_i2c_read_bulk(ts, csum_result, 4);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: read get_checksum result fail!\n",
+							__func__);
+		snprintf(buff, sizeof(buff), "%s", "ReadCSUMfail");
+		goto err;
+	}
+
+	nv_result = get_tsp_nvm_data(ts, SEC_TS_NVM_OFFSET_FAC_RESULT);
+	nv_result += get_tsp_nvm_data(ts, SEC_TS_NVM_OFFSET_CAL_COUNT);
+
+	cal_result = sec_ts_read_calibration_report(ts);
+
+	for (i = 0; i < 4; i++)
+		csum += csum_result[i];
+
+	csum += temp;
+	csum += cal_result;
+	csum = ~csum;
+
+	input_info(true, &ts->client->dev, "%s: checksum = %02X\n", __func__, csum);
+	snprintf(buff, sizeof(buff), "%02X", csum);
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = CMD_STATUS_OK;
+	return;
+
+err:
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = CMD_STATUS_NOT_APPLICABLE;
+}
+
+static void set_tsp_nvm_data_clear(struct sec_ts_data *ts) {
+	char buff[4] = {0};
+	int ret;
+
+	input_info(true, &ts->client->dev, "%s\n", __func__);
+
+	/* Use TSP NV area
+	 * buff[0] : offset from user NVM storage
+	 * buff[1] : length of stroed data - 1 (ex. using 1byte, value is  1 - 1 = 0)
+	 * buff[2] : write data
+	 */
+	buff[1] = 2 - 1;
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_NVM, buff, 4);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s nvm write failed. ret: %d\n",
+							__func__, ret);
+
+	sec_ts_delay(20);
+
+	ts->nv = get_tsp_nvm_data(ts, SEC_TS_NVM_OFFSET_FAC_RESULT);
+	ts->cal_count = get_tsp_nvm_data(ts, SEC_TS_NVM_OFFSET_CAL_COUNT);
+
+	input_info(true, &ts->client->dev, "%s: fac_nv:%02X, cal_nv:%02X\n", __func__,
+						 ts->nv, ts->cal_count);
+}
+
+int get_tsp_nvm_data(struct sec_ts_data *ts, u8 offset) {
+	char buff[2] = {0};
+	int ret;
+
+	input_info(true, &ts->client->dev, "%s, offset:%u\n", __func__, offset);
+
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SENSE_OFF, NULL, 0);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: sense off failed\n", __func__);
+		goto out_nvm;
+	}
+	input_dbg(true, &ts->client->dev, "%s: SENSE OFF\n", __func__);
+
+	sec_ts_delay(100);
+
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_CLEAR_EVENT_STACK, NULL, 0);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: clear event failed\n", __func__);
+		goto out_nvm;
+	}
+	input_dbg(true, &ts->client->dev, "%s: CLEAR EVENT STACK\n", __func__);
+
+	sec_ts_delay(100);
+
+	sec_ts_release_all_finger(ts);
+
+	/* send NV data using command
+	 * Use TSP NV area : in this model, use only one byte
+	 * buff[0] : offset from user NVM storage
+	 * buff[1] : length of stroed data - 1 (ex. using 1byte, value is  1 - 1 = 0)
+	 */
+	memset(buff, 0x00, 2);
+	buff[0] = offset;
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_NVM, buff, 2);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s nvm send command failed. ret: %d\n",
+							__func__, ret);
+		goto out_nvm;
+	}
+
+	sec_ts_delay(10);
+
+	/* read NV data
+	 * Use TSP NV area : in this model, use only one byte
+	 */
+	ret = ts->sec_ts_i2c_read_bulk(ts, buff, 1);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s nvm send command failed. ret: %d\n",
+							__func__, ret);
+		goto out_nvm;
+	}
+
+	input_info(true, &ts->client->dev, "%s: data:%X\n", __func__, buff[0]);
+
+out_nvm:
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SENSE_ON, NULL, 0);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: sense on failed\n", __func__);
+
+	input_dbg(true, &ts->client->dev, "%s: SENSE ON\n", __func__);
+
+	return buff[0];
+}
+
+/* FACTORY TEST RESULT SAVING FUNCTION
+ * bit 3 ~ 0 : OCTA Assy
+ * bit 7 ~ 4 : OCTA module
+ * param[0] : OCTA modue(1) / OCTA Assy(2)
+ * param[1] : TEST NONE(0) / TEST FAIL(1) / TEST PASS(2) : 2 bit
+ */
+
+#define TEST_OCTA_MODULE 1
+#define TEST_OCTA_ASSAY 2
+
+#define TEST_OCTA_NONE 0
+#define TEST_OCTA_FAIL 1
+#define TEST_OCTA_PASS 2
+
+#define GLOVE_MODE_EN (1 << 0)
+#define FAST_GLOVE_MODE_EN (1 << 2)
+
+static void glove_mode(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	int glove_mode_enables = 0;
+
+	set_default_result(ts);
+
+	if (ts->cmd_param[0] < 0 || ts->cmd_param[0] > 1) {
+		snprintf(ts->cmd_buff, sizeof(ts->cmd_buff), "NG");
+		ts->cmd_state = CMD_STATUS_FAIL;
+	} else {
+		int retval;
+
+		if (ts->cmd_param[0])
+			glove_mode_enables |= GLOVE_MODE_EN;
+		else
+			glove_mode_enables &= ~(GLOVE_MODE_EN);
+
+		retval = sec_ts_glove_mode_enables(ts, glove_mode_enables);
+
+		if (retval < 0) {
+			input_err(true, &ts->client->dev, "%s failed, retval = %d\n", __func__,
+								retval);
+			snprintf(ts->cmd_buff, sizeof(ts->cmd_buff), "NG");
+			ts->cmd_state = CMD_STATUS_FAIL;
+		} else {
+			snprintf(ts->cmd_buff, sizeof(ts->cmd_buff), "OK");
+			ts->cmd_state = CMD_STATUS_OK;
+		}
+	}
+
+	set_cmd_result(ts, ts->cmd_buff, strlen(ts->cmd_buff));
+
+	mutex_lock(&ts->cmd_lock);
+	ts->cmd_is_running = false;
+	mutex_unlock(&ts->cmd_lock);
+
+	ts->cmd_state = CMD_STATUS_WAITING;
+}
+
+static void hover_enable(void *device_data) {
+	int enables;
+	int retval;
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+
+	input_info(true, &ts->client->dev, "%s: enter hover enable, param = %d\n",
+						 __func__, ts->cmd_param[0]);
+
+	set_default_result(ts);
+
+	if (ts->cmd_param[0] < 0 || ts->cmd_param[0] > 1) {
+		snprintf(ts->cmd_buff, sizeof(ts->cmd_buff), "NG");
+		ts->cmd_state = CMD_STATUS_FAIL;
+	} else {
+		enables = ts->cmd_param[0];
+		retval = sec_ts_hover_enables(ts, enables);
+
+		if (retval < 0) {
+			input_err(true, &ts->client->dev, "%s failed, retval = %d\n", __func__,
+								retval);
+			snprintf(ts->cmd_buff, sizeof(ts->cmd_buff), "NG");
+			ts->cmd_state = CMD_STATUS_FAIL;
+		} else {
+			snprintf(ts->cmd_buff, sizeof(ts->cmd_buff), "OK");
+			ts->cmd_state = CMD_STATUS_OK;
+		}
+	}
+
+	set_cmd_result(ts, ts->cmd_buff, strlen(ts->cmd_buff));
+	mutex_lock(&ts->cmd_lock);
+	ts->cmd_is_running = false;
+	mutex_unlock(&ts->cmd_lock);
+
+	ts->cmd_state = CMD_STATUS_WAITING;
+}
+
+static void sec_ts_swap(u8 *a, u8 *b) {
+	u8 temp = *a;
+	*a = *b;
+	*b = temp;
+}
+
+static void rearrange_sft_result(u8 *data, int length) {
+	int i;
+
+	for (i = 0; i < length; i += 4) {
+		sec_ts_swap(&data[i], &data[i + 3]);
+		sec_ts_swap(&data[i + 1], &data[i + 2]);
+	}
+}
+
+static int execute_selftest(struct sec_ts_data *ts) {
+	int rc;
+	u8 tpara = 0x23;
+	u8 *rBuff;
+	int i;
+	int result = 0;
+	int result_size =
+			SEC_TS_SELFTEST_REPORT_SIZE + ts->tx_count * ts->rx_count * 2;
+
+	input_info(true, &ts->client->dev, "%s: Self test start!\n", __func__);
+	rc = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SELFTEST, &tpara, 1);
+	if (rc < 0) {
+		input_err(true, &ts->client->dev, "%s: Send selftest cmd failed!\n",
+							__func__);
+		goto err_exit;
+	}
+	sec_ts_delay(350);
+
+	rc = sec_ts_wait_for_ready(ts, SEC_TS_ACK_SELF_TEST_DONE);
+	if (rc < 0) {
+		input_err(true, &ts->client->dev, "%s: Selftest execution time out!\n",
+							__func__);
+		goto err_exit;
+	}
+
+	input_info(true, &ts->client->dev, "%s: Self test done!\n", __func__);
+
+	rBuff = kzalloc(result_size, GFP_KERNEL);
+	if (!rBuff) {
+		pr_err("%s: kzalloc %d bytes failed for rBuff\n", __func__, result_size);
+		goto err_exit;
+	}
+
+	rc = ts->sec_ts_i2c_read(ts, SEC_TS_READ_SELFTEST_RESULT, rBuff, result_size);
+	if (rc < 0) {
+		input_err(true, &ts->client->dev, "%s: Selftest execution time out!\n",
+							__func__);
+		goto err_exit;
+	}
+	rearrange_sft_result(rBuff, result_size);
+
+	for (i = 0; i < 80; i += 4) {
+		if (i % 8 == 0)
+			pr_cont("\n");
+		if (i % 4 == 0)
+			pr_cont("sec_ts : ");
+
+		if (i / 4 == 0)
+			pr_cont("SIG");
+		else if (i / 4 == 1)
+			pr_cont("VER");
+		else if (i / 4 == 2)
+			pr_cont("SIZ");
+		else if (i / 4 == 3)
+			pr_cont("CRC");
+		else if (i / 4 == 4)
+			pr_cont("RES");
+		else if (i / 4 == 5)
+			pr_cont("COU");
+		else if (i / 4 == 6)
+			pr_cont("PAS");
+		else if (i / 4 == 7)
+			pr_cont("FAI");
+		else if (i / 4 == 8)
+			pr_cont("CHA");
+		else if (i / 4 == 9)
+			pr_cont("AMB");
+		else if (i / 4 == 10)
+			pr_cont("RXS");
+		else if (i / 4 == 11)
+			pr_cont("TXS");
+		else if (i / 4 == 12)
+			pr_cont("RXO");
+		else if (i / 4 == 13)
+			pr_cont("TXO");
+		else if (i / 4 == 14)
+			pr_cont("RXG");
+		else if (i / 4 == 15)
+			pr_cont("TXG");
+		else if (i / 4 == 16)
+			pr_cont("RXR");
+		else if (i / 4 == 17)
+			pr_cont("TXT");
+		else if (i / 4 == 18)
+			pr_cont("RXT");
+		else if (i / 4 == 19)
+			pr_cont("TXR");
+
+		pr_cont(" %2X, %2X, %2X, %2X  ", rBuff[i], rBuff[i + 1], rBuff[i + 2],
+						rBuff[i + 3]);
+
+		if (i / 4 == 4) {
+			if ((rBuff[i + 3] & 0x30) != 0) /*RX, RX open check.*/
+				result = 0;
+			else
+				result = 1;
+		}
+	}
+
+	return result;
+err_exit:
+
+	return 0;
+}
+
+int sec_ts_execute_force_calibration(struct sec_ts_data *ts, int cal_mode) {
+	int rc = -1;
+	u8 cmd = 0;
+
+	if (cal_mode == OFFSET_CAL_SEC)
+		cmd = SEC_TS_CMD_CALIBRATION_OFFSET_SDC;
+	else if (cal_mode == AMBIENT_CAL)
+		cmd = SEC_TS_CMD_CALIBRATION_AMBIENT;
+
+	if (ts->sec_ts_i2c_write(ts, cmd, NULL, 0) < 0) {
+		input_err(true, &ts->client->dev, "%s: Write Cal commend failed!\n",
+							__func__);
+		return rc;
+	}
+
+	sec_ts_delay(1000);
+
+	rc = sec_ts_wait_for_ready(ts, SEC_TS_ACK_OFFSET_CAL_DONE);
+
+	ts->cal_status = sec_ts_read_calibration_report(ts);
+	return rc;
+}
+
+static void get_force_calibration(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[CMD_STR_LEN] = {0};
+	char cal_result[4] = {0};
+
+	set_default_result(ts);
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_info(true, &ts->client->dev, "%s: Touch is stopped!\n", __func__);
+		snprintf(buff, sizeof(buff), "%s", "TSP turned off");
+		set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+		ts->cmd_state = CMD_STATUS_NOT_APPLICABLE;
+		return;
+	}
+
+	cal_result[0] = sec_ts_read_calibration_report(ts);
+
+	if (cal_result[0] == SEC_TS_STATUS_CALIBRATION_SEC) {
+		snprintf(buff, sizeof(buff), "%s", "OK");
+		ts->cmd_state = CMD_STATUS_OK;
+	} else {
+		snprintf(buff, sizeof(buff), "%s", "NG");
+	}
+
+	input_info(true, &ts->client->dev, "%s: %d, %d\n", __func__, cal_result[0],
+						 (cal_result[0] == SEC_TS_STATUS_CALIBRATION_SEC));
+
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+
+static void run_force_calibration(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[CMD_STR_LEN] = {0};
+	int rc;
+
+	set_default_result(ts);
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_info(true, &ts->client->dev, "%s: Touch is stopped!\n", __func__);
+		snprintf(buff, sizeof(buff), "%s", "TSP turned off");
+		set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+		ts->cmd_state = CMD_STATUS_NOT_APPLICABLE;
+		return;
+	}
+
+	sec_ts_read_calibration_report(ts);
+
+	if (ts->touch_count > 0) {
+		snprintf(buff, sizeof(buff), "%s", "NG_FINGER_ON");
+		ts->cmd_state = CMD_STATUS_FAIL;
+		goto out_force_cal;
+	}
+
+	disable_irq(ts->client->irq);
+
+	rc = sec_ts_execute_force_calibration(ts, OFFSET_CAL_SEC);
+	if (rc < 0) {
+		snprintf(buff, sizeof(buff), "%s", "FAIL");
+		ts->cmd_state = CMD_STATUS_FAIL;
+	} else {
+#ifdef CALIBRATION_BY_FACTORY
+		buff[0] = get_tsp_nvm_data(ts, SEC_TS_NVM_OFFSET_FAC_RESULT);
+		buff[1] = get_tsp_nvm_data(ts, SEC_TS_NVM_OFFSET_CAL_COUNT);
+		if (buff[0] == 0 && buff[1] == 0)
+			set_tsp_nvm_data_clear(ts);
+		else if (buff[1] == 0xFF)
+			buff[1] = 0;
+
+		/* count the number of calibration */
+		if (buff[1] < 0xFE)
+			ts->cal_count = buff[1] + 1;
+
+		/* Use TSP NV area : in this model, use only one byte
+		 * buff[0] : offset from user NVM storage
+		 * buff[1] : length of stored data - 1 (ex. using 1byte, value is  1 - 1 =
+		 * 0)
+		 * buff[2] : write data
+		 */
+		buff[0] = SEC_TS_NVM_OFFSET_CAL_COUNT;
+		buff[1] = 0;
+		buff[2] = ts->cal_count;
+
+		input_info(true, &ts->client->dev, "%s: write to nvm %X\n", __func__,
+							 buff[2]);
+
+		rc = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_NVM, buff, 3);
+		if (rc < 0) {
+			input_err(true, &ts->client->dev, "%s nvm write failed. ret: %d\n",
+								__func__, rc);
+		}
+
+		sec_ts_delay(20);
+
+		ts->cal_count = get_tsp_nvm_data(ts, SEC_TS_NVM_OFFSET_CAL_COUNT);
+#endif
+		snprintf(buff, sizeof(buff), "%s", "OK");
+		ts->cmd_state = CMD_STATUS_OK;
+	}
+
+	enable_irq(ts->client->irq);
+
+out_force_cal:
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+
+	mutex_lock(&ts->cmd_lock);
+	ts->cmd_is_running = false;
+	mutex_unlock(&ts->cmd_lock);
+
+	input_info(true, &ts->client->dev, "%s: %s\n", __func__, buff);
+}
+static void set_log_level(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[CMD_STR_LEN] = {0};
+	char tBuff[2] = {0};
+	int ret;
+
+	set_default_result(ts);
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev, "%s: Touch is stopped!\n", __func__);
+		snprintf(buff, sizeof(buff), "%s", "TSP turned off");
+		set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+		ts->cmd_state = CMD_STATUS_FAIL;
+		return;
+	}
+
+	if ((ts->cmd_param[0] < 0 || ts->cmd_param[0] > 1) ||
+			(ts->cmd_param[1] < 0 || ts->cmd_param[1] > 1) ||
+			(ts->cmd_param[2] < 0 || ts->cmd_param[2] > 1) ||
+			(ts->cmd_param[3] < 0 || ts->cmd_param[3] > 1)) {
+		input_err(true, &ts->client->dev, "%s: para out of range\n", __func__);
+		snprintf(buff, sizeof(buff), "%s", "Para out of range");
+		set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+		ts->cmd_state = CMD_STATUS_FAIL;
+		return;
+	}
+
+	ret = ts->sec_ts_i2c_read(ts, SEC_TS_CMD_STATUS_EVENT_TYPE, tBuff, 2);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev,
+							"%s: Read Event type enable status fail\n", __func__);
+		snprintf(buff, sizeof(buff), "%s", "Read Stat Fail");
+		goto err;
+	}
+
+	input_info(true, &ts->client->dev,
+						 "%s: STATUS_EVENT enable = 0x%02X, 0x%02X\n", __func__, tBuff[0],
+						 tBuff[1]);
+
+	tBuff[0] = 0x0;
+	tBuff[1] = BIT_STATUS_EVENT_ACK(ts->cmd_param[0]) |
+						 BIT_STATUS_EVENT_ERR(ts->cmd_param[1]) |
+						 BIT_STATUS_EVENT_INFO(ts->cmd_param[2]) |
+						 BIT_STATUS_EVENT_GEST(ts->cmd_param[3]);
+
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_STATUS_EVENT_TYPE, tBuff, 2);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev,
+							"%s: Write Event type enable status fail\n", __func__);
+		snprintf(buff, sizeof(buff), "%s", "Write Stat Fail");
+		goto err;
+	}
+	input_info(true, &ts->client->dev,
+						 "%s: ACK : %d, ERR : %d, INFO : %d, GEST : %d\n", __func__,
+						 ts->cmd_param[0], ts->cmd_param[1], ts->cmd_param[2],
+						 ts->cmd_param[3]);
+
+	snprintf(buff, sizeof(buff), "%s", "OK");
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = CMD_STATUS_OK;
+	return;
+err:
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	ts->cmd_state = CMD_STATUS_NOT_APPLICABLE;
+}
+
+bool check_lowpower_flag(struct sec_ts_data *ts) {
+	bool ret = 0;
+	unsigned char flag = ts->lowpower_flag & 0xFF;
+
+	if (flag)
+		ret = 1;
+
+	input_info(true, &ts->client->dev, "%s: lowpower_mode flag : %d, ret:%d\n",
+						 __func__, flag, ret);
+
+	if (flag & SEC_TS_LOWP_FLAG_AOD)
+		input_info(true, &ts->client->dev, "%s: aod cmd on\n", __func__);
+	if (flag & SEC_TS_LOWP_FLAG_SPAY)
+		input_info(true, &ts->client->dev, "%s: spay cmd on\n", __func__);
+	if (flag & SEC_TS_LOWP_FLAG_SIDE_GESTURE)
+		input_info(true, &ts->client->dev, "%s: side cmd on\n", __func__);
+
+	return ret;
+}
+
+static void set_lowpower_mode(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+	char buff[CMD_STR_LEN] = {0};
+
+	set_default_result(ts);
+
+	if (ts->cmd_param[0] < 0 || ts->cmd_param[0] > 1) {
+		goto set_lowpower_fail;
+	} else {
+		if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+			input_err(true, &ts->client->dev, "%s: ERR, POWER OFF\n", __func__);
+			goto set_lowpower_fail;
+		}
+
+		ts->lowpower_mode = ts->cmd_param[0];
+	}
+
+	snprintf(buff, sizeof(buff), "%s", "OK");
+	ts->cmd_state = CMD_STATUS_OK;
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+	return;
+
+set_lowpower_fail:
+	snprintf(buff, sizeof(buff), "%s", "set_lowpower_fail");
+	ts->cmd_state = CMD_STATUS_FAIL;
+	set_cmd_result(ts, buff, strnlen(buff, sizeof(buff)));
+}
+
+static void not_support_cmd(void *device_data) {
+	struct sec_ts_data *ts = (struct sec_ts_data *)device_data;
+
+	set_default_result(ts);
+	snprintf(ts->cmd_buff, sizeof(ts->cmd_buff), "%s", tostring(NA));
+
+	set_cmd_result(ts, ts->cmd_buff, strlen(ts->cmd_buff));
+	ts->cmd_state = CMD_STATUS_NOT_APPLICABLE;
+
+	mutex_lock(&ts->cmd_lock);
+	ts->cmd_is_running = false;
+	mutex_unlock(&ts->cmd_lock);
+}
+
+int sec_ts_fn_init(struct sec_ts_data *ts) {
+	int retval;
+	unsigned short ii;
+
+	INIT_LIST_HEAD(&ts->cmd_list_head);
+
+	ts->cmd_buffer_size = 0;
+	for (ii = 0; ii < ARRAY_SIZE(ft_cmds); ii++) {
+		list_add_tail(&ft_cmds[ii].list, &ts->cmd_list_head);
+		if (ft_cmds[ii].cmd_name)
+			ts->cmd_buffer_size += strlen(ft_cmds[ii].cmd_name) + 1;
+	}
+
+	mutex_init(&ts->cmd_lock);
+	ts->cmd_is_running = false;
+
+	ts->fac_dev_ts = device_create(sec_class, NULL, 0, ts, "tsp");
+
+	retval = IS_ERR(ts->fac_dev_ts);
+	if (retval) {
+		input_err(true, &ts->client->dev,
+							"%s: Failed to create device for the sysfs\n", __func__);
+		retval = IS_ERR(ts->fac_dev_ts);
+		goto exit;
+	}
+
+	dev_set_drvdata(ts->fac_dev_ts, ts);
+
+	retval = sysfs_create_group(&ts->fac_dev_ts->kobj, &cmd_attr_group);
+	if (retval < 0) {
+		input_err(true, &ts->client->dev, "%s: Failed to create sysfs attributes\n",
+							__func__);
+		goto exit;
+	}
+
+	retval = sysfs_create_link(&ts->fac_dev_ts->kobj, &ts->input_dev->dev.kobj,
+														 "input");
+
+	if (retval < 0) {
+		input_err(true, &ts->client->dev, "%s: fail - sysfs_create_link\n",
+							__func__);
+		goto exit;
+	}
+	ts->reinit_done = true;
+
+	return 0;
+
+exit:
+	return retval;
+}
diff --git a/drivers/input/touchscreen/sec_ts/sec_ts_fw.c b/drivers/input/touchscreen/sec_ts/sec_ts_fw.c
new file mode 100644
index 000000000000..a5e78a3e0e3f
--- /dev/null
+++ b/drivers/input/touchscreen/sec_ts/sec_ts_fw.c
@@ -0,0 +1,824 @@
+/* drivers/input/touchscreen/sec_ts_fw.c
+ *
+ * Copyright (C) 2016 Samsung Electronics Co., Ltd.
+ * http://www.samsungsemi.com/
+ *
+ * Core file for Samsung TSC driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/time.h>
+
+#include <linux/uaccess.h>
+
+#include "sec_ts.h"
+
+#define SEC_TS_FW_BLK_SIZE 256
+/*for hardware info get tp fw version */
+extern unsigned int ctp_fw_version_1;
+extern unsigned int ctp_fw_version_2;
+
+#ifdef CONFIG_FW_UPDATE_ON_PROBE
+static u8 sec_ts_fw_data[] = {
+	#include "s6d6ft0_v1.10_20170918.i"
+};
+#else
+static u8 sec_ts_fw_data[8] = { 0 };
+#endif
+
+u8 *sec_get_fwdata(void) { return sec_ts_fw_data; }
+
+int sec_ts_sw_reset(struct sec_ts_data *ts) {
+	int ret;
+
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SW_RESET, NULL, 0);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: write fail, sw_reset\n", __func__);
+		return 0;
+	}
+
+	sec_ts_delay(500);
+	input_info(true, &ts->client->dev, "%s: sw_reset\n", __func__);
+
+	return 1;
+}
+
+int sec_ts_check_firmware_version(struct sec_ts_data *ts, const u8 *fw_info) {
+	struct fw_header *fw_hd;
+	u8 data[20] = {0};
+	u8 device_id[3] = {0};
+	u8 fw_ver[4];
+	int ret;
+	/*
+	 * sec_ts_check_firmware_version
+	 * return value = 2 : bootloader mode
+	 * return value = 1 : firmware download needed,
+	 * return value = 0 : skip firmware download
+	 */
+
+	fw_hd = (struct fw_header *)fw_info;
+
+	ret = ts->sec_ts_i2c_read(ts, SEC_TS_READ_DEVICE_ID, device_id, 3);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: failed to read device id(%d)\n",
+							__func__, ret);
+		return -1;
+	}
+
+	input_info(true, &ts->client->dev, "%s: %X, %X, %X\n", __func__, device_id[0],
+						 device_id[1], device_id[2]);
+
+	if (device_id[0] == SEC_TS_ID_ON_BOOT)
+		return 2;
+
+	ret = ts->sec_ts_i2c_read(ts, SEC_TS_READ_SUB_ID, data, 20);
+	if (ret < 0) {
+		input_info(true, &ts->client->dev, "%s: firmware version read error\n ",
+							 __func__);
+		return -1;
+	}
+	input_info(true, &ts->client->dev,
+						 "%s: [IC] Image version info : %x.%x.%x.%x // [BIN] %08X\n",
+						 __func__, data[9], data[10], data[11], data[12], fw_hd->version);
+
+	fw_ver[0] = data[9];
+	fw_ver[1] = data[10];
+	fw_ver[2] = data[11];
+	fw_ver[3] = data[12];
+
+	ts->plat_data->img_version_of_ic[0] = fw_ver[0];
+	ts->plat_data->img_version_of_ic[1] = fw_ver[1];
+	ts->plat_data->img_version_of_ic[2] = fw_ver[2];
+	ts->plat_data->img_version_of_ic[3] = fw_ver[3];
+
+#ifdef CONFIG_FW_UPDATE_ON_PROBE
+	ts->plat_data->img_version_of_bin[0] = (fw_hd->version && 0xFF);
+	ts->plat_data->img_version_of_bin[1] = (fw_hd->version >> 8 && 0xFF);
+	ts->plat_data->img_version_of_bin[2] = (fw_hd->version >> 16 && 0xFF);
+	ts->plat_data->img_version_of_bin[3] = (fw_hd->version >> 24 && 0xFF);
+
+	input_info(true, &ts->client->dev,
+						 "%s: [FW] IMG version : %x.%x. [IC] IMG version %x.%x.\n",
+						 __func__, (fw_hd->version >> 16) & 0xff,
+						 (fw_hd->version >> 24) & 0xff, fw_ver[2], fw_ver[3]);
+
+	if (((fw_hd->version) & 0xff) != fw_ver[0]) {
+		input_err(true, &ts->client->dev, "%s: f/w product 0 is not equal: %x\n ",
+							__func__, fw_ver[0]);
+		return -1;
+	}
+	if (((fw_hd->version >> 8) & 0xff) != fw_ver[1]) {
+		input_err(true, &ts->client->dev, "%s: f/w project 1 is not equal : %x\n ",
+							__func__, fw_ver[1]);
+		return -1;
+	}
+
+	if (((fw_hd->version >> 16) & 0xff) > fw_ver[2]) {
+		return 1;
+	} else if ((((fw_hd->version >> 16) & 0xff) == fw_ver[2]) &&
+						 (((fw_hd->version >> 24) & 0xff) > fw_ver[3])) {
+		return 1;
+	}
+#endif
+
+	return 0;
+}
+
+static u8 sec_ts_checksum(u8 *data, int offset, int size) {
+	int i;
+	u8 checksum = 0;
+
+	for (i = 0; i < size; i++)
+		checksum += data[i + offset];
+
+	return checksum;
+}
+
+/***********************/
+/** Ext-flash control **/
+/***********************/
+#define SEC_TS_CMD_CS_CONTROL				0x8B
+#define SEC_TS_CMD_SET_DATA_NUM			0xD1
+#define FLASH_CMD_RDSR							0x05
+#define FLASH_CMD_WREN							0x06
+#define FLASH_CMD_SE 								0x20
+#define FLASH_CMD_PP								0x02
+#define SEC_TS_CMD_FLASH_SEND_DATA	0xEB
+#define SEC_TS_CMD_FLASH_READ_DATA	0xEC
+
+#define CS_LOW	0
+#define CS_HIGH	1
+
+#define BYTE_PER_SECTOR				4096
+#define BYTE_PER_PAGE					256
+#define PAGE_DATA_HEADER_SIZE	4
+
+#define SEC_TS_FLASH_WIP_MASK	0x01
+#define SEC_TS_FLASH_SIZE_256	256
+
+#define BYTE_PER_SECTOR				4096
+#define BYTE_PER_PAGE					256
+#define PAGE_PER_SECTOR				16
+
+static int sec_ts_flash_set_datanum(struct sec_ts_data *ts, u16 num) {
+	u8 tData[2];
+	int ret;
+
+	tData[0] = (num >> 8) & 0xFF;
+	tData[1] = num & 0xFF;
+
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SET_DATA_NUM, tData, 2);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: Set datanum Fail %d\n", __func__,
+							num);
+
+	return ret;
+}
+
+static int sec_ts_flash_cs_control(struct sec_ts_data *ts, bool cs_level) {
+	u8 tData;
+	int ret;
+
+	tData = cs_level ? 1 : 0;
+
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_CS_CONTROL, &tData, 1);
+	if (ret < 0)
+		input_info(true, &ts->client->dev, "%s: %s control Fail!\n", __func__,
+							 cs_level ? "CS High" : "CS Low");
+	return ret;
+}
+
+static int sec_ts_wren(struct sec_ts_data *ts) {
+	u8 tData[2];
+	int ret;
+
+	sec_ts_flash_cs_control(ts, CS_LOW);
+
+	sec_ts_flash_set_datanum(ts, 6);
+
+	tData[0] = FLASH_CMD_WREN;
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_FLASH_SEND_DATA, &tData[0], 1);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: Send WREN fail!\n", __func__);
+
+	sec_ts_flash_cs_control(ts, CS_HIGH);
+
+	return ret;
+}
+
+static u8 sec_ts_rdsr(struct sec_ts_data *ts) {
+	u8 tData[2];
+
+	sec_ts_flash_cs_control(ts, CS_LOW);
+
+	sec_ts_flash_set_datanum(ts, 2);
+
+	tData[0] = FLASH_CMD_RDSR;
+	ts->sec_ts_i2c_write(ts, SEC_TS_CMD_FLASH_SEND_DATA, tData, 1);
+
+	sec_ts_flash_set_datanum(ts, 1);
+
+	ts->sec_ts_i2c_read(ts, SEC_TS_CMD_FLASH_READ_DATA, tData, 1);
+
+	sec_ts_flash_cs_control(ts, CS_HIGH);
+
+	return tData[0];
+}
+
+static bool IsFlashBusy(struct sec_ts_data *ts) {
+	u8 tBuf;
+
+	sec_ts_wren(ts);
+	tBuf = sec_ts_rdsr(ts);
+	if ((tBuf & SEC_TS_FLASH_WIP_MASK) == SEC_TS_FLASH_WIP_MASK)
+		return true;
+
+	return false;
+}
+
+static int sec_ts_wait_for_flash_busy(struct sec_ts_data *ts) {
+	int retry_cnt = 0;
+	int ret = 0;
+
+	while (IsFlashBusy(ts)) {
+		sec_ts_delay(10);
+
+		if (retry_cnt++ > SEC_TS_WAIT_RETRY_CNT) { /*RETRY_CNT = 100*/
+			input_err(true, &ts->client->dev, "%s: Retry Cnt over!\n", __func__);
+			ret = -1;
+		}
+	}
+
+	return ret;
+}
+
+static int sec_ts_cmd_flash_se(struct sec_ts_data *ts, u32 flash_addr) {
+	int ret;
+	u8 tBuf[5];
+
+	if (IsFlashBusy(ts))
+		return false;
+
+	sec_ts_wren(ts);
+
+	sec_ts_flash_cs_control(ts, CS_LOW);
+
+	sec_ts_flash_set_datanum(ts, 5);
+
+	tBuf[0] = SEC_TS_CMD_FLASH_SEND_DATA;
+	tBuf[1] = FLASH_CMD_SE;
+	tBuf[2] = (flash_addr >> 16) & 0xFF;
+	tBuf[3] = (flash_addr >> 8) & 0xFF;
+	tBuf[4] = (flash_addr >> 0) & 0xFF;
+	ret = ts->sec_ts_i2c_write_burst(ts, tBuf, 5);
+	sec_ts_flash_cs_control(ts, CS_HIGH);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: Send sector erase cmd fail!\n",
+							__func__);
+		return ret;
+	}
+
+	ret = sec_ts_wait_for_flash_busy(ts);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: Time out! - flash busy wait\n",
+							__func__);
+
+	return ret;
+}
+
+#ifdef CONFIG_CMD_PP
+bool sec_ts_cmd_pp(struct sec_ts_data *ts, int flash_address, u8 *source_data,
+									 int byte_length) {
+	int data_byte_total_length;
+	u8 *tCmd;
+	int ret, i;
+
+	if (IsFlashBusy(ts))
+		return false;
+
+	sec_ts_wren(ts);
+
+	data_byte_total_length = 1 + 3 + byte_length + 1;
+	tCmd = kzalloc(data_byte_total_length, GFP_KERNEL);
+
+	sec_ts_flash_cs_control(ts, CS_LOW);
+	sec_ts_flash_set_datanum(ts, 0x104);
+
+	tCmd[0] = SEC_TS_CMD_FLASH_SEND_DATA;
+	tCmd[1] = FLASH_CMD_PP;
+	tCmd[2] = (flash_address >> 16) & 0xFF;
+	tCmd[3] = (flash_address >> 8) & 0xFF;
+	tCmd[4] = (flash_address >> 0) & 0xFF;
+
+	for (i = 0; i < byte_length; i++)
+		tCmd[5 + i] = source_data[i];
+
+	ret = ts->sec_ts_i2c_write_burst(ts, tCmd, data_byte_total_length);
+	sec_ts_flash_cs_control(ts, CS_HIGH);
+
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: PP cmd fail!\n", __func__);
+		return false;
+	}
+	input_dbg(true, &ts->client->dev, "%s : addr = %X%X%X\n", __func__, tCmd[2],
+						tCmd[3], tCmd[4]);
+
+	kfree(tCmd);
+
+	while (IsFlashBusy(ts))
+		sec_ts_delay(10);
+
+	return true;
+}
+#endif
+
+static int sec_ts_FlashSectorErase(struct sec_ts_data *ts, u32 sector_idx) {
+	u32 addr;
+	int ret = 0;
+
+	addr = sector_idx * BYTE_PER_PAGE;
+
+	ret = sec_ts_cmd_flash_se(ts, addr);
+	if (ret < 0)
+		input_err(true, &ts->client->dev, "%s: Fail!\n", __func__);
+
+	return ret;
+}
+
+static bool sec_ts_flashpagewrite(struct sec_ts_data *ts, u32 page_idx,
+																	u8 *page_data) {
+#ifndef CONFIG_CMD_PP
+	int ret;
+	int i, j;
+	u8 *tCmd;
+	u8 copy_data[3 + SEC_TS_FLASH_SIZE_256];
+	int copy_left = SEC_TS_FLASH_SIZE_256 + 3;
+	int copy_size = 0;
+	int copy_max = SEC_TS_FLASH_SIZE_256 + 3;
+
+	copy_data[0] = (u8)((page_idx >> 8) & 0xFF);
+	copy_data[1] = (u8)((page_idx >> 0) & 0xFF);
+	for (i = 0; i < SEC_TS_FLASH_SIZE_256; i++)
+		copy_data[2 + i] = page_data[i];
+	copy_data[2 + SEC_TS_FLASH_SIZE_256] =
+			sec_ts_checksum(copy_data, 0, 2 + SEC_TS_FLASH_SIZE_256);
+
+	sec_ts_flash_cs_control(ts, CS_LOW);
+	while (copy_left > 0) {
+		int copy_cur = (copy_left > copy_max) ? copy_max : copy_left;
+		tCmd = (u8 *)kzalloc(copy_cur + 1, GFP_KERNEL);
+		if (copy_size == 0)
+			tCmd[0] = 0xD9;
+		else
+			tCmd[0] = 0xDA;
+
+		for (j = 0; j < copy_cur; j++)
+			tCmd[j + 1] = copy_data[copy_size + j];
+		ret = ts->sec_ts_i2c_write_burst(ts, tCmd, 1 + copy_cur);
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "%s i2c error =  %d\n", __func__,
+								copy_left);
+		copy_size += copy_cur;
+		copy_left -= copy_cur;
+		kfree(tCmd);
+	}
+	sec_ts_delay(5); // add for test
+	sec_ts_flash_cs_control(ts, CS_HIGH);
+
+	return ret;
+#else
+	int size;
+	int addr;
+
+	size = BYTE_PER_PAGE;
+	addr = page_idx * BYTE_PER_PAGE;
+
+	sec_ts_cmd_pp(ts, addr, page_data, size);
+
+	return true;
+#endif
+}
+
+static bool sec_ts_flashlimitread(struct sec_ts_data *ts, u32 mem_addr,
+																	u32 mem_size, u8 *mem_data) {
+	int ret = 0;
+	int copy_left = mem_size;
+	int copy_size = 0;
+	int copy_max = 32;
+	u32 copy_addr = mem_addr;
+	u8 tCmd[5];
+	u8 *copy_data = mem_data;
+
+	sec_ts_flash_cs_control(ts, CS_LOW);
+	while (copy_left > 0) {
+		int copy_cur = (copy_left > copy_max) ? copy_max : copy_left;
+
+		tCmd[0] = 0xD0;
+		tCmd[1] = (u8)((copy_addr >> 24) & 0xff);
+		tCmd[2] = (u8)((copy_addr >> 16) & 0xff);
+		tCmd[3] = (u8)((copy_addr >> 8) & 0xff);
+		tCmd[4] = (u8)((copy_addr >> 0) & 0xff);
+		ret = ts->sec_ts_i2c_write_burst(ts, tCmd, 5);
+		if (ret < 0) {
+			input_info(true, &ts->client->dev, "%s: D0 fail\n", __func__);
+			goto burst_err;
+		}
+
+		tCmd[0] = 0xD1;
+		tCmd[1] = (u8)((copy_cur >> 8) & 0xff);
+		tCmd[2] = (u8)((copy_cur >> 0) & 0xff);
+		ret = ts->sec_ts_i2c_write_burst(ts, tCmd, 3);
+		if (ret < 0) {
+			input_info(true, &ts->client->dev, "%s: D1 fail\n", __func__);
+			goto burst_err;
+		}
+
+		tCmd[0] = 0xDC;
+		ret = ts->sec_ts_i2c_read(ts, tCmd[0], &copy_data[copy_size], copy_cur);
+		if (ret < 0) {
+			input_info(true, &ts->client->dev, "%s: memroy read fail\n", __func__);
+			goto burst_err;
+		}
+
+		copy_addr += copy_cur;
+		copy_size += copy_cur;
+		copy_left -= copy_cur;
+	}
+
+	sec_ts_flash_cs_control(ts, CS_HIGH);
+
+burst_err:
+	return ret;
+}
+
+static int sec_ts_flashwrite(struct sec_ts_data *ts, u32 mem_addr, u8 *mem_data,
+														 u32 mem_size) {
+	int ret;
+	int page_idx;
+	int size_left;
+	int size_copy;
+	u32 flash_page_size;
+	u32 page_idx_start;
+	u32 page_idx_end;
+	u32 page_num;
+	u8 page_buf[SEC_TS_FLASH_SIZE_256];
+
+	if (mem_size == 0) {
+		input_err(true, &ts->client->dev,
+							"%s, mem_size 0\n", __func__);
+		return 0;
+	}
+
+	flash_page_size = SEC_TS_FLASH_SIZE_256;
+	page_idx_start = mem_addr / flash_page_size;
+	page_idx_end = (mem_addr + mem_size - 1) / flash_page_size;
+	page_num = page_idx_end - page_idx_start + 1;
+
+	for (page_idx = (int)((page_num - 1) / 16); page_idx >= 0; page_idx--) {
+		ret = sec_ts_FlashSectorErase(ts, (page_idx_start + page_idx * 16));
+		if (ret < 0) {
+			input_err(true, &ts->client->dev,
+								"%s: Sector erase fail! sector_idx = %08X\n", __func__,
+								page_idx_start + page_idx * 16);
+			return -EIO;
+		}
+	}
+	input_info(true, &ts->client->dev, "%s flash sector erase done\n", __func__);
+
+	sec_ts_delay(page_num + 10);
+
+	size_left = (int)mem_size;
+	size_copy = (int)(mem_size % flash_page_size);
+	if (size_copy == 0)
+		size_copy = (int)flash_page_size;
+
+	memset(page_buf, 0, SEC_TS_FLASH_SIZE_256);
+
+	for (page_idx = (int)page_num - 1; page_idx >= 0; page_idx--) {
+		memcpy(page_buf, mem_data + (page_idx * flash_page_size), size_copy);
+		ret = sec_ts_flashpagewrite(ts, (u32)(page_idx + page_idx_start), page_buf);
+		if (ret < 0) {
+			input_err(true, &ts->client->dev, "%s fw write failed, page_idx = %d\n",
+								__func__, page_idx);
+			goto err;
+		}
+
+		size_copy = (int)flash_page_size;
+		sec_ts_delay(5);
+	}
+	input_info(true, &ts->client->dev, "%s flash page write done\n", __func__);
+
+	return mem_size;
+err:
+	return -EIO;
+}
+
+static int __maybe_unused sec_ts_flashread(struct sec_ts_data *ts, u32 mem_addr, u8 *mem_data,
+						u32 mem_size) {
+	int ret;
+
+	if ((mem_size == 0) || (mem_size > 128000))
+		return 0;
+
+	ret = sec_ts_flashlimitread(ts, mem_addr, mem_size, mem_data);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s fw read failed\n", __func__);
+		goto err;
+	}
+	return mem_size;
+err:
+	return -EIO;
+}
+static int sec_ts_chunk_update(struct sec_ts_data *ts, u32 addr, u32 size,
+															 u8 *data) {
+	int __maybe_unused i;
+	int __maybe_unused ret;
+	u32 fw_size;
+	u32 write_size;
+	u8 *mem_data;
+	u8 __maybe_unused *mem_rb;
+
+	fw_size = size;
+
+	mem_data = kzalloc(fw_size, GFP_KERNEL);
+	if (!mem_data)
+		return -ENOMEM;
+
+	memcpy(mem_data, data, sizeof(u8) * fw_size);
+
+	write_size = sec_ts_flashwrite(ts, addr, mem_data, fw_size);
+	if (write_size != fw_size) {
+		input_err(true, &ts->client->dev, "%s fw write failed\n", __func__);
+		return -1;
+	}
+
+	input_info(true, &ts->client->dev, "%s flash write done\n", __func__);
+	kfree(mem_data);
+	sec_ts_delay(1000);
+
+	return 0;
+//verify_err:
+	input_info(true, &ts->client->dev, "%s flash verify failed\n", __func__);
+	kfree(mem_data);
+	return -ENOMEM;
+}
+
+static int sec_ts_firmware_update(struct sec_ts_data *ts, const u8 *data,
+																	size_t size) {
+	int i, ret;
+	u8 device_id[3];
+	u8 *fd = (u8 *)data;
+	u8 num_chunk;
+	struct fw_header *fw_hd;
+
+	fw_hd = (struct fw_header *)fd;
+
+	if (fw_hd->signature != SEC_TS_FW_HEADER_SIGN) {
+		input_err(true, &ts->client->dev, "%s: firmware header error = %08X\n",
+							__func__, fw_hd->signature);
+		return -1;
+	}
+
+	num_chunk = fw_hd->NumberOfChunk[0] && 0xFF;
+	input_info(true, &ts->client->dev, "%s: num_chunk : %d\n", __func__,
+						 num_chunk);
+	input_info(true, &ts->client->dev, "%s: 0x%08X, 0x%08X, 0x%zu, 0x%08X\n",
+						 __func__, fw_hd->signature, fw_hd->flag, size, fw_hd->setting);
+
+	for (i = 0; i < num_chunk; i++) {
+		ret = sec_ts_chunk_update(ts, 0, (u32)size, fd);
+		if (ret < 0) {
+			input_err(true, &ts->client->dev, "%s: firmware chunk write failed\n",
+								__func__);
+			return -1;
+		}
+	}
+
+	ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SW_RESET, NULL, 0);
+	sec_ts_delay(500);
+	sec_ts_wait_for_ready(ts, SEC_TS_ACK_BOOT_COMPLETE);
+
+	if (ts->sec_ts_i2c_read(ts, SEC_TS_READ_DEVICE_ID, device_id, 3) < 0) {
+		input_err(true, &ts->client->dev,
+							"%s: read fail, read_boot_status = 0x%x\n", __func__,
+							device_id[0]);
+		return -1;
+	}
+
+	if (device_id[0] != SEC_TS_ID_ON_FW) {
+		input_err(
+				true, &ts->client->dev,
+				"%s: fw update sequence done, BUT fw is not loaded (id[0] = 0x%x)\n",
+				__func__, device_id[0]);
+		return -1;
+	}
+
+	input_err(true, &ts->client->dev, "%s: fw update Success! id[0] = 0x%x\n",
+						__func__, device_id[0]);
+
+	return 0;
+}
+
+int sec_ts_firmware_update_on_probe(struct sec_ts_data *ts) {
+	const struct firmware *fw_entry;
+	char fw_path[SEC_TS_MAX_FW_PATH];
+	int result = -1;
+
+	disable_irq(ts->client->irq);
+
+	if (!ts->plat_data->firmware_name)
+		snprintf(fw_path, SEC_TS_MAX_FW_PATH, "%s", SEC_TS_DEFAULT_FW_NAME);
+	else
+		snprintf(fw_path, SEC_TS_MAX_FW_PATH, "%s", ts->plat_data->firmware_name);
+
+	input_info(true, &ts->client->dev, "%s: initial firmware update  %s\n",
+						 __func__, fw_path);
+
+	/* Loading Firmware */
+	if (request_firmware(&fw_entry, fw_path, &ts->client->dev) != 0) {
+		input_err(true, &ts->client->dev, "%s: firmware is not available\n",
+							__func__);
+		goto err_request_fw;
+	}
+	input_info(true, &ts->client->dev, "%s: request firmware done! size = %d\n",
+						 __func__, (int)fw_entry->size);
+
+	result = sec_ts_check_firmware_version(ts, fw_entry->data);
+	if (result <= 0)
+		goto err_request_fw;
+
+	if (sec_ts_firmware_update(ts, fw_entry->data, fw_entry->size) < 0)
+		result = -1;
+	else
+		result = 0;
+
+err_request_fw:
+	release_firmware(fw_entry);
+	enable_irq(ts->client->irq);
+	return result;
+}
+#ifdef CONFIG_FW_UPDATE_ON_PROBE
+int sec_ts_firmwarei_update_on_probe(struct sec_ts_data *ts) {
+	int ret;
+	int result = -1;
+	int fw_size;
+	int ctp_fw_version_1;
+	int ctp_fw_version_2;
+
+	input_info(true, &ts->client->dev,
+						 "%s: initial firmware update with i file\n", __func__);
+
+	fw_size = sizeof(sec_ts_fw_data);
+	/* Loading Firmware */
+	input_info(true, &ts->client->dev, "%s: request firmware done! size = %d\n",
+						 __func__, (int)fw_size);
+
+	result = sec_ts_check_firmware_version(ts, sec_ts_fw_data);
+	/*for hardware info get tp fw version */
+	ctp_fw_version_1 = ts->plat_data->img_version_of_ic[2];
+	ctp_fw_version_2 = ts->plat_data->img_version_of_ic[3];
+	if (!ts->force_fwup) {
+		if (result < 0)
+			goto err_request_fw;
+		else if (result == 0)
+			goto skip_request_fw;
+	}
+	if (sec_ts_firmware_update(ts, sec_ts_fw_data, fw_size) < 0) {
+		result = -1;
+		return result;
+	}
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_CALIBRATION_OFFSET_SDC, NULL, 0);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: calibration fail\n", __func__);
+		goto err_request_fw;
+	}
+	sec_ts_delay(1000);
+
+	ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SW_RESET, NULL, 0);
+	sec_ts_delay(500);
+	sec_ts_wait_for_ready(ts, SEC_TS_ACK_BOOT_COMPLETE);
+	if (result >= 1)
+		sec_ts_check_firmware_version(ts, sec_ts_fw_data);
+	ctp_fw_version_1 = ts->plat_data->img_version_of_bin[2];
+	ctp_fw_version_2 = ts->plat_data->img_version_of_bin[3];
+	// after update
+	return 0;
+
+err_request_fw:
+	return -1;
+skip_request_fw:
+	return result;
+}
+#endif
+
+static int sec_ts_load_fw_from_ums(struct sec_ts_data *ts) {
+	struct fw_header *fw_hd;
+	struct file *fp;
+//	mm_segment_t old_fs;
+	long fw_size, nread;
+	int error = 0;
+
+//	old_fs = get_fs();
+//	set_fs(KERNEL_DS);
+
+	fp = filp_open(SEC_TS_DEFAULT_UMS_FW, O_RDONLY, S_IRUSR);
+	if (IS_ERR(fp)) {
+		input_err(true, ts->dev, "%s: failed to open %s.\n", __func__,
+							SEC_TS_DEFAULT_UMS_FW);
+		error = -ENOENT;
+		goto open_err;
+	}
+
+	fw_size = fp->f_path.dentry->d_inode->i_size;
+
+	if (0 < fw_size) {
+		unsigned char *fw_data;
+
+		fw_data = kzalloc(fw_size, GFP_KERNEL);
+		nread = kernel_read(fp, (char __user *)fw_data, fw_size, &fp->f_pos);
+
+		input_info(true, ts->dev, "%s: start, file path %s, size %ld Bytes\n",
+							 __func__, SEC_TS_DEFAULT_UMS_FW, fw_size);
+
+		if (nread != fw_size) {
+			input_err(true, ts->dev,
+								"%s: failed to read firmware file, nread %ld Bytes\n", __func__,
+								nread);
+			error = -EIO;
+		} else {
+			fw_hd = (struct fw_header *)fw_data;
+
+			input_info(true, &ts->client->dev, "%s: IMG version %08X\n ", __func__,
+								 fw_hd->version);
+
+			if (ts->irq)
+				disable_irq(ts->irq);
+			if (sec_ts_firmware_update(ts, fw_data, fw_size) < 0)
+				goto done;
+			if (ts->irq)
+				enable_irq(ts->irq);
+		}
+
+		if (error < 0)
+			input_err(true, ts->dev, "%s: failed update firmware\n", __func__);
+
+	done:
+		kfree(fw_data);
+	}
+
+	filp_close(fp, NULL);
+
+open_err:
+//	set_fs(old_fs);
+	return error;
+}
+
+int sec_ts_firmware_update_on_hidden_menu(struct sec_ts_data *ts,
+																					int update_type) {
+	int ret = 0;
+
+	/* Factory cmd for firmware update
+	 * argument represent what is source of firmware like below.
+	 *
+	 * 0 : [BUILT_IN] Getting firmware which is for user.
+	 * 1 : [UMS] Getting firmware from sd card.
+	 * 2 : none
+	 * 3 : [FFU] Getting firmware from air.
+	 */
+
+	switch (update_type) {
+	case BUILT_IN:
+		ret = sec_ts_firmware_update_on_probe(ts);
+		break;
+	case UMS:
+		ret = sec_ts_load_fw_from_ums(ts);
+		break;
+	case FFU:
+		input_err(true, ts->dev, "%s: Not support yet\n", __func__);
+		break;
+	default:
+		input_err(true, ts->dev, "%s: Not support command[%d]\n", __func__,
+							update_type);
+		break;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(sec_ts_firmware_update_on_hidden_menu);
diff --git a/drivers/input/touchscreen/sec_ts/sec_ts_main.c b/drivers/input/touchscreen/sec_ts/sec_ts_main.c
new file mode 100644
index 000000000000..016d42112066
--- /dev/null
+++ b/drivers/input/touchscreen/sec_ts/sec_ts_main.c
@@ -0,0 +1,2236 @@
+/* drivers/input/touchscreen/sec_ts.c
+ *
+ * Copyright (C) 2016 Samsung Electronics Co., Ltd.
+ * http://www.samsungsemi.com/
+ *
+ * Core file for Samsung TSC driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+/*
+#include <linux/wakelock.h>
+*/
+#ifdef SAMSUNG_PROJECT
+#include <linux/sec_sysfs.h>
+#endif
+#include <linux/irq.h>
+#include <linux/of_gpio.h>
+#include <linux/time.h>
+#if defined(CONFIG_FB)
+#include <linux/fb.h>
+#include <linux/notifier.h>
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
+
+#include "sec_ts.h"
+#ifdef CONFIG_INPUT_PRESSURE
+#include "../../pressure/pressure_func.h"
+#endif
+
+//#define SEC_TS_WAKEUP_GESTURE
+struct sec_ts_data *tsp_data;
+
+#ifdef SEC_TS_WAKEUP_GESTURE
+static u32 keycode;
+extern unsigned int gesture_enable;
+void (*handle_sec)(u8) = 0;
+
+void sec_ts_gesture_state(u8 gesture_state) {
+	if (gesture_state != 0) {
+		gesture_enable = 1;
+		tsp_data->lowpower_status = TO_LOWPOWER_MODE;
+	} else {
+		gesture_enable = 0;
+		tsp_data->lowpower_status = TO_TOUCH_MODE;
+	}
+	printk("[sec_ts]gesture_enable is %d\n", gesture_enable);
+}
+
+const uint16_t wakeup_gesture_key[] = {
+		DOUBLE_TAP,			// GESTURE_DOUBLE_CLICK
+		UNICODE_E,			// GESTURE_WORD_e
+		UNICODE_O,			// GESTURE_WORD_O
+		UNICODE_W,			// GESTURE_WORD_W
+		UNICODE_M,			// GESTURE_WORD_M
+		UNICODE_V_DOWN, // GESTURE_WORD_V
+		UNICODE_S,			// GESTURE_WORD_S
+		UNICODE_Z,			// GESTURE_WORD_Z
+		UNICODE_C,			// GESTURE_WORD_C
+		SWIPE_Y_UP,			// GESTURE_SLIDE_UP
+		SWIPE_Y_DOWN,		// GESTURE_SLIDE_DOWN
+		SWIPE_X_RIGHT,	// GESTURE_SLIDE_RIGHT
+		SWIPE_X_LEFT,		// GESTURE_SLIDE_LEFT
+
+};
+
+#define GESTURE_DOUBLE_CLICK 0
+#define GESTURE_WORD_e 1
+#define GESTURE_WORD_O 2
+#define GESTURE_WORD_W 3
+#define GESTURE_WORD_M 4
+#define GESTURE_WORD_V 6
+#define GESTURE_WORD_S 7
+#define GESTURE_WORD_Z 8
+#define GESTURE_WORD_C 9
+#define GESTURE_SLIDE_UP 10
+#define GESTURE_SLIDE_DOWN 11
+#define GESTURE_SLIDE_RIGHT 12
+#define GESTURE_SLIDE_LEFT 13
+
+static struct wake_lock gesture_wakelock;
+#endif
+
+static struct device *sec_ts_dev;
+#if 0
+EXPORT_SYMBOL(sec_ts_dev);
+#endif
+#ifndef SAMSUNG_PROJECT
+struct class *sec_class;
+static int sec_class_create(void) {
+	sec_class = class_create(THIS_MODULE, "sec");
+	if (IS_ERR_OR_NULL(sec_class)) {
+		pr_err("%s:Failed to create class(sec) %ld\n", __func__,
+					 PTR_ERR(sec_class));
+		return PTR_ERR(sec_class);
+	}
+	return 0;
+}
+#endif
+
+int32_t __weak sec_ts_test_proc_init(struct sec_ts_data *ts) {
+	return 0;
+}
+
+struct sec_ts_fw_file {
+	u8 *data;
+	u32 pos;
+	size_t size;
+};
+
+struct sec_ts_event_status {
+	u8 tchsta : 3;
+	u8 ttype : 3;
+	u8 eid : 2;
+	u8 sid;
+	u8 buff2;
+	u8 buff3;
+	u8 buff4;
+	u8 buff5;
+	u8 buff6;
+	u8 buff7;
+} __packed;
+
+struct sec_ts_gesture_status {
+	u8 stype : 6;
+	u8 eid : 2;
+	u8 gesture;
+	u8 y_4_2 : 3;
+	u8 x : 5;
+	u8 h_4 : 1;
+	u8 w : 5;
+	u8 y_1_0 : 2;
+	u8 reserved : 4;
+	u8 h_3_0 : 4;
+} __packed;
+
+struct sec_ts_exp_fn {
+	int (*func_init)(void *device_data);
+	void (*func_remove)(void);
+};
+
+#if defined(CONFIG_FB)
+static int fb_notifier_callback(struct notifier_block *self,
+																unsigned long event, void *data);
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+static void sec_ts_early_suspend(struct early_suspend *h);
+static void sec_ts_late_resume(struct early_suspend *h);
+#endif
+
+static struct workqueue_struct *sec_fwu_wq;
+
+static int sec_ts_input_open(struct input_dev *dev);
+static void sec_ts_input_close(struct input_dev *dev);
+
+static void sec_ts_reset_work(struct work_struct *work);
+static void sec_ts_fwupdate_work(struct work_struct *work);
+
+static int sec_ts_stop_device(struct sec_ts_data *ts);
+static int sec_ts_start_device(struct sec_ts_data *ts);
+
+u8 lv1cmd;
+u8 *read_lv1_buff;
+static int lv1_readsize;
+static int lv1_readremain;
+static int lv1_readoffset;
+
+static ssize_t sec_ts_reg_store(struct device *dev,
+																struct device_attribute *attr, const char *buf,
+																size_t size);
+static ssize_t sec_ts_regreadsize_store(struct device *dev,
+																				struct device_attribute *attr,
+																				const char *buf, size_t size);
+static inline ssize_t sec_ts_store_error(struct device *dev,
+																				 struct device_attribute *attr,
+																				 const char *buf, size_t count);
+static ssize_t sec_ts_enter_recovery_store(struct device *dev,
+																					 struct device_attribute *attr,
+																					 const char *buf, size_t size);
+
+static ssize_t sec_ts_regread_show(struct device *dev,
+																	 struct device_attribute *attr, char *buf);
+static ssize_t sec_ts_gesture_status_show(struct device *dev,
+																					struct device_attribute *attr,
+																					char *buf);
+static inline ssize_t
+sec_ts_show_error(struct device *dev, struct device_attribute *attr, char *buf);
+
+static DEVICE_ATTR(sec_ts_reg, 0660, NULL, sec_ts_reg_store);
+static DEVICE_ATTR(sec_ts_regreadsize, 0660, NULL, sec_ts_regreadsize_store);
+static DEVICE_ATTR(sec_ts_enter_recovery, 0660, NULL,
+									 sec_ts_enter_recovery_store);
+static DEVICE_ATTR(sec_ts_regread, 0660, sec_ts_regread_show, NULL);
+static DEVICE_ATTR(sec_ts_gesture_status, 0660, sec_ts_gesture_status_show,
+									 NULL);
+
+static struct attribute *cmd_attributes[] = {
+		&dev_attr_sec_ts_reg.attr,
+		&dev_attr_sec_ts_regreadsize.attr,
+		&dev_attr_sec_ts_enter_recovery.attr,
+		&dev_attr_sec_ts_regread.attr,
+		&dev_attr_sec_ts_gesture_status.attr,
+		NULL,
+};
+
+static struct attribute_group cmd_attr_group = {
+		.attrs = cmd_attributes,
+};
+
+static inline ssize_t sec_ts_show_error(struct device *dev,
+																				struct device_attribute *attr,
+																				char *buf) {
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+
+	input_err(true, &ts->client->dev, "sec_ts :%s read only function, %s\n",
+						__func__, attr->attr.name);
+	return -EPERM;
+}
+
+static inline ssize_t sec_ts_store_error(struct device *dev,
+																				 struct device_attribute *attr,
+																				 const char *buf, size_t count) {
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+
+	input_err(true, &ts->client->dev, "sec_ts :%s write only function, %s\n",
+						__func__, attr->attr.name);
+	return -EPERM;
+}
+
+int sec_ts_i2c_write(struct sec_ts_data *ts, u8 reg, u8 *data, int len) {
+	u8 buf[I2C_WRITE_BUFFER_SIZE + 1];
+	int ret;
+	unsigned char retry;
+#ifdef POR_AFTER_I2C_RETRY
+	int retry_cnt = 0;
+#endif
+	struct i2c_msg msg;
+
+	// input_info(true, &ts->client->dev,"%s\n", __func__);
+
+	if (len > I2C_WRITE_BUFFER_SIZE) {
+		input_err(true, &ts->client->dev,
+							"sec_ts_i2c_write len is larger than buffer size\n");
+		return -1;
+	}
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev, "%s: fail to POWER_STATUS=OFF\n",
+							__func__);
+		goto err;
+	}
+
+	buf[0] = reg;
+	memcpy(buf + 1, data, len);
+
+	msg.addr = ts->client->addr;
+	msg.flags = 0;
+	msg.len = len + 1;
+	msg.buf = buf;
+
+#ifdef POR_AFTER_I2C_RETRY
+retry_fail:
+#endif
+	mutex_lock(&ts->i2c_mutex);
+	for (retry = 0; retry < SEC_TS_I2C_RETRY_CNT; retry++) {
+		ret = i2c_transfer(ts->client->adapter, &msg, 1);
+		if (ret == 1)
+			break;
+
+		if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+			input_err(true, &ts->client->dev,
+								"%s: fail to POWER_STATUS=OFF ret = %d\n", __func__, ret);
+			mutex_unlock(&ts->i2c_mutex);
+			goto err;
+		}
+		if (retry > 0)
+			sec_ts_delay(10);
+	}
+	mutex_unlock(&ts->i2c_mutex);
+	if (retry == SEC_TS_I2C_RETRY_CNT) {
+		input_err(true, &ts->client->dev, "%s: I2C write over retry limit\n",
+							__func__);
+#ifdef POR_AFTER_I2C_RETRY
+		schedule_delayed_work(&ts->reset_work,
+													msecs_to_jiffies(TOUCH_RESET_DWORK_TIME));
+
+		if (!retry_cnt++)
+			goto retry_fail;
+#endif
+		ret = -EIO;
+	}
+
+	if (ret == 1)
+		return 0;
+err:
+	return -EIO;
+}
+
+int sec_ts_i2c_read(struct sec_ts_data *ts, u8 reg, u8 *data, int len) {
+	u8 buf[4];
+	int ret;
+	unsigned char retry;
+#ifdef POR_AFTER_I2C_RETRY
+	int retry_cnt = 0;
+#endif
+	struct i2c_msg msg[2];
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev, "%s: fail to POWER_STATUS=OFF\n",
+							__func__);
+		return -EIO;
+	}
+
+	mutex_lock(&ts->i2c_mutex);
+
+	buf[0] = reg;
+	msg[0].addr = ts->client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf;
+
+#ifdef POR_AFTER_I2C_RETRY
+retry_fail_write:
+#endif
+
+	for (retry = 0; retry < SEC_TS_I2C_RETRY_CNT; retry++) {
+		ret = i2c_transfer(ts->client->adapter, msg, 1);
+		if (ret == 1)
+			break;
+
+		if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+			input_err(true, &ts->client->dev,
+								"%s: fail to POWER_STATUS=OFF ret = %d\n", __func__, ret);
+			mutex_unlock(&ts->i2c_mutex);
+			goto err;
+		}
+		if (retry > 0)
+			sec_ts_delay(10);
+	}
+
+	if (retry == SEC_TS_I2C_RETRY_CNT) {
+		input_err(true, &ts->client->dev, "%s: I2C write over retry limit\n",
+							__func__);
+#ifdef POR_AFTER_I2C_RETRY
+		schedule_delayed_work(&ts->reset_work,
+													msecs_to_jiffies(TOUCH_RESET_DWORK_TIME));
+
+		if (!retry_cnt++)
+			goto retry_fail_write;
+#endif
+	}
+
+	if (ret != 1) {
+		mutex_unlock(&ts->i2c_mutex);
+		goto err;
+	}
+	udelay(100);
+
+	msg[0].addr = ts->client->addr;
+	msg[0].flags = I2C_M_RD;
+	msg[0].len = len;
+	msg[0].buf = data;
+
+#ifdef POR_AFTER_I2C_RETRY
+	retry_cnt = 0;
+#endif
+
+	for (retry = 0; retry < SEC_TS_I2C_RETRY_CNT; retry++) {
+		ret = i2c_transfer(ts->client->adapter, msg, 1);
+		if (ret == 1)
+			break;
+
+		if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+			input_err(true, &ts->client->dev,
+								"%s: fail to POWER_STATUS=OFF ret = %d\n", __func__, ret);
+			mutex_unlock(&ts->i2c_mutex);
+			goto err;
+		}
+		if (retry > 0)
+			sec_ts_delay(10);
+	}
+
+	if (retry == SEC_TS_I2C_RETRY_CNT) {
+		input_err(true, &ts->client->dev, "%s: I2C read over retry limit\n",
+							__func__);
+#ifdef POR_AFTER_I2C_RETRY
+		schedule_delayed_work(&ts->reset_work,
+													msecs_to_jiffies(TOUCH_RESET_DWORK_TIME));
+
+		if (!retry_cnt++)
+			goto retry_fail_write;
+#endif
+		ret = -EIO;
+	}
+
+	mutex_unlock(&ts->i2c_mutex);
+	return ret;
+err:
+	return -EIO;
+}
+
+#if defined(CONFIG_SEC_DEBUG_TSP_LOG)
+struct delayed_work *p_ghost_check;
+
+static void sec_ts_check_rawdata(struct work_struct *work) {
+	struct sec_ts_data *ts =
+			container_of(work, struct sec_ts_data, ghost_check.work);
+
+	if (ts->tsp_dump_lock == 1) {
+		input_err(true, &ts->client->dev, "%s, ignored ## already checking..\n",
+							__func__);
+		return;
+	}
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev, "%s, ignored ## IC is power off\n",
+							__func__);
+		return;
+	}
+
+	ts->tsp_dump_lock = 1;
+	input_err(true, &ts->client->dev, "%s, start ##\n", __func__);
+	sec_ts_run_rawdata_all((void *)ts);
+	msleep(100);
+
+	input_err(true, &ts->client->dev, "%s, done ##\n", __func__);
+	ts->tsp_dump_lock = 0;
+}
+
+void tsp_dump_sec(void) {
+	pr_err("%s: sec_ts %s: start\n", SECLOG, __func__);
+
+	if (p_ghost_check == NULL) {
+		pr_err("sec_ts %s, ignored ## tsp probe fail!!\n", __func__);
+		return;
+	}
+	schedule_delayed_work(p_ghost_check, msecs_to_jiffies(100));
+}
+#else
+void tsp_dump_sec(void) { pr_err("sec_ts %s: not support\n", __func__); }
+#endif
+
+static int sec_ts_i2c_read_bulk(struct sec_ts_data *ts, u8 *data, int len) {
+	int ret;
+	unsigned char retry;
+	struct i2c_msg msg;
+#ifdef POR_AFTER_I2C_RETRY
+	int retry_cnt = 0;
+#endif
+
+	msg.addr = ts->client->addr;
+	msg.flags = I2C_M_RD;
+	msg.len = len;
+	msg.buf = data;
+
+	mutex_lock(&ts->i2c_mutex);
+
+#ifdef POR_AFTER_I2C_RETRY
+retry_fail:
+#endif
+	for (retry = 0; retry < SEC_TS_I2C_RETRY_CNT; retry++) {
+		ret = i2c_transfer(ts->client->adapter, &msg, 1);
+		if (ret == 1)
+			break;
+
+		if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+			input_err(true, &ts->client->dev,
+								"%s: fail to POWER_STATUS=OFF ret = %d\n", __func__, ret);
+			mutex_unlock(&ts->i2c_mutex);
+			goto err;
+		}
+	}
+
+	mutex_unlock(&ts->i2c_mutex);
+
+	if (retry == 10) {
+		input_err(true, &ts->client->dev, "%s: I2C read over retry limit\n",
+							__func__);
+#ifdef POR_AFTER_I2C_RETRY
+		schedule_delayed_work(&ts->reset_work,
+													msecs_to_jiffies(TOUCH_RESET_DWORK_TIME));
+
+		if (!retry_cnt++)
+			goto retry_fail;
+#endif
+		ret = -EIO;
+	}
+
+	if (ret == 1)
+		return 0;
+err:
+	return -EIO;
+}
+
+void sec_ts_delay(unsigned int ms) {
+	if (ms < 20)
+		usleep_range(ms * 1000, ms * 1000);
+	else
+		msleep(ms);
+}
+
+int sec_ts_wait_for_ready(struct sec_ts_data *ts, unsigned int ack) {
+	int rc = -1;
+	int retry = 0;
+	u8 tBuff[SEC_TS_Event_Buff_Size];
+
+	while (sec_ts_i2c_read(ts, SEC_TS_READ_ONE_EVENT, tBuff,
+												 SEC_TS_Event_Buff_Size) > 0) {
+		if (tBuff[0] == TYPE_STATUS_EVENT_ACK) {
+			if (tBuff[1] == ack) {
+				rc = 0;
+				break;
+			}
+		}
+
+		if (retry++ > SEC_TS_WAIT_RETRY_CNT) {
+			input_err(true, &ts->client->dev, "%s: Time Over\n", __func__);
+			break;
+		}
+		sec_ts_delay(20);
+	}
+
+	input_info(true, &ts->client->dev,
+						 "%s: %02X, %02X, %02X, %02X, %02X, %02X, %02X, %02X [%d]\n",
+						 __func__, tBuff[0], tBuff[1], tBuff[2], tBuff[3], tBuff[4],
+						 tBuff[5], tBuff[6], tBuff[7], retry);
+
+	return rc;
+}
+
+int sec_ts_read_calibration_report(struct sec_ts_data *ts) {
+	int ret;
+	u8 buf[5] = {0};
+
+	buf[0] = SEC_TS_READ_CALIBRATION_REPORT;
+
+	ret = sec_ts_i2c_read(ts, buf[0], &buf[1], 4);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: failed to read, %d\n", __func__,
+							ret);
+		return ret;
+	}
+
+	input_info(true, &ts->client->dev,
+						 "%s: count:%d, pass count:%d, fail count:%d, status:0x%X\n",
+						 __func__, buf[1], buf[2], buf[3], buf[4]);
+
+	return buf[4];
+}
+
+#ifdef SEC_TS_WAKEUP_GESTURE
+int sec_ts_wakeup_gesture_report(struct sec_ts_data *ts, uint8_t gesture_id) {
+	input_info(true, &ts->client->dev, "%s: gesture_id = %d\n", __func__,
+						 gesture_id);
+	if (gesture_enable == 1) {
+		switch (gesture_id) {
+		case GESTURE_DOUBLE_CLICK:
+			keycode = wakeup_gesture_key[0];
+			input_info(true, &ts->client->dev,
+								 "Gesture : Double Click, keycode=0x%x\n", keycode);
+			break;
+		case GESTURE_WORD_e:
+			keycode = wakeup_gesture_key[1];
+			input_info(true, &ts->client->dev, "Gesture : Word e, keycode=0x%x\n",
+								 keycode);
+			break;
+		case GESTURE_WORD_O:
+			keycode = wakeup_gesture_key[2];
+			input_info(true, &ts->client->dev, "Gesture : Word O, keycode=0x%x\n",
+								 keycode);
+			break;
+		case GESTURE_WORD_W:
+			keycode = wakeup_gesture_key[3];
+			input_info(true, &ts->client->dev, "Gesture : Word W, keycode=0x%x\n",
+								 keycode);
+			break;
+		case GESTURE_WORD_M:
+			keycode = wakeup_gesture_key[4];
+			input_info(true, &ts->client->dev, "Gesture : Word M, keycode=0x%x\n",
+								 keycode);
+			break;
+		case GESTURE_WORD_V:
+			keycode = wakeup_gesture_key[5];
+			input_info(true, &ts->client->dev, "Gesture : Word V, keycode=0x%x\n",
+								 keycode);
+			break;
+		case GESTURE_WORD_S:
+			keycode = wakeup_gesture_key[6];
+			input_info(true, &ts->client->dev, "Gesture : Word S, keycode=0x%x\n",
+								 keycode);
+			break;
+		case GESTURE_WORD_Z:
+			keycode = wakeup_gesture_key[7];
+			input_info(true, &ts->client->dev, "Gesture : Word Z, keycode=0x%x\n",
+								 keycode);
+			break;
+		case GESTURE_WORD_C:
+			keycode = wakeup_gesture_key[8];
+			input_info(true, &ts->client->dev, "Gesture : Word C, keycode=0x%x\n",
+								 keycode);
+			break;
+		case GESTURE_SLIDE_UP:
+			keycode = wakeup_gesture_key[9];
+			input_info(true, &ts->client->dev, "Gesture : Slide Up, keycode=0x%x\n",
+								 keycode);
+			break;
+		case GESTURE_SLIDE_DOWN:
+			input_info(true, &ts->client->dev, "Gesture : Slide Down, keycode=0x%x\n",
+								 keycode);
+			keycode = wakeup_gesture_key[10];
+			break;
+		case GESTURE_SLIDE_RIGHT:
+			keycode = wakeup_gesture_key[11];
+			input_info(true, &ts->client->dev,
+								 "Gesture : Slide Right, keycode=0x%x\n", keycode);
+			break;
+		case GESTURE_SLIDE_LEFT:
+			keycode = wakeup_gesture_key[12];
+			input_info(true, &ts->client->dev, "Gesture : Slide Left, keycode=0x%x\n",
+								 keycode);
+			break;
+		}
+	}
+	return keycode;
+}
+#endif
+
+#define MAX_EVENT_COUNT 128
+static void sec_ts_read_event(struct sec_ts_data *ts) {
+	int ret;
+	int is_event_remain;
+	int t_id;
+	int event_id;
+	int read_event_count;
+	u8 read_event_buff[SEC_TS_Event_Buff_Size];
+#ifdef SEC_TS_WAKEUP_GESTURE
+	u32 wakeup_code;
+	struct sec_ts_event_status *p_event_status;
+#endif
+	struct sec_ts_event_coordinate *p_event_coord;
+
+	struct sec_ts_coordinate coordinate;
+
+	is_event_remain = 0;
+	read_event_count = 0;
+	ret = t_id = event_id = 0;
+
+	memset(&coordinate, 0x00, sizeof(struct sec_ts_coordinate));
+
+	/* repeat READ_ONE_EVENT until buffer is empty(No event) */
+	do {
+		ret = sec_ts_i2c_read(ts, SEC_TS_READ_ONE_EVENT, read_event_buff,
+													SEC_TS_Event_Buff_Size);
+		if (ret < 0) {
+			ts->event_errcnt++;
+			if (ts->event_errcnt > 10) {
+				// disable_irq(ts->client->irq);
+				if (ts->probe_done && ts->fw_workdone)
+					sec_ts_release_all_finger(ts);
+			}
+			input_err(true, &ts->client->dev, "%s: i2c read one event failed\n",
+								__func__);
+			return;
+		}
+		ts->event_errcnt = 0;
+
+		read_event_count++;
+		if (read_event_count > MAX_EVENT_COUNT) {
+			input_err(true, &ts->client->dev, "%s : event buffer overflow\n",
+								__func__);
+
+			/* write clear event stack command when read_event_count > MAX_EVENT_COUNT
+			 */
+			ret = sec_ts_i2c_write(ts, SEC_TS_CMD_CLEAR_EVENT_STACK, NULL, 0);
+			if (ret < 0)
+				input_err(true, &ts->client->dev, "%s: i2c write clear event failed\n",
+									__func__);
+
+			return;
+		}
+
+		event_id = read_event_buff[0] >> 6;
+		switch (event_id) {
+		case SEC_TS_Status_Event:
+			if ((read_event_buff[0] == TYPE_STATUS_EVENT_ACK) &&
+					(read_event_buff[1] == SEC_TS_ACK_BOOT_COMPLETE)) {
+				if (ts->probe_done && ts->fw_workdone) {
+					sec_ts_release_all_finger(ts);
+				}
+
+				if (read_event_buff[2] == 0x20) { /* watchdog reset flag */
+					input_err(true, &ts->client->dev, "%s: watchdog reset\n", __func__);
+				}
+				input_err(true, &ts->client->dev, "%s: Ack&Boot Complete\n", __func__);
+			}
+
+			if (read_event_buff[0] > 0)
+				input_info(true, &ts->client->dev,
+									 "%s: STATUS %x %x %x %x %x %x %x %x\n", __func__,
+									 read_event_buff[0], read_event_buff[1], read_event_buff[2],
+									 read_event_buff[3], read_event_buff[4], read_event_buff[5],
+									 read_event_buff[6], read_event_buff[7]);
+
+			if ((read_event_buff[0] == TYPE_STATUS_EVENT_ERR) &&
+					(read_event_buff[1] == SEC_TS_ERR_ESD)) {
+				input_err(true, &ts->client->dev, "%s: ESD detected. run reset\n",
+									__func__);
+				schedule_work(&ts->reset_work.work);
+			}
+			coordinate.action = SEC_TS_Coordinate_Action_None;
+			is_event_remain = 0;
+			break;
+
+		case SEC_TS_Coordinate_Event:
+			p_event_coord = (struct sec_ts_event_coordinate *)read_event_buff;
+
+			t_id = (p_event_coord->tid - 1);
+
+			if (t_id < MAX_SUPPORT_TOUCH_COUNT) {
+				coordinate.id = t_id;
+				coordinate.action = p_event_coord->tchsta;
+				coordinate.x = (p_event_coord->x_11_4 << 4) | (p_event_coord->x_3_0);
+				coordinate.y = (p_event_coord->y_11_4 << 4) | (p_event_coord->y_3_0);
+				coordinate.touch_width = p_event_coord->z;
+				coordinate.ttype = p_event_coord->ttype & 0x7;
+				coordinate.major = p_event_coord->major;
+				coordinate.minor = p_event_coord->minor;
+				coordinate.mcount = ts->coord[t_id].mcount;
+				coordinate.palm = (coordinate.ttype == SEC_TS_TOUCHTYPE_PALM) ? 1 : 0;
+
+				if ((t_id == SEC_TS_EVENTID_HOVER) &&
+						(coordinate.ttype == SEC_TS_TOUCHTYPE_PROXIMITY) &&
+						(coordinate.action == SEC_TS_Coordinate_Action_Release)) {
+					input_mt_slot(ts->input_dev, 0);
+					input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+					input_dbg(true, &ts->client->dev,
+										"%s: Hover - Release - tid=%d, touch_count=%d\n", __func__,
+										t_id, ts->touch_count);
+				} else if ((t_id == SEC_TS_EVENTID_HOVER) &&
+									 (coordinate.ttype == SEC_TS_TOUCHTYPE_PROXIMITY)) {
+					input_mt_slot(ts->input_dev, 0);
+					input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, true);
+
+					input_report_key(ts->input_dev, BTN_TOUCH, false);
+					input_report_key(ts->input_dev, BTN_TOOL_FINGER, true);
+
+					input_report_abs(ts->input_dev, ABS_MT_POSITION_X, coordinate.x);
+					input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, coordinate.y);
+					input_report_abs(ts->input_dev, ABS_MT_DISTANCE,
+													 coordinate.touch_width);
+
+					if (coordinate.action == SEC_TS_Coordinate_Action_Press)
+						input_dbg(true, &ts->client->dev,
+											"%s: Hover - Press - tid=%d, touch_count=%d\n", __func__,
+											t_id, ts->touch_count);
+					else if (coordinate.action == SEC_TS_Coordinate_Action_Move)
+						input_dbg(true, &ts->client->dev,
+											"%s: Hover - Move - tid=%d, touch_count=%d\n", __func__,
+											t_id, ts->touch_count);
+				} else if (coordinate.ttype == SEC_TS_TOUCHTYPE_NORMAL ||
+									 coordinate.ttype == SEC_TS_TOUCHTYPE_PALM ||
+									 coordinate.ttype == SEC_TS_TOUCHTYPE_GLOVE) {
+					if (coordinate.action == SEC_TS_Coordinate_Action_Release) {
+						coordinate.touch_width = 0;
+						/*coordinate.action = SEC_TS_Coordinate_Action_None;*/
+						input_mt_slot(ts->input_dev, t_id);
+						input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
+
+						if (ts->touch_count > 0)
+							ts->touch_count--;
+						if (ts->touch_count == 0) {
+							input_report_key(ts->input_dev, BTN_TOUCH, 0);
+							input_report_key(ts->input_dev, BTN_TOOL_FINGER, 0);
+						}
+					} else if (coordinate.action == SEC_TS_Coordinate_Action_Press) {
+						ts->touch_count++;
+						input_mt_slot(ts->input_dev, t_id);
+						input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER,
+																			 1 + (coordinate.palm << 1));
+						input_report_key(ts->input_dev, BTN_TOUCH, 1);
+						input_report_key(ts->input_dev, BTN_TOOL_FINGER, 1);
+
+						input_report_abs(ts->input_dev, ABS_MT_POSITION_X, coordinate.x);
+						input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, coordinate.y);
+						input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR,
+														 coordinate.major);
+						input_report_abs(ts->input_dev, ABS_MT_TOUCH_MINOR,
+														 coordinate.minor);
+#ifdef SEC_TS_SUPPORT_SEC_SWIPE
+						input_report_abs(ts->input_dev, ABS_MT_PALM, coordinate.palm);
+#endif
+
+#ifdef CONFIG_SEC_FACTORY
+						input_report_abs(ts->input_dev, ABS_MT_PRESSURE,
+														 coordinate.touch_width);
+#endif
+					} else if (coordinate.action == SEC_TS_Coordinate_Action_Move) {
+#ifdef CONFIG_TOUCHSCREN_SEC_TS_GLOVEMODE
+						if ((coordinate.ttype == SEC_TS_TOUCHTYPE_GLOVE) &&
+								!ts->touchkey_glove_mode_status) {
+							ts->touchkey_glove_mode_status = true;
+							input_report_switch(ts->input_dev, SW_GLOVE, 1);
+						}
+#endif
+						input_mt_slot(ts->input_dev, t_id);
+						input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 1);
+						input_report_key(ts->input_dev, BTN_TOUCH, 1);
+						input_report_key(ts->input_dev, BTN_TOOL_FINGER, 1);
+
+						input_report_abs(ts->input_dev, ABS_MT_POSITION_X, coordinate.x);
+						input_report_abs(ts->input_dev, ABS_MT_POSITION_Y, coordinate.y);
+						input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR,
+														 coordinate.major);
+						input_report_abs(ts->input_dev, ABS_MT_TOUCH_MINOR,
+														 coordinate.minor);
+#ifdef SEC_TS_SUPPORT_SEC_SWIPE
+						input_report_abs(ts->input_dev, ABS_MT_PALM, coordinate.palm);
+#endif
+#ifdef CONFIG_SEC_FACTORY
+						input_report_abs(ts->input_dev, ABS_MT_PRESSURE,
+														 coordinate.touch_width);
+#endif
+						coordinate.mcount++;
+					}
+
+					memcpy(&ts->coord[t_id], &coordinate,
+								 sizeof(struct sec_ts_coordinate));
+				}
+			} else {
+				input_err(true, &ts->client->dev, "%s: tid(%d) is  out of range\n",
+									__func__, t_id);
+			}
+
+			is_event_remain = 1;
+			break;
+
+		case SEC_TS_Gesture_Event:
+#ifdef SEC_TS_WAKEUP_GESTURE
+			p_event_status = (struct sec_ts_event_status *)read_event_buff;
+
+			if ((p_event_status->eid == 0x02) && (p_event_status->tchsta == 0x01)) {
+				struct sec_ts_gesture_status *p_gesture_status =
+						(struct sec_ts_gesture_status *)read_event_buff;
+				wakeup_code =
+						sec_ts_wakeup_gesture_report(ts, p_gesture_status->gesture);
+				input_info(true, &ts->client->dev, "%s: GESTURE  wakeup_code=0x%x\n",
+									 __func__, wakeup_code);
+				mz_gesture_report(ts->input_dev, keycode);
+			}
+			is_event_remain = 1;
+			break;
+#endif
+		default:
+			input_err(true, &ts->client->dev,
+								"%s: unknown event  %x %x %x %x %x %x\n", __func__,
+								read_event_buff[0], read_event_buff[1], read_event_buff[2],
+								read_event_buff[3], read_event_buff[4], read_event_buff[5]);
+
+			is_event_remain = 0;
+			break;
+		}
+
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+		if (coordinate.action == SEC_TS_Coordinate_Action_Press)
+			input_dbg(
+					true, &ts->client->dev,
+					"%s: [P] tID:%d, x:%d, y:%d, major:%d, minor:%d, tc:%d palm:%d\n",
+					__func__, t_id, coordinate.x, coordinate.y, coordinate.major,
+					coordinate.minor, ts->touch_count, coordinate.palm);
+#else
+		if (coordinate.action == SEC_TS_Coordinate_Action_Press)
+			input_dbg(true, &ts->client->dev, "%s: [P] tID:%d, tc:%d\n", __func__,
+								t_id, ts->touch_count);
+#endif
+		else if (coordinate.action == SEC_TS_Coordinate_Action_Release) {
+#if !defined(CONFIG_SAMSUNG_PRODUCT_SHIP)
+			input_dbg(true, &ts->client->dev, "%s: [R] tID:%d mc:%d tc:%d lx:%d "
+																				 "ly:%d cal:0x%x(%X|%X), "
+																				 "[SE%02X%02X%02X]\n",
+								__func__, t_id, ts->coord[t_id].mcount, ts->touch_count,
+								ts->coord[t_id].x, ts->coord[t_id].y, ts->cal_status, ts->nv,
+								ts->cal_count, ts->plat_data->panel_revision,
+								ts->plat_data->img_version_of_ic[2],
+								ts->plat_data->img_version_of_ic[3]);
+#else
+			input_dbg(
+					true, &ts->client->dev,
+					"%s: [R] tID:%d mc:%d tc:%d cal:0x%x(%X|%X) [SE%02X%02X%02X]\n",
+					__func__, t_id, ts->coord[t_id].mcount, ts->touch_count,
+					ts->cal_status, ts->nv, ts->cal_count, ts->plat_data->panel_revision,
+					ts->plat_data->img_version_of_ic[2],
+					ts->plat_data->img_version_of_ic[3]);
+#endif
+			ts->coord[t_id].mcount = 0;
+		}
+	} while (is_event_remain);
+	input_sync(ts->input_dev);
+}
+
+static irqreturn_t sec_ts_irq_thread(int irq, void *ptr) {
+	struct sec_ts_data *ts;
+
+	ts = (struct sec_ts_data *)ptr;
+
+#ifdef SEC_TS_WAKEUP_GESTURE
+	if (ts->lowpower_mode)
+		wake_lock_timeout(&gesture_wakelock, msecs_to_jiffies(5000));
+#endif
+	sec_ts_read_event(ts);
+
+	return IRQ_HANDLED;
+}
+
+int get_tsp_status(void) { return 0; }
+EXPORT_SYMBOL(get_tsp_status);
+
+int sec_ts_glove_mode_enables(struct sec_ts_data *ts, int mode) {
+	int ret;
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev,
+							"%s: fail to enable glove status, POWER_STATUS=OFF\n", __func__);
+		goto glove_enable_err;
+	}
+
+	if (mode)
+		ts->touch_functions = (ts->touch_functions | SEC_TS_BIT_SETFUNC_GLOVE |
+													 SEC_TS_BIT_SETFUNC_MUTUAL);
+	else
+		ts->touch_functions = ((ts->touch_functions & (~SEC_TS_BIT_SETFUNC_GLOVE)) |
+													 SEC_TS_BIT_SETFUNC_MUTUAL);
+
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_TOUCHFUNCTION, &ts->touch_functions,
+												 1);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: Failed to send command", __func__);
+		goto glove_enable_err;
+	}
+
+	input_err(true, &ts->client->dev, "%s: %s, status =%x\n", __func__,
+						(mode) ? "glove enable" : "glove disable", ts->touch_functions);
+
+	return 0;
+
+glove_enable_err:
+	(mode)
+			? (ts->touch_functions = SEC_TS_BIT_SETFUNC_GLOVE) |
+						SEC_TS_BIT_SETFUNC_MUTUAL
+			: (ts->touch_functions =
+						 (ts->touch_functions & (~SEC_TS_BIT_SETFUNC_GLOVE)) |
+						 SEC_TS_BIT_SETFUNC_MUTUAL);
+	input_err(true, &ts->client->dev, "%s: %s, status =%x\n", __func__,
+						(mode) ? "glove enable" : "glove disable", ts->touch_functions);
+	return -EIO;
+}
+EXPORT_SYMBOL(sec_ts_glove_mode_enables);
+
+int sec_ts_hover_enables(struct sec_ts_data *ts, int enables) {
+	int ret;
+
+	if (enables)
+		ts->touch_functions = (ts->touch_functions | SEC_TS_BIT_SETFUNC_HOVER |
+													 SEC_TS_BIT_SETFUNC_MUTUAL);
+	else
+		ts->touch_functions = ((ts->touch_functions & (~SEC_TS_BIT_SETFUNC_HOVER)) |
+													 SEC_TS_BIT_SETFUNC_MUTUAL);
+
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_TOUCHFUNCTION, &ts->touch_functions,
+												 1);
+
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: Failed to send command", __func__);
+		goto hover_enable_err;
+	}
+
+	input_err(true, &ts->client->dev, "%s: %s, status =%x\n", __func__,
+						(enables) ? "hover enable" : "hover disable", ts->touch_functions);
+	return 0;
+hover_enable_err:
+	ts->touch_functions =
+			(enables) ? ((ts->touch_functions | SEC_TS_BIT_SETFUNC_HOVER) |
+									 SEC_TS_BIT_SETFUNC_MUTUAL)
+								: ((ts->touch_functions & (~SEC_TS_BIT_SETFUNC_HOVER)) |
+									 SEC_TS_BIT_SETFUNC_MUTUAL);
+	input_err(true, &ts->client->dev, "%s: %s, status =%x\n", __func__,
+						(enables) ? "hover enable" : "hover disable", ts->touch_functions);
+	return -EIO;
+}
+EXPORT_SYMBOL(sec_ts_hover_enables);
+
+int sec_ts_i2c_write_burst(struct sec_ts_data *ts, u8 *data, int len) {
+	int ret;
+	int retry;
+
+	mutex_lock(&ts->i2c_mutex);
+	for (retry = 0; retry < SEC_TS_I2C_RETRY_CNT; retry++) {
+		ret = i2c_master_send(ts->client, data, len);
+		if (ret == len) {
+			input_info(true, &ts->client->dev, "%s: i2c_master_send %d = %d\n",
+								 __func__, ret, len);
+			break;
+		}
+		if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+			input_err(true, &ts->client->dev,
+								"%s: fail to POWER_STATUS=OFF ret = %d\n", __func__, ret);
+			mutex_unlock(&ts->i2c_mutex);
+			goto err;
+		}
+		if (retry > 0)
+			sec_ts_delay(10);
+	}
+	mutex_unlock(&ts->i2c_mutex);
+	if (retry == 10) {
+		input_err(true, &ts->client->dev, "%s: I2C write over retry limit\n",
+							__func__);
+		ret = -EIO;
+	}
+
+	if (ret == len)
+		return 0;
+err:
+	return -EIO;
+}
+
+/* for
+ * debugging--------------------------------------------------------------------------------------*/
+static ssize_t sec_ts_reg_store(struct device *dev,
+																struct device_attribute *attr, const char *buf,
+																size_t size) {
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+	int length;
+	int remain;
+	int offset;
+	int ret;
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_info(true, &ts->client->dev, "%s: Power off state\n", __func__);
+		return -EIO;
+	}
+
+	mutex_lock(&ts->device_mutex);
+	disable_irq(ts->client->irq);
+	if (size > 0) {
+		remain = size;
+		offset = 0;
+		do {
+			if (remain >= ts->i2c_burstmax)
+				length = ts->i2c_burstmax;
+			else
+				length = remain;
+			ret = sec_ts_i2c_write_burst(ts, (u8 *)&buf[offset], length);
+			if (ret < 0) {
+				input_err(true, &ts->client->dev,
+									"%s: i2c write %x command, remain = %d\n", __func__,
+									buf[offset], remain);
+				goto i2c_err;
+			}
+
+			remain -= length;
+			offset += length;
+		} while (remain > 0);
+	}
+
+i2c_err:
+	enable_irq(ts->client->irq);
+	input_info(true, &ts->client->dev, "%s: 0x%x, 0x%x, size %d\n", __func__,
+						 buf[0], buf[1], (int)size);
+	mutex_unlock(&ts->device_mutex);
+
+	return size;
+}
+
+static ssize_t sec_ts_regread_show(struct device *dev,
+																	 struct device_attribute *attr, char *buf) {
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+	int ret;
+	int length;
+	int remain;
+	int offset;
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_info(true, &ts->client->dev, "%s: Power off state\n", __func__);
+		return -EIO;
+	}
+
+	disable_irq(ts->client->irq);
+
+	read_lv1_buff = kcalloc(lv1_readsize, sizeof(u8), GFP_KERNEL);
+	if (!read_lv1_buff)
+		goto malloc_err;
+
+	mutex_lock(&ts->device_mutex);
+	remain = lv1_readsize;
+	offset = 0;
+	do {
+		if (remain >= ts->i2c_burstmax)
+			length = ts->i2c_burstmax;
+		else
+			length = remain;
+
+		if (offset == 0)
+			ret = sec_ts_i2c_read(ts, lv1cmd, &read_lv1_buff[offset], length);
+		else
+			ret = sec_ts_i2c_read_bulk(ts, &read_lv1_buff[offset], length);
+
+		if (ret < 0) {
+			input_err(true, &ts->client->dev, "%s: i2c read %x command, remain =%d\n",
+								__func__, lv1cmd, remain);
+			goto i2c_err;
+		}
+
+		remain -= length;
+		offset += length;
+	} while (remain > 0);
+
+	input_info(true, &ts->client->dev, "%s: lv1_readsize = %d\n", __func__,
+						 lv1_readsize);
+	memcpy(buf, read_lv1_buff + lv1_readoffset, lv1_readsize);
+
+i2c_err:
+	kfree(read_lv1_buff);
+malloc_err:
+	mutex_unlock(&ts->device_mutex);
+	lv1_readremain = 0;
+	enable_irq(ts->client->irq);
+
+	return lv1_readsize;
+}
+
+static ssize_t sec_ts_gesture_status_show(struct device *dev,
+																					struct device_attribute *attr,
+																					char *buf) {
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+
+	mutex_lock(&ts->device_mutex);
+	memcpy(buf, ts->gesture_status, sizeof(ts->gesture_status));
+	input_info(true, &ts->client->dev, "%s: GESTURE STATUS %x %x %x %x %x %x\n",
+						 __func__, ts->gesture_status[0], ts->gesture_status[1],
+						 ts->gesture_status[2], ts->gesture_status[3],
+						 ts->gesture_status[4], ts->gesture_status[5]);
+	mutex_unlock(&ts->device_mutex);
+
+	return sizeof(ts->gesture_status);
+}
+
+static ssize_t sec_ts_regreadsize_store(struct device *dev,
+																				struct device_attribute *attr,
+																				const char *buf, size_t size) {
+	lv1cmd = buf[0];
+	lv1_readsize = ((unsigned int)buf[4] << 24) | ((unsigned int)buf[3] << 16) |
+								 ((unsigned int)buf[2] << 8) | ((unsigned int)buf[1] << 0);
+	lv1_readoffset = 0;
+	lv1_readremain = 0;
+	return size;
+}
+
+static ssize_t sec_ts_enter_recovery_store(struct device *dev,
+																					 struct device_attribute *attr,
+																					 const char *buf, size_t size) {
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+	struct sec_ts_plat_data *pdata = dev->platform_data;
+	int ret;
+	u8 on = (u8)buf[0];
+
+	if (on == 1) {
+		disable_irq(ts->client->irq);
+		gpio_free(pdata->gpio);
+
+		input_info(true, &ts->client->dev, "%s: gpio free\n", __func__);
+		if (gpio_is_valid(pdata->gpio)) {
+			ret = gpio_request_one(pdata->gpio, GPIOF_OUT_INIT_LOW, "sec,tsp_int");
+			input_info(true, &ts->client->dev, "%s: gpio request one\n", __func__);
+			if (ret) {
+				input_err(true, &ts->client->dev, "Unable to request tsp_int [%d]\n",
+									pdata->gpio);
+				return -EINVAL;
+			}
+		} else {
+			input_err(true, &ts->client->dev, "Failed to get irq gpio\n");
+			return -EINVAL;
+		}
+
+		pdata->power(ts, false);
+		sec_ts_delay(100);
+		pdata->power(ts, true);
+	} else {
+		gpio_free(pdata->gpio);
+
+		if (gpio_is_valid(pdata->gpio)) {
+			ret = gpio_request_one(pdata->gpio, GPIOF_DIR_IN, "sec,tsp_int");
+			if (ret) {
+				input_err(true, &ts->client->dev, "Unable to request tsp_int [%d]\n",
+									pdata->gpio);
+				return -EINVAL;
+			}
+		} else {
+			input_err(true, &ts->client->dev, "Failed to get irq gpio\n");
+			return -EINVAL;
+		}
+
+		pdata->power(ts, false);
+		sec_ts_delay(500);
+		pdata->power(ts, true);
+		sec_ts_delay(500);
+
+		/* AFE Calibration */
+		ret = sec_ts_i2c_write(ts, SEC_TS_CMD_CALIBRATION_AMBIENT, NULL, 0);
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "%s: fail to write AFE_CAL\n",
+								__func__);
+
+		sec_ts_delay(1000);
+		enable_irq(ts->client->irq);
+	}
+
+	return size;
+}
+
+#ifdef SEC_TS_SUPPORT_TA_MODE
+static void sec_ts_charger_config(struct sec_ts_data *ts, int status) {
+	int ret;
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev,
+							"%s: fail to enalbe charger status, POWER_STATUS=OFF\n",
+							__func__);
+		goto charger_config_err;
+	}
+
+	if (status == 0x01 || status == 0x03)
+		ts->touch_functions = ts->touch_functions | SEC_TS_BIT_SETFUNC_CHARGER |
+													SEC_TS_BIT_SETFUNC_MUTUAL;
+	else
+		ts->touch_functions =
+				((ts->touch_functions & (~SEC_TS_BIT_SETFUNC_CHARGER)) |
+				 SEC_TS_BIT_SETFUNC_MUTUAL);
+
+	ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_TOUCHFUNCTION, &ts->touch_functions,
+												 1);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: Failed to send command\n", __func__);
+		goto charger_config_err;
+	}
+
+	input_err(true, &ts->client->dev, "%s: charger inform : read status = %x\n",
+						__func__, ts->touch_functions);
+	return;
+
+charger_config_err:
+	if (status == 0x01 || status == 0x03)
+		ts->touch_functions = ts->touch_functions | SEC_TS_BIT_SETFUNC_CHARGER |
+													SEC_TS_BIT_SETFUNC_MUTUAL;
+	else
+		ts->touch_functions =
+				((ts->touch_functions & (~SEC_TS_BIT_SETFUNC_CHARGER)) |
+				 SEC_TS_BIT_SETFUNC_MUTUAL);
+	input_err(true, &ts->client->dev,
+						"%s: charger inform : touch function status = %x\n", __func__,
+						ts->touch_functions);
+}
+
+static void sec_ts_ta_cb(struct sec_ts_callbacks *cb, int status) {
+	struct sec_ts_data *ts = container_of(cb, struct sec_ts_data, callbacks);
+	input_err(true, &ts->client->dev, "[TSP] %s: status : %x\n", __func__,
+						status);
+
+	ts->ta_status = status;
+
+	sec_ts_charger_config(ts, status);
+}
+#endif
+static void sec_ts_raw_device_init(struct sec_ts_data *ts) {
+	int ret;
+
+	sec_ts_dev = device_create(sec_class, NULL, 0, ts, "sec_ts");
+
+	ret = IS_ERR(sec_ts_dev);
+	if (ret) {
+		input_err(true, &ts->client->dev, "%s: fail - device_create\n", __func__);
+		return;
+	}
+
+	ret = sysfs_create_group(&sec_ts_dev->kobj, &cmd_attr_group);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: fail - sysfs_create_group\n",
+							__func__);
+		goto err_sysfs;
+	}
+	return;
+
+err_sysfs:
+	input_err(true, &ts->client->dev, "%s: fail\n", __func__);
+}
+
+/* for
+ * debugging--------------------------------------------------------------------------------------*/
+static int sec_ts_power(void *data, bool on) {
+	int ret = 0;
+	return ret;
+}
+
+static int sec_ts_parse_dt(struct i2c_client *client) {
+	struct device *dev = &client->dev;
+	struct sec_ts_plat_data *pdata = dev->platform_data;
+	struct device_node *np = dev->of_node;
+
+	u32 coords[2], lines[2];
+	int ret = 0;
+	pdata->power = sec_ts_power;
+
+	pdata->gpio = of_get_named_gpio(np, "sec,irq_gpio", 0);
+	if (gpio_is_valid(pdata->gpio)) {
+		ret = gpio_request_one(pdata->gpio, GPIOF_DIR_IN, "sec,tsp_int");
+		if (ret) {
+			input_err(true, &client->dev, "Unable to request tsp_int [%d]\n",
+								pdata->gpio);
+			return -EINVAL;
+		}
+	} else {
+		input_err(true, &client->dev, "Failed to get irq gpio\n");
+		return -EINVAL;
+	}
+	client->irq = gpio_to_irq(pdata->gpio);
+
+	pdata->irq_type = IRQF_TRIGGER_LOW | IRQF_ONESHOT;
+	if (of_property_read_u32_array(np, "sec,max_coords", coords, 2)) {
+		input_err(true, &client->dev, "Failed to get max_coords property\n");
+		return -EINVAL;
+	}
+	pdata->max_x = coords[0];
+	pdata->max_y = coords[1];
+
+	if (of_property_read_u32_array(np, "sec,num_lines", lines, 2))
+		input_info(true, &client->dev, "skipped to get num_lines property\n");
+	else {
+		pdata->num_rx = lines[0];
+		pdata->num_tx = lines[1];
+		input_info(true, &client->dev, "num_of[rx,tx]: [%d,%d]\n", pdata->num_rx,
+							 pdata->num_tx);
+	}
+
+	if (of_property_read_string_index(np, "sec,project_name", 0,
+																		&pdata->project_name))
+		input_info(true, &client->dev, "skipped to get project_name property\n");
+	if (of_property_read_string_index(np, "sec,project_name", 1,
+																		&pdata->model_name))
+		input_info(true, &client->dev, "skipped to get model_name property\n");
+
+	pdata->i2c_burstmax = SEC_TS_FW_MAX_BURSTSIZE;
+
+	input_info(true, &client->dev, "irq:%d,irq_type:0x%04x,max[x,y]:[%d,%d],"
+																 "project/model_name:%s/%s,panel_revision:%d\n",
+						 pdata->gpio, pdata->irq_type, pdata->max_x, pdata->max_y,
+						 pdata->project_name, pdata->model_name, pdata->panel_revision);
+
+	return ret;
+}
+
+static int sec_ts_setup_drv_data(struct i2c_client *client) {
+	int ret = 0;
+	struct sec_ts_data *ts;
+	struct sec_ts_plat_data *pdata;
+
+	/* parse dt */
+	if (client->dev.of_node) {
+		pdata =
+				devm_kzalloc(&client->dev, sizeof(struct sec_ts_plat_data), GFP_KERNEL);
+
+		if (!pdata) {
+			input_err(true, &client->dev, "Failed to allocate platform data\n");
+			return -ENOMEM;
+		}
+
+		client->dev.platform_data = pdata;
+		ret = sec_ts_parse_dt(client);
+		if (ret) {
+			input_err(true, &client->dev, "Failed to parse dt\n");
+			return ret;
+		}
+	} else
+		pdata = client->dev.platform_data;
+
+	if (!pdata) {
+		input_err(true, &client->dev, "No platform data found\n");
+		return -EINVAL;
+	}
+	if (!pdata->power) {
+		input_err(true, &client->dev, "No power contorl found\n");
+		return -EINVAL;
+	}
+
+	pdata->pinctrl = devm_pinctrl_get(&client->dev);
+	if (IS_ERR(pdata->pinctrl)) {
+		input_err(true, &client->dev, "could not get pinctrl\n");
+		return PTR_ERR(pdata->pinctrl);
+	}
+
+	pdata->pins_default = pinctrl_lookup_state(pdata->pinctrl, "on_state");
+	if (IS_ERR(pdata->pins_default))
+		input_err(true, &client->dev, "could not get default pinstate\n");
+
+	pdata->pins_sleep = pinctrl_lookup_state(pdata->pinctrl, "off_state");
+	if (IS_ERR(pdata->pins_sleep))
+		input_err(true, &client->dev, "could not get sleep pinstate\n");
+
+	ts = kzalloc(sizeof(struct sec_ts_data), GFP_KERNEL);
+	if (!ts)
+		return -ENOMEM;
+
+	ts->client = client;
+	ts->plat_data = pdata;
+	ts->crc_addr = 0x0001FE00;
+	ts->fw_addr = 0x00002000;
+	ts->para_addr = 0x18000;
+	ts->sec_ts_i2c_read = sec_ts_i2c_read;
+	ts->sec_ts_i2c_write = sec_ts_i2c_write;
+	ts->sec_ts_i2c_read_bulk = sec_ts_i2c_read_bulk;
+	ts->sec_ts_i2c_write_burst = sec_ts_i2c_write_burst;
+	ts->i2c_burstmax = pdata->i2c_burstmax;
+	ts->fw_workdone = false;
+	ts->force_fwup = false;
+
+	INIT_DELAYED_WORK(&ts->reset_work, sec_ts_reset_work);
+
+	i2c_set_clientdata(client, ts);
+
+	return ret;
+}
+
+static int sec_ts_read_information(struct sec_ts_data *ts) {
+	unsigned char data[20] = {0};
+	unsigned char device_id[3] = {0};
+	int ret;
+
+	memset(data, 0x0, 3);
+	ret = sec_ts_i2c_read(ts, SEC_TS_READ_DEVICE_ID, device_id, 3);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: failed to read device id(%d)\n",
+							__func__, ret);
+		return ret;
+	}
+
+	input_info(true, &ts->client->dev, "%s: %X, %X, %X\n", __func__, device_id[0],
+						 device_id[1], device_id[2]);
+
+	memset(data, 0x0, 20);
+	ret = sec_ts_i2c_read(ts, SEC_TS_READ_SUB_ID, data, 20);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: failed to read sub id(%d)\n",
+							__func__, ret);
+		return ret;
+	}
+
+	input_info(true, &ts->client->dev,
+						 "%s: AP/BL(%X), DEV1:%X, DEV2:%X, nT:%X, nR:%X, rY:%d, rX:%d\n",
+						 __func__, data[0], data[1], data[2], data[3], data[4],
+						 (data[5] << 8) | data[6], (data[7] << 8) | data[8]);
+
+	data[0] = sec_ts_read_calibration_report(ts);
+	input_err(true, &ts->client->dev, "%s: cal info (%d)\n", __func__, data[0]);
+
+	data[0] = 0;
+	ret = sec_ts_i2c_read(ts, SEC_TS_READ_BOOT_STATUS, data, 1);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: failed to read sub id(%d)\n",
+							__func__, ret);
+		return ret;
+	}
+
+	input_info(true, &ts->client->dev, "%s: %X\n", __func__, data[0]);
+
+	if (device_id[0] == SEC_TS_ID_ON_FW)
+		ret = 1;
+	else {
+		input_err(true, &ts->client->dev, "%s: device id = %X\n", __func__,
+							device_id[0]);
+		ret = 0;
+	}
+
+	return ret;
+}
+
+int sec_ts_i2c_probe_read(struct sec_ts_data *ts, u8 reg, u8 *data, int len) {
+	u8 buf[4];
+	int ret;
+	unsigned char retry;
+#ifdef POR_AFTER_I2C_RETRY
+	int retry_cnt = 0;
+#endif
+	struct i2c_msg msg[2];
+
+	input_info(true, &ts->client->dev, "%s\n", __func__);
+
+	mutex_lock(&ts->i2c_mutex);
+
+	buf[0] = reg;
+	msg[0].addr = ts->client->addr;
+	msg[0].flags = 0;
+	msg[0].len = 1;
+	msg[0].buf = buf;
+
+#ifdef POR_AFTER_I2C_RETRY
+retry_fail_write:
+#endif
+
+	for (retry = 0; retry < SEC_TS_I2C_RETRY_CNT; retry++) {
+		ret = i2c_transfer(ts->client->adapter, msg, 1);
+		if (ret == 1)
+			break;
+
+		if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+			input_err(true, &ts->client->dev,
+								"%s: fail to POWER_STATUS=OFF ret = %d\n", __func__, ret);
+			mutex_unlock(&ts->i2c_mutex);
+			goto err;
+		}
+		if (retry > 0)
+			sec_ts_delay(10);
+	}
+
+	if (retry == SEC_TS_I2C_RETRY_CNT) {
+		input_err(true, &ts->client->dev, "%s: I2C write over retry limit\n",
+							__func__);
+#ifdef POR_AFTER_I2C_RETRY
+		schedule_delayed_work(&ts->reset_work,
+													msecs_to_jiffies(TOUCH_RESET_DWORK_TIME));
+
+		if (!retry_cnt++)
+			goto retry_fail_write;
+#endif
+	}
+
+	if (ret != 1) {
+		mutex_unlock(&ts->i2c_mutex);
+		goto err;
+	}
+	udelay(100);
+
+	msg[0].addr = ts->client->addr;
+	msg[0].flags = I2C_M_RD;
+	msg[0].len = len;
+	msg[0].buf = data;
+
+#ifdef POR_AFTER_I2C_RETRY
+	retry_cnt = 0;
+#endif
+
+	for (retry = 0; retry < SEC_TS_I2C_RETRY_CNT; retry++) {
+		ret = i2c_transfer(ts->client->adapter, msg, 1);
+		if (ret == 1)
+			break;
+
+		if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+			input_err(true, &ts->client->dev,
+								"%s: fail to POWER_STATUS=OFF ret = %d\n", __func__, ret);
+			mutex_unlock(&ts->i2c_mutex);
+			goto err;
+		}
+		if (retry > 0)
+			sec_ts_delay(10);
+	}
+
+	if (retry == SEC_TS_I2C_RETRY_CNT) {
+		input_err(true, &ts->client->dev, "%s: I2C read over retry limit\n",
+							__func__);
+#ifdef POR_AFTER_I2C_RETRY
+		schedule_delayed_work(&ts->reset_work,
+													msecs_to_jiffies(TOUCH_RESET_DWORK_TIME));
+
+		if (!retry_cnt++)
+			goto retry_fail_write;
+#endif
+		ret = -EIO;
+	}
+
+	mutex_unlock(&ts->i2c_mutex);
+	return ret;
+	input_info(true, &ts->client->dev, "%s ret=%d\n", __func__, ret);
+err:
+	return -EIO;
+}
+
+static int sec_ts_read_device_id(struct sec_ts_data *ts) {
+	unsigned char device_id[3] = {0};
+	int ret;
+
+	ret = sec_ts_i2c_probe_read(ts, SEC_TS_READ_DEVICE_ID, device_id, 3);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: failed to read device id(%d)\n",
+							__func__, ret);
+		return -EIO;
+	}
+
+	input_info(true, &ts->client->dev, "%s: %X, %X, %X ret=%d\n", __func__,
+						 device_id[0], device_id[1], device_id[2], ret);
+
+	return ret;
+}
+
+#define T_BUFF_SIZE 5
+static int sec_ts_probe(struct i2c_client *client,
+												const struct i2c_device_id *id) {
+#ifdef SEC_TS_WAKEUP_GESTURE
+	int i;
+#endif
+	struct sec_ts_data *ts;
+
+	static char sec_ts_phys[64] = {0};
+	int ret = 0;
+
+	input_info(true, &client->dev, "SEC_TS Driver [%s]\n", SEC_TS_DRV_VERSION);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		input_err(true, &client->dev, "%s : EIO err!\n", __func__);
+		return -EIO;
+	}
+
+	ret = sec_ts_setup_drv_data(client);
+	if (ret < 0) {
+		input_err(true, &client->dev, "%s: Failed to set up driver data\n",
+							__func__);
+		goto err_setup_drv_data;
+	}
+
+	ts = (struct sec_ts_data *)i2c_get_clientdata(client);
+	if (!ts) {
+		input_err(true, &client->dev, "%s: Failed to get driver data\n", __func__);
+		ret = -ENODEV;
+		goto err_get_drv_data;
+	}
+
+	if (!(IS_ERR_OR_NULL(ts->plat_data->pins_default) ||
+				IS_ERR_OR_NULL(ts->plat_data->pinctrl))) {
+		ret = pinctrl_select_state(ts->plat_data->pinctrl,
+															 ts->plat_data->pins_default);
+		if (ret < 0)
+			input_err(true, &ts->client->dev,
+								"%s: Failed to configure tsp_attn pin\n", __func__);
+	}
+
+	ts->input_dev = input_allocate_device();
+	if (!ts->input_dev) {
+		input_err(true, &ts->client->dev, "%s: allocate device err!\n", __func__);
+		ret = -ENOMEM;
+		goto err_allocate_device;
+	}
+
+	ts->input_dev->name = "Samsung Electronics Touchscreen 1223";
+	snprintf(sec_ts_phys, sizeof(sec_ts_phys), "%s/input1", ts->input_dev->name);
+	ts->input_dev->name = "Samsung Electronics Touchscreen 1223";
+	snprintf(sec_ts_phys, sizeof(sec_ts_phys), "%s/input1",
+		ts->input_dev->name);
+	ts->input_dev->phys = sec_ts_phys;
+	ts->input_dev->id.bustype = BUS_I2C;
+	ts->input_dev->dev.parent = &client->dev;
+	ts->touch_count = 0;
+
+	mutex_init(&ts->lock);
+	mutex_init(&ts->device_mutex);
+	mutex_init(&ts->i2c_mutex);
+
+#ifdef CONFIG_TOUCHSCREN_SEC_TS_GLOVEMODE
+	input_set_capability(ts->input_dev, EV_SW, SW_GLOVE);
+#endif
+	set_bit(EV_SYN, ts->input_dev->evbit);
+	set_bit(EV_KEY, ts->input_dev->evbit);
+	set_bit(EV_ABS, ts->input_dev->evbit);
+	set_bit(BTN_TOUCH, ts->input_dev->keybit);
+	set_bit(BTN_TOOL_FINGER, ts->input_dev->keybit);
+
+#ifdef SEC_TS_SUPPORT_TOUCH_KEY
+	if (ts->plat_data->support_mskey) {
+		for (i = 0; i < ts->plat_data->num_touchkey; i++)
+			set_bit(ts->plat_data->touchkey[i].keycode, ts->input_dev->keybit);
+
+		set_bit(EV_LED, ts->input_dev->evbit);
+		set_bit(LED_MISC, ts->input_dev->ledbit);
+	}
+#endif
+
+#ifdef INPUT_PROP_DIRECT
+	set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
+#endif
+
+	ts->input_dev->evbit[0] = BIT_MASK(EV_ABS) | BIT_MASK(EV_KEY);
+	set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
+
+	input_mt_init_slots(ts->input_dev, MAX_SUPPORT_TOUCH_COUNT, INPUT_MT_DIRECT);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X, 0,
+											 ts->plat_data->max_x, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y, 0,
+											 ts->plat_data->max_y, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MINOR, 0, 255, 0, 0);
+#ifdef SEC_TS_SUPPORT_SEC_SWIPE
+	input_set_abs_params(ts->input_dev, ABS_MT_PALM, 0, 1, 0, 0);
+#endif
+#if defined(SEC_TS_SUPPORT_GRIP_EVENT)
+	input_set_abs_params(ts->input_dev, ABS_MT_GRIP, 0, 1, 0, 0);
+#endif
+	input_set_abs_params(ts->input_dev, ABS_MT_DISTANCE, 0, 255, 0, 0);
+
+#ifdef CONFIG_SEC_FACTORY
+	input_set_abs_params(ts->input_dev, ABS_MT_PRESSURE, 0, 255, 0, 0);
+#endif
+#ifdef SEC_TS_WAKEUP_GESTURE
+	handle_sec = sec_ts_gesture_state;
+	for (i = 0; i < (sizeof(wakeup_gesture_key) / sizeof(wakeup_gesture_key[0]));
+			 i++) {
+		input_set_capability(ts->input_dev, EV_KEY, wakeup_gesture_key[i]);
+	}
+
+	input_set_capability(ts->input_dev, EV_KEY, KEY_POWER);
+	mz_gesture_handle_register(handle_sec);
+	wake_lock_init(&gesture_wakelock, WAKE_LOCK_SUSPEND, "poll-wake-lock");
+#endif
+	input_set_drvdata(ts->input_dev, ts);
+	i2c_set_clientdata(client, ts);
+
+	ret = sec_ts_read_device_id(ts);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: allocate device err!\n", __func__);
+		ret = -ENOMEM;
+		goto err_input_register_device;
+	}
+
+	ret = input_register_device(ts->input_dev);
+	if (ret) {
+		input_err(true, &ts->client->dev,
+							"%s: Unable to register %s input device\n", __func__,
+							ts->input_dev->name);
+		goto err_input_register_device;
+	}
+
+	ts->power_status = SEC_TS_STATE_POWER_ON;
+
+	input_info(true, &ts->client->dev, "sec_ts_probe request_irq = %d\n",
+						 client->irq);
+#ifdef SEC_TS_WAKEUP_GESTURE
+	ret = request_threaded_irq(client->irq, NULL, sec_ts_irq_thread,
+														 ts->plat_data->irq_type | IRQF_ONESHOT |
+																 IRQF_NO_SUSPEND,
+														 SEC_TS_I2C_NAME, ts);
+#else
+	ret = request_threaded_irq(client->irq, NULL, sec_ts_irq_thread,
+														 ts->plat_data->irq_type | IRQF_ONESHOT,
+														 SEC_TS_I2C_NAME, ts);
+#endif
+	if (ret < 0) {
+		input_err(true, &ts->client->dev,
+							"sec_ts_probe: Unable to request threaded irq\n");
+		goto err_irq;
+	}
+	disable_irq(ts->client->irq);
+	ts->interrupt_enable = SEC_TS_INTERRUPT_EN;
+	input_info(true, &ts->client->dev, "sec_ts_probe request_irq done\n");
+
+#ifdef SEC_TS_SUPPORT_TA_MODE
+	ts->callbacks.inform_charger = sec_ts_ta_cb;
+	if (ts->plat_data->register_cb)
+		ts->plat_data->register_cb(&ts->callbacks);
+#endif
+#ifndef SAMSUNG_PROJECT
+	ret = sec_class_create();
+#endif
+	if (!IS_ERR_OR_NULL(sec_class)) {
+		sec_ts_raw_device_init(ts);
+		sec_ts_fn_init(ts);
+	}
+
+	ret = sec_ts_test_proc_init(ts);
+	if (ret != 0) {
+		input_err(true, &ts->client->dev, "sec_ts test proc init failed. ret=%d\n",
+							ret);
+		goto err_proc_init;
+	}
+
+#if defined(CONFIG_FB)
+	ts->fb_notif.notifier_call = fb_notifier_callback;
+	ret = fb_register_client(&ts->fb_notif);
+	if (ret) {
+		input_err(true, &ts->client->dev, "register fb_notifier failed\n");
+		goto err_register_fb_notif;
+	}
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+	ts->early_suspend.suspend = sec_ts_early_suspend;
+	ts->early_suspend.resume = sec_ts_late_resume;
+	ret = register_early_suspend(&ts->early_suspend);
+	if (ret) {
+		input_err(true, &ts->client->dev, "register early suspend failed. ret=%d\n",
+							ret);
+		goto err_register_early_suspend;
+	}
+#endif
+
+	sec_fwu_wq = create_singlethread_workqueue("sec_fwu_wq");
+	if (!sec_fwu_wq) {
+		input_err(true, &ts->client->dev, "sec_fwu_wq create workqueue failed\n");
+		ret = -ENOMEM;
+		goto err_create_sec_fwu_wq_failed;
+	}
+
+	INIT_DELAYED_WORK(&ts->fwupdate_work, sec_ts_fwupdate_work);
+	queue_delayed_work(sec_fwu_wq, &ts->fwupdate_work,
+			 msecs_to_jiffies(TOUCH_FWUPDATE_DWORK_TIME));
+
+	ts->lowpower_mode = TO_TOUCH_MODE;
+	ts->probe_done = true;
+	tsp_data = ts;
+	device_init_wakeup(&client->dev, true);
+	input_info(true, &ts->client->dev, "sec_ts_probe done\n");
+
+	return 0;
+
+#if defined(CONFIG_FB)
+err_register_fb_notif:
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+err_register_early_suspend:
+#endif
+err_create_sec_fwu_wq_failed:
+err_proc_init:
+err_irq:
+	input_unregister_device(ts->input_dev);
+	ts->input_dev = NULL;
+err_input_register_device:
+	if (ts->input_dev)
+		input_free_device(ts->input_dev);
+
+err_allocate_device:
+err_get_drv_data:
+	kfree(ts);
+err_setup_drv_data:
+	return ret;
+}
+
+void sec_ts_release_all_finger(struct sec_ts_data *ts) {
+	int i;
+
+	for (i = 0; i < MAX_SUPPORT_TOUCH_COUNT; i++) {
+		input_mt_slot(ts->input_dev, i);
+		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, false);
+
+		if ((ts->coord[i].action == SEC_TS_Coordinate_Action_Press) ||
+				(ts->coord[i].action == SEC_TS_Coordinate_Action_Move)) {
+			ts->touch_count--;
+			if (ts->touch_count < 0)
+				ts->touch_count = 0;
+
+			ts->coord[i].action = SEC_TS_Coordinate_Action_Release;
+
+			input_info(
+					true, &ts->client->dev,
+					"%s: [RA] tID:%d mc:%d tc:%d cal:0x%x(%X|%X) [SE%02X%02X%02X]\n",
+					__func__, i, ts->coord[i].mcount, ts->touch_count, ts->cal_status,
+					ts->nv, ts->cal_count, ts->plat_data->panel_revision,
+					ts->plat_data->img_version_of_ic[2],
+					ts->plat_data->img_version_of_ic[3]);
+		}
+
+		ts->coord[i].mcount = 0;
+	}
+
+	input_report_key(ts->input_dev, BTN_TOUCH, false);
+	input_report_key(ts->input_dev, BTN_TOOL_FINGER, false);
+#ifdef CONFIG_TOUCHSCREN_SEC_TS_GLOVEMODE
+	input_report_switch(ts->input_dev, SW_GLOVE, false);
+#endif
+	ts->touchkey_glove_mode_status = false;
+	ts->touch_count = 0;
+
+	input_sync(ts->input_dev);
+}
+
+static int sec_ts_set_lowpowermode(struct sec_ts_data *ts, u8 mode) {
+	int ret = -1;
+
+	input_err(true, &ts->client->dev, "%s: %s\n", __func__,
+						mode == TO_LOWPOWER_MODE ? "ENTER" : "EXIT");
+
+	ts->power_status = SEC_TS_STATE_POWER_ON;
+	if (mode) {
+		ret = sec_ts_i2c_write(ts, SEC_TS_CMD_SET_POWER_MODE, &mode, 1);
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "%s: failed\n", __func__);
+	}
+
+	ts->lowpower_mode = mode;
+	sec_ts_release_all_finger(ts);
+
+	return ret;
+}
+
+static void sec_ts_reset_work(struct work_struct *work) {
+	struct sec_ts_data *ts =
+			container_of(work, struct sec_ts_data, reset_work.work);
+
+	if (!ts->probe_done)
+		return;
+
+	input_err(true, &ts->client->dev, "%s start\n", __func__);
+	sec_ts_delay(30);
+	input_info(true, &ts->client->dev, "%s done\n", __func__);
+}
+
+static void __maybe_unused sec_ts_fwupdate_work(struct work_struct *work) {
+	u8 tBuff[T_BUFF_SIZE];
+	int ret = 0;
+
+	struct sec_ts_data *ts =
+			container_of(work, struct sec_ts_data, fwupdate_work.work);
+
+	if (!ts->probe_done)
+		return;
+	input_err(true, &ts->client->dev, "%s start\n", __func__);
+
+	mutex_lock(&ts->device_mutex);
+
+	/* Enable Power */
+	ts->plat_data->power(ts, true);
+	ts->power_status = SEC_TS_STATE_POWER_ON;
+	ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SW_RESET, NULL, 0);
+	sec_ts_delay(500);
+	sec_ts_wait_for_ready(ts, SEC_TS_ACK_BOOT_COMPLETE);
+
+#ifndef CONFIG_FW_UPDATE_ON_PROBE
+	input_info(true, &ts->client->dev, "%s: fw update on probe disabled!\n",
+						 __func__);
+	sec_ts_check_firmware_version(ts, sec_get_fwdata());
+
+	ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_CALIBRATION_OFFSET_SDC, NULL, 0);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: calibration fail\n", __func__);
+	}
+	sec_ts_delay(1000);
+
+	ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SW_RESET, NULL, 0);
+	sec_ts_delay(500);
+#endif
+
+#ifdef CONFIG_FW_UPDATE_ON_PROBE
+	ret = sec_ts_firmwarei_update_on_probe(ts);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: fw update fail, ret = %d!\n",
+							__func__, ret);
+		goto err_init;
+	} else
+		input_err(true, &ts->client->dev, "%s: fw update success, ret = %d!\n",
+							__func__, ret);
+#endif
+
+	ret = sec_ts_read_information(ts);
+	if ((ts->tx_count == 0) || (ts->rx_count == 0)) {
+
+		/* Read Raw Channel Info */
+		ret = sec_ts_i2c_read(ts, SEC_TS_READ_SUB_ID, tBuff, 5);
+		if (ret < 0) {
+			input_err(true, &ts->client->dev, "%s: fail to read raw channel info\n",
+								__func__);
+			goto err_init;
+		} else {
+			ts->tx_count = tBuff[3];
+			ts->rx_count = tBuff[4];
+			input_info(true, &ts->client->dev, "%s: S6SSEC_TS Tx : %d, Rx : %d\n",
+								 __func__, ts->tx_count, ts->rx_count);
+		}
+	}
+
+	ts->pFrame = kzalloc(ts->tx_count * ts->rx_count * 2, GFP_KERNEL);
+	if (!ts->pFrame) {
+		ret = -ENOMEM;
+		goto err_allocate_frame;
+	}
+	ts->fw_workdone = true;
+	mutex_unlock(&ts->device_mutex);
+	enable_irq(ts->client->irq);
+	input_info(true, &ts->client->dev, "%s done\n", __func__);
+	return;
+
+err_allocate_frame:
+err_init:
+	mutex_unlock(&ts->device_mutex);
+	enable_irq(ts->client->irq);
+	input_info(true, &ts->client->dev, "%s failed\n", __func__);
+}
+
+static int sec_ts_input_open(struct input_dev *dev) {
+	struct sec_ts_data *ts = input_get_drvdata(dev);
+	int ret;
+
+	if (ts->fw_workdone) {
+		if (ts->lowpower_status) {
+			sec_ts_delay(200);
+			sec_ts_set_lowpowermode(ts, TO_TOUCH_MODE);
+			enable_irq(ts->client->irq);
+		} else {
+			ret = sec_ts_start_device(ts);
+			if (ret < 0)
+				input_err(true, &ts->client->dev, "%s: Failed to start device\n",
+									__func__);
+		}
+	}
+	input_err(true, &ts->client->dev, "%s : Done", __func__);
+
+	return 0;
+}
+
+static void sec_ts_input_close(struct input_dev *dev) {
+	struct sec_ts_data *ts = input_get_drvdata(dev);
+	input_err(true, &ts->client->dev, "%s\n", __func__);
+
+	cancel_delayed_work(&ts->reset_work);
+
+	if (ts->fw_workdone) {
+		if (ts->lowpower_status) {
+			sec_ts_set_lowpowermode(ts, TO_LOWPOWER_MODE);
+			enable_irq_wake(ts->client->irq);
+		} else
+			sec_ts_stop_device(ts);
+	}
+}
+
+static int sec_ts_remove(struct i2c_client *client) {
+	struct sec_ts_data *ts = i2c_get_clientdata(client);
+
+	pr_err("%s\n", __func__);
+#if defined(CONFIG_FB)
+	if (fb_unregister_client(&ts->fb_notif))
+		input_err(true, &ts->client->dev, "unregistering fb_notifier err\n");
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+	unregister_early_suspend(&ts->early_suspend);
+#endif
+
+	free_irq(client->irq, ts);
+
+	input_mt_destroy_slots(ts->input_dev);
+	input_unregister_device(ts->input_dev);
+
+	ts->input_dev = NULL;
+	ts->plat_data->power(ts, false);
+
+	kfree(ts);
+	return 0;
+}
+
+static void sec_ts_shutdown(struct i2c_client *client) {
+	struct sec_ts_data *ts = i2c_get_clientdata(client);
+	pr_err("%s\n", __func__);
+
+	sec_ts_stop_device(ts);
+}
+
+static int sec_ts_stop_device(struct sec_ts_data *ts) {
+	input_info(true, &ts->client->dev, "%s\n", __func__);
+
+	mutex_lock(&ts->device_mutex);
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev, "%s: already power off\n", __func__);
+		goto out;
+	}
+
+	disable_irq(ts->client->irq);
+	sec_ts_release_all_finger(ts);
+
+	ts->plat_data->power(ts, false);
+	ts->power_status = SEC_TS_STATE_POWER_OFF;
+
+	if (ts->plat_data->enable_sync)
+		ts->plat_data->enable_sync(false);
+
+out:
+	mutex_unlock(&ts->device_mutex);
+	input_info(true, &ts->client->dev, "%s: done\n", __func__);
+	return 0;
+}
+
+static int sec_ts_start_device(struct sec_ts_data *ts) {
+	input_info(true, &ts->client->dev, "%s\n", __func__);
+
+	mutex_lock(&ts->device_mutex);
+	if (ts->power_status == SEC_TS_STATE_POWER_ON) {
+		input_err(true, &ts->client->dev, "%s: already power on\n", __func__);
+		goto out;
+	}
+	sec_ts_release_all_finger(ts);
+	if (!ts->interrupt_enable) {
+		input_err(true, &ts->client->dev, "%s: interrupt work not finished\n",
+							__func__);
+		goto out;
+	}
+	ts->plat_data->power(ts, true);
+	sec_ts_delay(200);
+	ts->power_status = SEC_TS_STATE_POWER_ON;
+	input_err(true, &ts->client->dev, "%s: SEC_TS_STATE_POWER_ON\n", __func__);
+	if (ts->plat_data->enable_sync)
+		ts->plat_data->enable_sync(true);
+
+#ifdef SEC_TS_SUPPORT_TA_MODE
+	if (ts->ta_status)
+		sec_ts_charger_config(ts, ts->ta_status);
+#endif
+	enable_irq(ts->client->irq);
+out:
+	mutex_unlock(&ts->device_mutex);
+	input_info(true, &ts->client->dev, "%s: done\n", __func__);
+	return 0;
+}
+
+#if defined(CONFIG_FB)
+static int fb_notifier_callback(struct notifier_block *self,
+																unsigned long event, void *data) {
+	struct fb_event *evdata = data;
+	int *blank;
+
+	struct sec_ts_data *ts = container_of(self, struct sec_ts_data, fb_notif);
+	input_info(true, &ts->client->dev, "%s event = %ld\n", __func__, event);
+
+#ifndef FB_EARLY_EVENT_BLANK
+#define FB_EARLY_EVENT_BLANK FB_EVENT_BLANK
+/*
+	from after kernel 4.9 FB_EARLY_EVENT_BLANK is no longer available
+	to workaround, make it same as FB_EVENT_BLANK
+*/
+#endif
+
+	if (evdata && evdata->data && event == FB_EARLY_EVENT_BLANK) {
+		blank = evdata->data;
+		input_info(true, &ts->client->dev,
+							 "%s event = FB_EARLY_EVENT_BLANK, blank = %d\n", __func__,
+							 *blank);
+		if (*blank == FB_BLANK_POWERDOWN) {
+			input_info(true, &ts->client->dev, "%s blank = FB_BLANK_POWERDOWN\n",
+								 __func__);
+			sec_ts_input_close(ts->input_dev);
+		} else if (*blank == FB_BLANK_UNBLANK) {
+			input_info(true, &ts->client->dev, "%s blank = FB_BLANK_UNBLANK\n",
+								 __func__);
+			if (ts->lowpower_status && ts->fw_workdone) {
+				disable_irq(ts->client->irq);
+			}
+		}
+	} else if (evdata && evdata->data && event == FB_EVENT_BLANK) {
+		blank = evdata->data;
+		input_info(true, &ts->client->dev,
+							 "%s event = FB_EVENT_BLANK, blank = %d\n", __func__, *blank);
+		if (*blank == FB_BLANK_UNBLANK) {
+			input_info(true, &ts->client->dev, "%s blank = FB_BLANK_UNBLANK\n",
+								 __func__);
+			sec_ts_input_open(ts->input_dev);
+		} else if (*blank == FB_BLANK_POWERDOWN) {
+			input_info(true, &ts->client->dev, "%s blank = FB_BLANK_POWERDOWN\n",
+								 __func__);
+		}
+	}
+
+	return 0;
+}
+
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+static void sec_ts_early_suspend(struct early_suspend *h) {
+	sec_ts_input_close(ts->input_dev);
+}
+
+static void sec_ts_late_resume(struct early_suspend *h) {
+	sec_ts_input_open(ts->input_dev);
+}
+#endif
+
+static const struct i2c_device_id sec_ts_id[] = {
+		{SEC_TS_I2C_NAME, 0}, {},
+};
+MODULE_DEVICE_TABLE(i2c, sec_ts_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id sec_ts_match_table[] = {
+		{
+				.compatible = "sec,sec_ts",
+		},
+		{},
+};
+MODULE_DEVICE_TABLE(of, sec_ts_match_table);
+#endif
+
+static struct i2c_driver sec_ts_driver = {
+		.probe = sec_ts_probe,
+		.remove = sec_ts_remove,
+		.shutdown = sec_ts_shutdown,
+		.id_table = sec_ts_id,
+		.driver =
+				{
+						.owner = THIS_MODULE,
+						.name = SEC_TS_I2C_NAME,
+						.of_match_table = of_match_ptr(sec_ts_match_table),
+				},
+};
+
+static int __init sec_ts_init(void) {
+	int ret;
+
+	ret = i2c_add_driver(&sec_ts_driver);
+	if (ret)
+		pr_err("%s:fail to i2c_add_driver\n", __func__);
+	else
+		pr_err("%s:reg to i2c_add_driver [sec_ts]\n", __func__);
+	return ret;
+}
+
+static void __exit sec_ts_exit(void) {
+	i2c_del_driver(&sec_ts_driver);
+
+	if (sec_fwu_wq)
+		destroy_workqueue(sec_fwu_wq);
+}
+
+late_initcall_sync(sec_ts_init);
+module_exit(sec_ts_exit);
+
+MODULE_AUTHOR("Younghee, Won<younghee46.won@samsung.com>");
+MODULE_DESCRIPTION("Samsung Electronics TouchScreen driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/sec_ts/sec_ts_only_vendor.c b/drivers/input/touchscreen/sec_ts/sec_ts_only_vendor.c
new file mode 100644
index 000000000000..691bdb08a751
--- /dev/null
+++ b/drivers/input/touchscreen/sec_ts/sec_ts_only_vendor.c
@@ -0,0 +1,296 @@
+/* drivers/input/touchscreen/sec_ts_fw.c
+ *
+ * Copyright (C) 2015 Samsung Electronics Co., Ltd.
+ * http://www.samsungsemi.com/
+ *
+ * Core file for Samsung TSC driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/platform_device.h>
+#include <linux/firmware.h>
+#include <linux/gpio.h>
+#include <linux/regulator/consumer.h>
+#include <linux/irq.h>
+#include <linux/of_gpio.h>
+#include <linux/time.h>
+#include <linux/vmalloc.h>
+
+#include <linux/uaccess.h>
+/*#include <asm/gpio.h>*/
+
+#include "sec_ts.h"
+
+u8 lv1cmd;
+u8 *read_lv1_buff;
+static int lv1_readsize;
+static int lv1_readremain;
+static int lv1_readoffset;
+
+static ssize_t sec_ts_reg_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+static ssize_t sec_ts_regreadsize_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+static inline ssize_t sec_ts_store_error(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count);
+static ssize_t sec_ts_enter_recovery_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size);
+static ssize_t sec_ts_regread_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+static ssize_t sec_ts_gesture_status_show(struct device *dev,
+		struct device_attribute *attr, char *buf);
+static inline ssize_t sec_ts_show_error(struct device *dev,
+		struct device_attribute *attr, char *buf);
+
+static DEVICE_ATTR(sec_ts_reg, (S_IWUSR | S_IWGRP), NULL, sec_ts_reg_store);
+static DEVICE_ATTR(sec_ts_regreadsize, (S_IWUSR | S_IWGRP), NULL, sec_ts_regreadsize_store);
+static DEVICE_ATTR(sec_ts_enter_recovery, (S_IWUSR | S_IWGRP), NULL, sec_ts_enter_recovery_store);
+static DEVICE_ATTR(sec_ts_regread, S_IRUGO, sec_ts_regread_show, NULL);
+static DEVICE_ATTR(sec_ts_gesture_status, S_IRUGO, sec_ts_gesture_status_show, NULL);
+
+static struct attribute *cmd_attributes[] = {
+	&dev_attr_sec_ts_reg.attr,
+	&dev_attr_sec_ts_regreadsize.attr,
+	&dev_attr_sec_ts_enter_recovery.attr,
+	&dev_attr_sec_ts_regread.attr,
+	&dev_attr_sec_ts_gesture_status.attr,
+	NULL,
+};
+
+static struct attribute_group cmd_attr_group = {
+	.attrs = cmd_attributes,
+};
+
+/* for debugging--------------------------------------------------------------------------------------*/
+static ssize_t sec_ts_reg_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_info(true, &ts->client->dev, "%s: Power off state\n", __func__);
+		return -EIO;
+	}
+
+	if (size > 0)
+		ts->sec_ts_i2c_write_burst(ts, (u8 *)buf, size);
+
+	input_info(true, &ts->client->dev, "%s: 0x%x, 0x%x, size %d\n", __func__, buf[0], buf[1], (int)size);
+	return size;
+}
+
+static ssize_t sec_ts_regread_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+	int ret;
+	int length;
+	int remain;
+	int offset;
+
+	if (ts->power_status == SEC_TS_STATE_POWER_OFF) {
+		input_err(true, &ts->client->dev, "%s: Power off state\n", __func__);
+		return -EIO;
+	}
+
+	disable_irq(ts->client->irq);
+
+	mutex_lock(&ts->device_mutex);
+	
+	if ((lv1_readsize <= 0) || (lv1_readsize > PAGE_SIZE)) {
+		input_err(true, &ts->client->dev, "%s: invalid lv1_readsize = %d\n",
+						__func__, lv1_readsize);
+		lv1_readsize = 0;
+		goto malloc_err;
+	}
+
+	read_lv1_buff = kzalloc(lv1_readsize, GFP_KERNEL);
+	if (!read_lv1_buff)
+		goto malloc_err;
+
+	remain = lv1_readsize;
+	offset = 0;
+	do {
+		if (remain >= ts->i2c_burstmax)
+			length = ts->i2c_burstmax;
+		else
+			length = remain;
+
+		if (offset == 0)
+			ret = ts->sec_ts_i2c_read(ts, lv1cmd, &read_lv1_buff[offset], length);
+		else
+			ret = ts->sec_ts_i2c_read_bulk (ts, &read_lv1_buff[offset], length);
+
+		if (ret < 0) {
+			input_err(true, &ts->client->dev, "%s: i2c read %x command, remain =%d\n", __func__, lv1cmd, remain);
+			goto i2c_err;
+		}
+
+		remain -= length;
+		offset += length;
+	} while (remain > 0);
+
+	input_info(true, &ts->client->dev, "%s: lv1_readsize = %d\n", __func__, lv1_readsize);
+	memcpy(buf, read_lv1_buff + lv1_readoffset, lv1_readsize);
+
+i2c_err:
+	kfree(read_lv1_buff);
+malloc_err:
+	mutex_unlock(&ts->device_mutex);
+	lv1_readremain = 0;
+	enable_irq(ts->client->irq);
+
+	return lv1_readsize;
+}
+
+static ssize_t sec_ts_gesture_status_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+
+	mutex_lock(&ts->device_mutex);
+	memcpy(buf, ts->gesture_status, sizeof(ts->gesture_status));
+	input_info(true, &ts->client->dev,
+			"%s: GESTURE STATUS %x %x %x %x %x %x\n", __func__,
+			ts->gesture_status[0], ts->gesture_status[1], ts->gesture_status[2],
+			ts->gesture_status[3], ts->gesture_status[4], ts->gesture_status[5]);
+	mutex_unlock(&ts->device_mutex);
+
+	return sizeof(ts->gesture_status);
+}
+
+static ssize_t sec_ts_regreadsize_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+
+	mutex_lock(&ts->device_mutex);
+
+	lv1cmd = buf[0];
+	lv1_readsize = ((unsigned int)buf[4] << 24) |
+		((unsigned int)buf[3] << 16) | ((unsigned int) buf[2] << 8) | ((unsigned int)buf[1] << 0);
+	lv1_readoffset = 0;
+	lv1_readremain = 0;
+
+	mutex_unlock(&ts->device_mutex);
+
+	return size;
+}
+
+static ssize_t sec_ts_enter_recovery_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+	struct sec_ts_plat_data *pdata = ts->plat_data;
+	int ret;
+	unsigned long on;
+
+	ret = kstrtoul(buf, 10, &on);
+	if (ret != 0) {
+		input_err(true, &ts->client->dev, "%s: failed to read:%d\n",
+				__func__, ret);
+		return -EINVAL;
+	}
+
+	if (on == 1) {
+		disable_irq(ts->client->irq);
+		gpio_free(pdata->irq_gpio);
+
+		input_info(true, &ts->client->dev, "%s: gpio free\n", __func__);
+		if (gpio_is_valid(pdata->irq_gpio)) {
+			ret = gpio_request_one(pdata->irq_gpio, GPIOF_OUT_INIT_LOW, "sec,tsp_int");
+			input_info(true, &ts->client->dev, "%s: gpio request one\n", __func__);
+			if (ret < 0)
+				input_err(true, &ts->client->dev, "%s: Unable to request tsp_int [%d]: %d\n", __func__, pdata->irq_gpio, ret);
+		} else {
+			input_err(true, &ts->client->dev, "%s: Failed to get irq gpio\n", __func__);
+			return -EINVAL;
+		}
+
+		pdata->power(ts, false);
+		sec_ts_delay(100);
+		pdata->power(ts, true);
+	} else {
+		gpio_free(pdata->irq_gpio);
+
+		if (gpio_is_valid(pdata->irq_gpio)) {
+			ret = gpio_request_one(pdata->irq_gpio, GPIOF_DIR_IN, "sec,tsp_int");
+			if (ret) {
+				input_err(true, &ts->client->dev, "%s: Unable to request tsp_int [%d]\n", __func__, pdata->irq_gpio);
+				return -EINVAL;
+			}
+		} else {
+			input_err(true, &ts->client->dev, "%s: Failed to get irq gpio\n", __func__);
+			return -EINVAL;
+		}
+
+		pdata->power(ts, false);
+		sec_ts_delay(500);
+		pdata->power(ts, true);
+		sec_ts_delay(500);
+
+		/* AFE Calibration */
+		ret = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_CALIBRATION_AMBIENT, NULL, 0);
+		if (ret < 0)
+			input_err(true, &ts->client->dev, "%s: fail to write AFE_CAL\n", __func__);
+
+		sec_ts_delay(1000);
+		enable_irq(ts->client->irq);
+	}
+
+	sec_ts_read_information(ts);
+
+	return size;
+}
+
+static inline ssize_t sec_ts_show_error(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+
+	input_err(true, &ts->client->dev, "%s: read only function, %s\n", __func__, attr->attr.name);
+	return -EPERM;
+}
+
+static inline ssize_t sec_ts_store_error(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct sec_ts_data *ts = dev_get_drvdata(dev);
+
+	input_err(true, &ts->client->dev, "%s: write only function, %s\n", __func__, attr->attr.name);
+	return -EPERM;
+}
+
+int sec_ts_raw_device_init(struct sec_ts_data *ts)
+{
+	int ret;
+
+#ifdef CONFIG_SEC_SYSFS
+	ts->dev = sec_device_create(ts, "sec_ts");
+#else
+	ts->dev = device_create(sec_class, NULL, 0, ts, "sec_ts");
+#endif
+	ret = IS_ERR(ts->dev);
+	if (ret) {
+		input_err(true, &ts->client->dev, "%s: fail - device_create\n", __func__);
+		return ret;
+	}
+
+	ret = sysfs_create_group(&ts->dev->kobj, &cmd_attr_group);
+	if (ret < 0) {
+		input_err(true, &ts->client->dev, "%s: fail - sysfs_create_group\n", __func__);
+		goto err_sysfs;
+	}
+
+	return ret;
+err_sysfs:
+	input_err(true, &ts->client->dev, "%s: fail\n", __func__);
+	return ret;
+}
diff --git a/drivers/input/touchscreen/sec_ts/sec_ts_selftest.c b/drivers/input/touchscreen/sec_ts/sec_ts_selftest.c
new file mode 100644
index 000000000000..c8a67f61905c
--- /dev/null
+++ b/drivers/input/touchscreen/sec_ts/sec_ts_selftest.c
@@ -0,0 +1,743 @@
+/* drivers/input/touchscreen/sec_ts_selftest.c
+ *
+ * Copyright (C) 2016 Samsung Electronics Co., Ltd.
+ * http://www.samsungsemi.com/
+ *
+ * Core file for Samsung TSC driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/delay.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/regulator/consumer.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/slab.h>
+#include <linux/wakelock.h>
+
+#ifdef SAMSUNG_PROJECT
+#include <linux/sec_sysfs.h>
+#endif
+#include <linux/irq.h>
+#include <linux/of_gpio.h>
+#include <linux/time.h>
+#if defined(CONFIG_FB)
+#include <linux/fb.h>
+#include <linux/notifier.h>
+#elif defined(CONFIG_HAS_EARLYSUSPEND)
+#include <linux/earlysuspend.h>
+#endif
+
+#include "sec_ts.h"
+#include "sec_ts_selftest.h"
+
+#if SEC_TS_SELFTEST
+
+#define sec_ts_seq_printf(m, fmt, args...)                                     \
+	do {                                                                         \
+		seq_printf(m, fmt, ##args);                                                \
+		if (!sec_ts_test_result_printed)                                           \
+			printk(fmt, ##args);                                                     \
+	} while (0)
+
+static uint8_t *sec_ts_report_buf = NULL;
+static struct sec_ts_data *ts_data;
+
+static struct proc_dir_entry *android_touch_entry = NULL;
+static struct proc_dir_entry *sec_ts_proc_selftest_entry = NULL;
+static int8_t sec_ts_test_result_printed = 0;
+static int8_t sec_ts_test_result = -1;
+
+void sec_ts_print_report_frame(struct sec_ts_data *ts, u16 *pFrame, bool digit,
+															 bool data16) {
+	int i = 0;
+	int j = 0;
+	unsigned char *pStr = NULL;
+	unsigned char pTmp[16] = {0};
+	u16 *pFrame_u16 = (u16 *)pFrame;
+	u8 *pFrame_u8 = (u8 *)pFrame;
+	s16 *pFrame_s16 = (s16 *)pFrame;
+	s8 *pFrame_s8 = (s8 *)pFrame;
+
+	pStr = kzalloc(6 * (ts->tx_count + 1), GFP_KERNEL);
+	if (pStr == NULL)
+		return;
+
+	memset(pStr, 0x0, 6 * (ts->tx_count + 1));
+	snprintf(pTmp, sizeof(pTmp), "           ");
+	strncat(pStr, pTmp, 6 * ts->tx_count);
+
+	for (i = 0; i < ts->tx_count; i++) {
+		snprintf(pTmp, sizeof(pTmp), "Tx%02d  ", i);
+		strncat(pStr, pTmp, 6 * ts->tx_count);
+	}
+
+	printk("SEC_TS %s\n", pStr);
+	memset(pStr, 0x0, 6 * (ts->tx_count + 1));
+	snprintf(pTmp, sizeof(pTmp), "      +");
+	strncat(pStr, pTmp, 6 * ts->tx_count);
+
+	for (i = 0; i < ts->tx_count; i++) {
+		snprintf(pTmp, sizeof(pTmp), "------");
+		strncat(pStr, pTmp, 6 * ts->rx_count);
+	}
+
+	printk("SEC_TS %s\n", pStr);
+
+	for (i = 0; i < ts->rx_count; i++) {
+		memset(pStr, 0x0, 6 * (ts->tx_count + 1));
+		snprintf(pTmp, sizeof(pTmp), "Rx%02d | ", i);
+		strncat(pStr, pTmp, 6 * ts->tx_count);
+
+		for (j = 0; j < ts->tx_count; j++) {
+			if (digit && data16)
+				snprintf(pTmp, sizeof(pTmp), "%5d ",
+								 pFrame_u16[(j * ts->rx_count) + i]);
+			else if (!digit && data16)
+				snprintf(pTmp, sizeof(pTmp), "%5d ",
+								 pFrame_s16[(j * ts->rx_count) + i]);
+			else if (digit && !data16)
+				snprintf(pTmp, sizeof(pTmp), "%5d ", pFrame_u8[(j * ts->rx_count) + i]);
+			else
+				snprintf(pTmp, sizeof(pTmp), "%5d ", pFrame_s8[(j * ts->rx_count) + i]);
+			strncat(pStr, pTmp, 6 * ts->rx_count);
+		}
+		printk("SEC_TS %s\n", pStr);
+	}
+	kfree(pStr);
+}
+
+/*******************************************************
+Description:
+	Novatek touchscreen self-test sequence print show
+	function.
+
+return:
+	Executive outcomes. 0---succeed.
+*******************************************************/
+#define SUCCESS 0
+#define FAIL -1
+static int32_t c_show_selftest(struct seq_file *m, void *v) {
+#if 0	
+	struct sec_ts_data *ts = ts_data;
+	struct selftest_header *st_header; 
+	u8 *ptrBuff = sec_ts_report_buf;
+	u16 *ptrBuff16 = (u16 *)sec_ts_report_buf;
+	int i,j;
+	u8 failcnt = 0;
+	int result = SUCCESS;
+
+	sec_ts_test_result_printed = 0;
+	printk( "FW Version: %d.%d.%d.%d\n",
+		ts->plat_data->img_version_of_ic[0],
+		ts->plat_data->img_version_of_ic[1],
+		ts->plat_data->img_version_of_ic[2],
+		ts->plat_data->img_version_of_ic[3]);
+	
+	st_header = (struct selftest_header *)ptrBuff;	
+	printk( "selftest signature:%08X\n", st_header->signature);
+	printk( "selftest version:%08X\n", st_header->version);
+	printk( "selftest total size:%d\n", st_header->totalsize);	
+	printk( "selftest crc32:%08X\n", st_header->crc32);	
+	printk( "selftest result:%08X\n", st_header->result);	
+	printk( "selftest trycnt:%d\n", st_header->trycnt);	
+	printk( "selftest passcnt:%d\n", st_header->passcnt);	
+	printk( "selftest failcnt:%d\n", st_header->failcnt);
+	ptrBuff += sizeof(struct selftest_header);	
+	ptrBuff += sizeof(u32)*12;
+
+	ptrBuff16 = (u16 *)ptrBuff;
+	printk( "ambient:\n");
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, m, false, true);
+
+	result = SUCCESS;
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			int ratio = ((sec_ts_selftest_ambient[j*ts->rx_count] / 100) * 25);
+			int min = sec_ts_selftest_ambient[j*ts->rx_count] - ratio;
+			int max = sec_ts_selftest_ambient[j*ts->rx_count] + ratio;
+			if ((ptrBuff16[j*ts->rx_count] < min) ||
+				(ptrBuff16[j*ts->rx_count] > max))
+				result = FAIL;			
+		}
+	}
+	if (result == FAIL) {
+		printk( "ambient 1st Fail\n");
+		failcnt++;
+	}
+	else
+		printk( "ambient 1st Pass\n");
+
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+	printk( "ambient 2nd:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, m, false, true);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff16[j*ts->rx_count] < sec_ts_selftest_ambient_2nd[0]) ||
+				(ptrBuff16[j*ts->rx_count] > sec_ts_selftest_ambient_2nd[1]))
+				result = FAIL;			
+		}
+	}
+	if (result == FAIL) {
+		printk( "ambient 2nd Fail\n");
+		failcnt++;
+	}
+	else
+		printk( "ambient 2nd Pass\n");
+		
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+	printk( "ambient 3rd:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, m, true, true);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff16[j*ts->rx_count] < sec_ts_selftest_ambient_3rd[0]) ||
+				(ptrBuff16[j*ts->rx_count] > sec_ts_selftest_ambient_3rd[1]))
+				result = FAIL;			
+		}
+	}
+	if (result == FAIL) {
+		printk( "ambient 3rd Fail\n");
+		failcnt++;
+	}
+	else
+		printk( "ambient 3rd Pass\n");
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+
+	printk( "P2P min:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (s16 *)ptrBuff, m, false, true);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff16[j*ts->rx_count] < sec_ts_selftest_p2pmin[0]))
+				result = FAIL;			
+		}
+	}
+	if (result == FAIL) {
+		printk( "P2P Min Fail\n");
+		failcnt++;
+	}
+	else
+		printk( "P2P Min Pass\n");
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+
+	printk( "P2P Max:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, m, true, true);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff16[j*ts->rx_count] > sec_ts_selftest_p2pmax[1]))
+				result = FAIL;			
+		}
+	}
+	if (result == FAIL) {
+		printk( "P2P Max Fail\n");
+		failcnt++;
+	}
+	else
+		printk( "P2P Max Pass\n");
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+	printk( "Raw variance X:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, m, true, false);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff[j*ts->rx_count] < sec_ts_selftest_rawvarX[0]) ||
+				(ptrBuff[j*ts->rx_count] > sec_ts_selftest_rawvarX[1]))
+				result = FAIL;			
+		}
+	}
+	if (result == FAIL) {
+		printk( "Raw variance X Fail\n");
+		failcnt++;
+	}
+	else
+		printk( "Raw variance X Pass\n");
+	ptrBuff += (SEC_TS_RAWDATA_MAXSIZE/2);
+	ptrBuff16 = (u16 *)ptrBuff;
+
+	printk( "Raw variance Y:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, m, true, false);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff[j*ts->rx_count] < sec_ts_selftest_rawvarY[0]) ||
+				(ptrBuff[j*ts->rx_count] > sec_ts_selftest_rawvarY[1]))
+				result = FAIL;			
+		}
+	}
+	if (result == FAIL) {
+		printk( "Raw variance Y Fail\n");
+		failcnt++;
+	}
+	else
+		printk( "Raw variance Y Pass\n");
+	ptrBuff += (SEC_TS_RAWDATA_MAXSIZE/2);
+	ptrBuff16 = (u16 *)ptrBuff;
+
+	printk( "Short :\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, m, false, true);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff16[j*ts->rx_count] < sec_ts_selftest_short2nd[0]) ||
+				(ptrBuff16[j*ts->rx_count] > sec_ts_selftest_short2nd[1]))
+				result = FAIL;			
+		}
+	}
+	if (result == FAIL) {
+		printk( "Short Fail\n");
+		failcnt++;
+	}
+	else
+		printk( "Short Pass\n");
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+
+	printk( "Rawdata:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, m, false, true);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff16[j*ts->rx_count] < sec_ts_selftest_rawdata[0]) ||
+				(ptrBuff16[j*ts->rx_count] > sec_ts_selftest_rawdata[1]))
+				result = FAIL;			
+		}
+	}
+	if (result == FAIL) {
+		printk( "Rawdata Fail\n");
+		failcnt++;
+	}
+	else
+		printk( "Short Pass\n");
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+	printk( "Offset Cal data:\n");
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, m, true, false);
+	ptrBuff += (SEC_TS_RAWDATA_MAXSIZE/2);
+	ptrBuff16 = (u16 *)ptrBuff;
+	printk( "\n");
+#endif
+
+	if (sec_ts_test_result < 0) {
+		sec_ts_seq_printf(m, "%d\n", 0);
+	} else {
+
+		sec_ts_seq_printf(m, "%d\n", 1);
+	}
+	sec_ts_test_result_printed = 1;
+	return 0;
+}
+
+/*******************************************************
+Description:
+	Sec touchscreen self-test sequence print start
+	function.
+
+return:
+	Executive outcomes. 1---call next function.
+	NULL---not call next function and sequence loop
+	stop.
+*******************************************************/
+static void *c_start(struct seq_file *m, loff_t *pos) {
+	return *pos < 1 ? (void *)1 : NULL;
+}
+
+/*******************************************************
+Description:
+	Sec touchscreen self-test sequence print next
+	function.
+
+return:
+	Executive outcomes. NULL---no next and call sequence
+	stop function.
+*******************************************************/
+static void *c_next(struct seq_file *m, void *v, loff_t *pos) {
+	++*pos;
+	return NULL;
+}
+
+/*******************************************************
+Description:
+	Sec touchscreen self-test sequence print stop
+	function.
+
+return:
+	n.a.
+*******************************************************/
+static void c_stop(struct seq_file *m, void *v) { return; }
+
+const struct seq_operations sec_ts_selftest_seq_ops = {
+		.start = c_start, .next = c_next, .stop = c_stop, .show = c_show_selftest};
+
+static int32_t sec_ts_print_selftest(void) {
+	struct sec_ts_data *ts = ts_data;
+	struct selftest_header *st_header;
+	u8 *ptrBuff = sec_ts_report_buf;
+	u16 *ptrBuff16 = (u16 *)sec_ts_report_buf;
+	int i, j;
+	u8 failcnt = 0;
+	int result = SUCCESS;
+	int ratio, min, max;
+
+	sec_ts_test_result_printed = 0;
+	printk("FW Version: %d.%d.%d.%d\n", ts->plat_data->img_version_of_ic[0],
+				 ts->plat_data->img_version_of_ic[1],
+				 ts->plat_data->img_version_of_ic[2],
+				 ts->plat_data->img_version_of_ic[3]);
+
+	st_header = (struct selftest_header *)ptrBuff;
+	printk("selftest signature:%08X\n", st_header->signature);
+	printk("selftest version:%08X\n", st_header->version);
+	printk("selftest total size:%d\n", st_header->totalsize);
+	printk("selftest crc32:%08X\n", st_header->crc32);
+	printk("selftest result:%08X\n", st_header->result);
+	printk("selftest trycnt:%d\n", st_header->trycnt);
+	printk("selftest passcnt:%d\n", st_header->passcnt);
+	printk("selftest failcnt:%d\n", st_header->failcnt);
+	ptrBuff += sizeof(struct selftest_header);
+	ptrBuff += sizeof(u32) * 12;
+
+	ptrBuff16 = (u16 *)ptrBuff;
+	printk("ambient:\n");
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, false, true);
+
+	result = SUCCESS;
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			ratio = ((sec_ts_selftest_ambient[j * ts->rx_count] / 100) * 25);
+			min = sec_ts_selftest_ambient[j * ts->rx_count] - ratio;
+			max = sec_ts_selftest_ambient[j * ts->rx_count] + ratio;
+			if ((ptrBuff16[j * ts->rx_count] < min) ||
+					(ptrBuff16[j * ts->rx_count] > max))
+				result = FAIL;
+		}
+	}
+	if (result == FAIL) {
+		printk("ambient 1st Fail\n");
+		failcnt++;
+	} else
+		printk("ambient 1st Pass\n");
+
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+	printk("ambient 2nd:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, false, true);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff16[j * ts->rx_count] < sec_ts_selftest_ambient_2nd[0]) ||
+					(ptrBuff16[j * ts->rx_count] > sec_ts_selftest_ambient_2nd[1]))
+				result = FAIL;
+		}
+	}
+	if (result == FAIL) {
+		printk("ambient 2nd Fail\n");
+		failcnt++;
+	} else
+		printk("ambient 2nd Pass\n");
+
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+	printk("ambient 3rd:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, true, true);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff16[j * ts->rx_count] < sec_ts_selftest_ambient_3rd[0]) ||
+					(ptrBuff16[j * ts->rx_count] > sec_ts_selftest_ambient_3rd[1]))
+				result = FAIL;
+		}
+	}
+	if (result == FAIL) {
+		printk("ambient 3rd Fail\n");
+		failcnt++;
+	} else
+		printk("ambient 3rd Pass\n");
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+
+	printk("P2P min:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (s16 *)ptrBuff, false, true);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff16[j * ts->rx_count] < sec_ts_selftest_p2pmin[0]))
+				result = FAIL;
+		}
+	}
+	if (result == FAIL) {
+		printk("P2P Min Fail\n");
+		failcnt++;
+	} else
+		printk("P2P Min Pass\n");
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+
+	printk("P2P Max:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, true, true);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff16[j * ts->rx_count] > sec_ts_selftest_p2pmax[1]))
+				result = FAIL;
+		}
+	}
+	if (result == FAIL) {
+		printk("P2P Max Fail\n");
+		failcnt++;
+	} else
+		printk("P2P Max Pass\n");
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+	printk("Raw variance X:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, true, false);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff[j * ts->rx_count] < sec_ts_selftest_rawvarX[0]) ||
+					(ptrBuff[j * ts->rx_count] > sec_ts_selftest_rawvarX[1]))
+				result = FAIL;
+		}
+	}
+	if (result == FAIL) {
+		printk("Raw variance X Fail\n");
+		failcnt++;
+	} else
+		printk("Raw variance X Pass\n");
+	ptrBuff += (SEC_TS_RAWDATA_MAXSIZE / 2);
+	ptrBuff16 = (u16 *)ptrBuff;
+
+	printk("Raw variance Y:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, true, false);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff[j * ts->rx_count] < sec_ts_selftest_rawvarY[0]) ||
+					(ptrBuff[j * ts->rx_count] > sec_ts_selftest_rawvarY[1]))
+				result = FAIL;
+		}
+	}
+	if (result == FAIL) {
+		printk("Raw variance Y Fail\n");
+		failcnt++;
+	} else
+		printk("Raw variance Y Pass\n");
+	ptrBuff += (SEC_TS_RAWDATA_MAXSIZE / 2);
+	ptrBuff16 = (u16 *)ptrBuff;
+
+	printk("Short :\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, false, true);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff16[j * ts->rx_count] < sec_ts_selftest_short2nd[0]) ||
+					(ptrBuff16[j * ts->rx_count] > sec_ts_selftest_short2nd[1]))
+				result = FAIL;
+		}
+	}
+	if (result == FAIL) {
+		printk("Short Fail\n");
+		failcnt++;
+	} else
+		printk("Short Pass\n");
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+
+	printk("Rawdata:\n");
+	result = SUCCESS;
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, false, true);
+	for (i = 0; i < ts->rx_count; i++) {
+		for (j = 0; j < ts->tx_count; j++) {
+			if ((ptrBuff16[j * ts->rx_count] < sec_ts_selftest_rawdata[0]) ||
+					(ptrBuff16[j * ts->rx_count] > sec_ts_selftest_rawdata[1]))
+				result = FAIL;
+		}
+	}
+	if (result == FAIL) {
+		printk("Rawdata Fail\n");
+		failcnt++;
+	} else
+		printk("Short Pass\n");
+	ptrBuff += SEC_TS_RAWDATA_MAXSIZE;
+	ptrBuff16 = (u16 *)ptrBuff;
+	printk("Offset Cal data:\n");
+	sec_ts_print_report_frame(ts, (u16 *)ptrBuff, true, false);
+	ptrBuff += (SEC_TS_RAWDATA_MAXSIZE / 2);
+	ptrBuff16 = (u16 *)ptrBuff;
+	/*for (i = 0; i < 8; i++) {
+		printk( "%d, ", *((u32 *)ptrBuff));
+		ptrBuff += sizeof(u16);
+	}*/
+	printk("\n");
+	if (failcnt > 0) {
+		printk("Selftest result Fail\n");
+		sec_ts_test_result_printed = 1;
+		return -1;
+	} else {
+		printk("Selftest result Pass\n");
+		sec_ts_test_result_printed = 1;
+		return 0;
+	}
+}
+
+/*******************************************************
+Description:
+	Sec touchscreen /proc/sec_ts_selftest open function.
+
+return:
+	Executive outcomes. 0---succeed. negative---failed.
+*******************************************************/
+static int32_t sec_ts_selftest_open(struct inode *inode, struct file *file) {
+	struct sec_ts_data *ts = ts_data;
+	int rc;
+	u8 tpara = 0x03;
+	u8 cmd_data[10];
+	u8 *report_buff;
+	u32 result_size = SEC_TS_SELFTEST_REPORT_SIZE;
+	u32 remain_size;
+	u32 read_size;
+
+	disable_irq(ts->client->irq);
+	input_info(true, &ts->client->dev, "%s: Self test start!\n", __func__);
+	cmd_data[0] = 0xFF;
+	rc = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SELFTEST_TYPE, cmd_data, 1);
+	if (rc < 0) {
+		input_err(true, &ts->client->dev, "%s: Send selftest cmd failed!\n",
+							__func__);
+		goto err_exit;
+	}
+	sec_ts_delay(100);
+
+	cmd_data[0] = 0x0;
+	cmd_data[1] = 0x64;
+	rc = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SELFTEST_PTOP, cmd_data, 4);
+	if (rc < 0) {
+		input_err(true, &ts->client->dev, "%s: Send selftest cmd failed!\n",
+							__func__);
+		goto err_init;
+	}
+	sec_ts_delay(100);
+
+	input_info(true, &ts->client->dev, "%s: send selftest cmd!\n", __func__);
+	rc = ts->sec_ts_i2c_write(ts, SEC_TS_CMD_SELFTEST, &tpara, 1);
+	if (rc < 0) {
+		input_err(true, &ts->client->dev, "%s: Send selftest cmd failed!\n",
+							__func__);
+		goto err_init;
+	}
+	sec_ts_delay(1000);
+	rc = sec_ts_wait_for_ready(ts, SEC_TS_ACK_SELF_TEST_DONE);
+	if (rc < 0) {
+		input_err(true, &ts->client->dev, "%s: Selftest execution time out!\n",
+							__func__);
+		goto err_init;
+	}
+
+	sec_ts_sw_reset(ts);
+	sec_ts_delay(500);
+
+	input_info(true, &ts->client->dev, "%s: Self test done!\n", __func__);
+
+	sec_ts_report_buf = kzalloc(result_size, GFP_KERNEL);
+	if (!sec_ts_report_buf)
+		goto err_init;
+
+	rc = ts->sec_ts_i2c_write(ts, SEC_TS_READ_SELFTEST_RESULT, NULL, 0);
+	if (rc < 0) {
+		input_err(true, &ts->client->dev,
+							"%s: Send selftest read result cmd failed!\n", __func__);
+		goto err_exit;
+	}
+	report_buff = sec_ts_report_buf;
+	remain_size = result_size;
+	read_size = (remain_size > 256) ? (256) : (remain_size);
+	do {
+		rc = ts->sec_ts_i2c_read_bulk(ts, report_buff, read_size);
+		if (rc < 0) {
+			input_err(true, &ts->client->dev,
+								"%s: Selftest result read failed remain = %d!\n", __func__,
+								remain_size);
+			goto err_exit;
+		}
+		remain_size -= read_size;
+		report_buff += read_size;
+		read_size = (remain_size > 256) ? 256 : remain_size;
+		sec_ts_delay(1);
+	} while (remain_size > 0);
+
+	sec_ts_test_result = sec_ts_print_selftest();
+
+	enable_irq(ts->client->irq);
+	if(sec_ts_report_buf)
+		kfree(sec_ts_report_buf);
+
+	return seq_open(file, &sec_ts_selftest_seq_ops);
+
+err_exit:
+	if(sec_ts_report_buf)
+		kfree(sec_ts_report_buf);
+err_init:
+	enable_irq(ts->client->irq);
+	return -1;
+}
+
+static const struct file_operations sec_ts_selftest_fops = {
+		.owner = THIS_MODULE,
+		.open = sec_ts_selftest_open,
+		.read = seq_read,
+		.llseek = seq_lseek,
+		.release = seq_release,
+};
+
+/*******************************************************
+Description:
+	Novatek touchscreen MP function proc. file node
+	initial function.
+
+return:
+	Executive outcomes. 0---succeed. -1---failed.
+*******************************************************/
+int32_t sec_ts_test_proc_init(struct sec_ts_data *ts) {
+	ts_data = ts;
+
+	android_touch_entry = proc_mkdir("android_touch", NULL);
+	if (android_touch_entry == NULL) {
+		input_err(true, &ts->client->dev, "create /proc/android_touch Failed!\n");
+		return -1;
+	}
+
+	sec_ts_proc_selftest_entry = proc_create(
+			"self_test", 0444, android_touch_entry, &sec_ts_selftest_fops);
+	if (sec_ts_proc_selftest_entry == NULL) {
+		input_err(true, &ts->client->dev, "create /proc/self_test Failed!\n");
+		return -1;
+	} else {
+		input_info(true, &ts->client->dev, "create /proc/self_test Succeeded!\n");
+		return 0;
+	}
+}
+
+#endif /* #if SEC_TS_SELFTEST */
diff --git a/drivers/input/touchscreen/sec_ts/sec_ts_selftest.h b/drivers/input/touchscreen/sec_ts/sec_ts_selftest.h
new file mode 100644
index 000000000000..0e4201f7a8ef
--- /dev/null
+++ b/drivers/input/touchscreen/sec_ts/sec_ts_selftest.h
@@ -0,0 +1,91 @@
+/* drivers/input/touchscreen/sec_ts_selftest.h
+ *
+ * Copyright (C) 2016 Samsung Electronics Co., Ltd.
+ * http://www.samsungsemi.com/
+ *
+ * Core file for Samsung TSC driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __SEC_TS_SELFTEST_H__
+#define __SEC_TS_SELFTEST_H__
+
+#define SEC_TS_SELFTEST 1
+#define SEC_TS_RAWDATA_MAXSIZE (32 * 32 * 2)
+
+struct selftest_header {
+	u32 signature;
+	u32 version;
+	u32 totalsize;
+	u32 crc32;
+	u32 result;
+	u32 trycnt;
+	u32 passcnt;
+	u32 failcnt;
+	u32 channel;
+};
+
+static int16_t sec_ts_selftest_ambient[18 * 32] = {
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+		6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639, 6639,
+};
+
+static int16_t sec_ts_selftest_ambient_2nd[2] = {0, 100};
+static int16_t sec_ts_selftest_ambient_3rd[2] = {0, 100};
+static int16_t sec_ts_selftest_p2pmin[2] = {-30, 0};
+static int16_t sec_ts_selftest_p2pmax[2] = {0, 30};
+static int8_t sec_ts_selftest_rawvarX[2] = {0, 15};
+static int8_t sec_ts_selftest_rawvarY[2] = {0, 15};
+static int16_t sec_ts_selftest_short2nd[2] = {0, 100};
+static int16_t sec_ts_selftest_rawdata[2] = {1650, 2350};
+
+#endif
diff --git a/drivers/interconnect/qcom/sdm660.c b/drivers/interconnect/qcom/sdm660.c
index 8d879b0bcabc..26661d2184fd 100644
--- a/drivers/interconnect/qcom/sdm660.c
+++ b/drivers/interconnect/qcom/sdm660.c
@@ -1716,6 +1716,7 @@ static struct platform_driver sdm660_noc_driver = {
 	.driver = {
 		.name = "qnoc-sdm660",
 		.of_match_table = sdm660_noc_of_match,
+		.sync_state = icc_sync_state,
 	},
 };
 module_platform_driver(sdm660_noc_driver);
diff --git a/drivers/iommu/arm/arm-smmu/arm-smmu-qcom.c b/drivers/iommu/arm/arm-smmu/arm-smmu-qcom.c
index b2708de25ea3..32427db32b6c 100644
--- a/drivers/iommu/arm/arm-smmu/arm-smmu-qcom.c
+++ b/drivers/iommu/arm/arm-smmu/arm-smmu-qcom.c
@@ -386,7 +386,7 @@ static int qcom_smmu500_reset(struct arm_smmu_device *smmu)
 	return 0;
 }
 
-static const struct arm_smmu_impl qcom_smmu_impl = {
+static const struct arm_smmu_impl qcom_smmu500_impl = {
 	.init_context = qcom_smmu_init_context,
 	.cfg_probe = qcom_smmu_cfg_probe,
 	.def_domain_type = qcom_smmu_def_domain_type,
@@ -395,6 +395,56 @@ static const struct arm_smmu_impl qcom_smmu_impl = {
 	.tlb_sync = qcom_smmu_tlb_sync,
 };
 
+static int qcom_smmuv2_cfg_probe(struct arm_smmu_device *smmu)
+{
+	/*
+	 * Some IOMMUs are getting set-up for Shared Virtual Address, but:
+	 * 1. They are secured by the Hypervisor, so any configuration
+	 *    change will generate a hyp-fault and crash the system
+	 * 2. This 39-bits Virtual Address size deviates from the ARM
+	 *    System MMU Architecture specification for SMMUv2, hence
+	 *    it is non-standard. In this case, the only way to keep the
+	 *    IOMMU as the firmware did configure it, is to hardcode a
+	 *    maximum VA size of 39 bits (because of point 1).
+	 */
+	if (smmu->va_size > 39UL)
+		dev_notice(smmu->dev,
+			   "\tenabling workaround for QCOM SMMUv2 VA size\n");
+	smmu->va_size = min(smmu->va_size, 39UL);
+
+	return 0;
+}
+
+static void qcom_smmuv2_stream_mapping_reset(struct arm_smmu_device *smmu)
+{
+	/*
+	 * Broken firmware quirk:
+	 * On some Qualcomm SoCs with certain hypervisor configurations,
+	 * some context banks are hyp-protected and cannot be disabled,
+	 * nor the relative S2CRs can be set as bypass, or a hyp-fault
+	 * will be triggered and the system will hang.
+	 */
+	return;
+}
+
+static void qcom_smmuv2_test_smr_masks(struct arm_smmu_device *smmu)
+{
+	/*
+	 * Broken firmware quirk:
+	 * On some Qualcomm SoCs with certain hypervisor configurations,
+	 * writing the streamid masks to the SMRs will trigger a hyp-fault
+	 * and crash the system.
+	 */
+	smmu->streamid_mask = 0x7FFF;
+	smmu->smr_mask_mask = 0x7FFF;
+}
+
+static const struct arm_smmu_impl qcom_smmuv2_impl = {
+	.cfg_probe = qcom_smmuv2_cfg_probe,
+	.stream_mapping_reset = qcom_smmuv2_stream_mapping_reset,
+	.test_smr_masks = qcom_smmuv2_test_smr_masks,
+};
+
 static const struct arm_smmu_impl qcom_adreno_smmu_impl = {
 	.init_context = qcom_adreno_smmu_init_context,
 	.def_domain_type = qcom_smmu_def_domain_type,
@@ -430,7 +480,6 @@ static const struct of_device_id __maybe_unused qcom_smmu_impl_of_match[] = {
 	{ .compatible = "qcom,sc7280-smmu-500" },
 	{ .compatible = "qcom,sc8180x-smmu-500" },
 	{ .compatible = "qcom,sc8280xp-smmu-500" },
-	{ .compatible = "qcom,sdm630-smmu-v2" },
 	{ .compatible = "qcom,sdm845-smmu-500" },
 	{ .compatible = "qcom,sm6125-smmu-500" },
 	{ .compatible = "qcom,sm6350-smmu-500" },
@@ -462,6 +511,9 @@ struct arm_smmu_device *qcom_smmu_impl_init(struct arm_smmu_device *smmu)
 	}
 #endif
 
+	if (of_device_is_compatible(np, "qcom,sdm630-smmu-v2"))
+		return qcom_smmu_create(smmu, &qcom_smmuv2_impl);
+
 	/*
 	 * Do not change this order of implementation, i.e., first adreno
 	 * smmu impl and then apss smmu since we can have both implementing
@@ -472,7 +524,7 @@ struct arm_smmu_device *qcom_smmu_impl_init(struct arm_smmu_device *smmu)
 		return qcom_smmu_create(smmu, &qcom_adreno_smmu_impl);
 
 	if (of_match_node(qcom_smmu_impl_of_match, np))
-		return qcom_smmu_create(smmu, &qcom_smmu_impl);
+		return qcom_smmu_create(smmu, &qcom_smmu500_impl);
 
 	return smmu;
 }
diff --git a/drivers/iommu/arm/arm-smmu/arm-smmu.c b/drivers/iommu/arm/arm-smmu/arm-smmu.c
index dfa82df00342..024f26f38a66 100644
--- a/drivers/iommu/arm/arm-smmu/arm-smmu.c
+++ b/drivers/iommu/arm/arm-smmu/arm-smmu.c
@@ -953,6 +953,12 @@ static void arm_smmu_test_smr_masks(struct arm_smmu_device *smmu)
 
 	if (!smmu->smrs)
 		return;
+
+	if (smmu->impl && smmu->impl->test_smr_masks) {
+		smmu->impl->test_smr_masks(smmu);
+		return;
+	}
+
 	/*
 	 * If we've had to accommodate firmware memory regions, we may
 	 * have live SMRs by now; tread carefully...
@@ -1600,14 +1606,14 @@ static struct iommu_ops arm_smmu_ops = {
 	}
 };
 
-static void arm_smmu_device_reset(struct arm_smmu_device *smmu)
+static void arm_smmu_stream_mapping_reset(struct arm_smmu_device *smmu)
 {
 	int i;
-	u32 reg;
 
-	/* clear global FSR */
-	reg = arm_smmu_gr0_read(smmu, ARM_SMMU_GR0_sGFSR);
-	arm_smmu_gr0_write(smmu, ARM_SMMU_GR0_sGFSR, reg);
+	if (smmu->impl && smmu->impl->stream_mapping_reset) {
+		smmu->impl->stream_mapping_reset(smmu);
+		return;
+	}
 
 	/*
 	 * Reset stream mapping groups: Initial values mark all SMRn as
@@ -1621,6 +1627,18 @@ static void arm_smmu_device_reset(struct arm_smmu_device *smmu)
 		arm_smmu_write_context_bank(smmu, i);
 		arm_smmu_cb_write(smmu, i, ARM_SMMU_CB_FSR, ARM_SMMU_FSR_FAULT);
 	}
+}
+
+static void arm_smmu_device_reset(struct arm_smmu_device *smmu)
+{
+	u32 reg;
+
+	/* clear global FSR */
+	reg = arm_smmu_gr0_read(smmu, ARM_SMMU_GR0_sGFSR);
+	arm_smmu_gr0_write(smmu, ARM_SMMU_GR0_sGFSR, reg);
+
+	/* Reset stream mapping */
+	arm_smmu_stream_mapping_reset(smmu);
 
 	/* Invalidate the TLB, just in case */
 	arm_smmu_gr0_write(smmu, ARM_SMMU_GR0_TLBIALLH, QCOM_DUMMY_VAL);
diff --git a/drivers/iommu/arm/arm-smmu/arm-smmu.h b/drivers/iommu/arm/arm-smmu/arm-smmu.h
index 703fd5817ec1..b6946e6c981c 100644
--- a/drivers/iommu/arm/arm-smmu/arm-smmu.h
+++ b/drivers/iommu/arm/arm-smmu/arm-smmu.h
@@ -432,6 +432,8 @@ struct arm_smmu_impl {
 	int (*reset)(struct arm_smmu_device *smmu);
 	int (*init_context)(struct arm_smmu_domain *smmu_domain,
 			struct io_pgtable_cfg *cfg, struct device *dev);
+	void (*test_smr_masks)(struct arm_smmu_device *smmu);
+	void (*stream_mapping_reset)(struct arm_smmu_device *smmu);
 	void (*tlb_sync)(struct arm_smmu_device *smmu, int page, int sync,
 			 int status);
 	int (*def_domain_type)(struct device *dev);
diff --git a/drivers/leds/rgb/leds-qcom-lpg.c b/drivers/leds/rgb/leds-qcom-lpg.c
index 02f51cc61837..102ab0c33887 100644
--- a/drivers/leds/rgb/leds-qcom-lpg.c
+++ b/drivers/leds/rgb/leds-qcom-lpg.c
@@ -1304,6 +1304,23 @@ static int lpg_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct lpg_data pm660l_lpg_data = {
+	.lut_base = 0xb000,
+	.lut_size = 49,
+
+	.triled_base = 0xd000,
+	.triled_has_atc_ctl = true,
+	.triled_has_src_sel = true,
+
+	.num_channels = 4,
+	.channels = (const struct lpg_channel_data[]) {
+		{ .base = 0xb100, .triled_mask = BIT(5) },
+		{ .base = 0xb200, .triled_mask = BIT(6) },
+		{ .base = 0xb300, .triled_mask = BIT(7) },
+		{ .base = 0xb400 },
+	},
+};
+
 static const struct lpg_data pm8916_pwm_data = {
 	.num_channels = 1,
 	.channels = (const struct lpg_channel_data[]) {
@@ -1424,6 +1441,7 @@ static const struct lpg_data pm8350c_pwm_data = {
 };
 
 static const struct of_device_id lpg_of_table[] = {
+	{ .compatible = "qcom,pm660l-lpg", .data = &pm660l_lpg_data },
 	{ .compatible = "qcom,pm8150b-lpg", .data = &pm8150b_lpg_data },
 	{ .compatible = "qcom,pm8150l-lpg", .data = &pm8150l_lpg_data },
 	{ .compatible = "qcom,pm8350c-pwm", .data = &pm8350c_pwm_data },
diff --git a/drivers/leds/trigger/ledtrig-pattern.c b/drivers/leds/trigger/ledtrig-pattern.c
index 43a265dc4696..a11d68143757 100644
--- a/drivers/leds/trigger/ledtrig-pattern.c
+++ b/drivers/leds/trigger/ledtrig-pattern.c
@@ -126,7 +126,8 @@ static int pattern_trig_start_pattern(struct led_classdev *led_cdev)
 
 	if (data->is_hw_pattern) {
 		return led_cdev->pattern_set(led_cdev, data->patterns,
-					     data->npatterns, data->repeat);
+					     data->npatterns,
+					     data->last_repeat);
 	}
 
 	/* At least 2 tuples for software pattern. */
diff --git a/include/drm/msm_drm_notify.h b/include/drm/msm_drm_notify.h
new file mode 100644
index 000000000000..62d395ab33b8
--- /dev/null
+++ b/include/drm/msm_drm_notify.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef _MSM_DRM_NOTIFY_H_
+#define _MSM_DRM_NOTIFY_H_
+
+#include <linux/notifier.h>
+
+/* A hardware display blank change occurred */
+#define MSM_DRM_EVENT_BLANK			0x01
+/* A hardware display blank early change occurred */
+#define MSM_DRM_EARLY_EVENT_BLANK		0x02
+
+#define DRM_EARLY_EVENT_BLANK   0x01
+#define DRM_EVENT_BLANK         0x02
+
+//enum {
+//	/* panel: power on */
+//	MSM_DRM_BLANK_UNBLANK,
+//	/* panel: power off */
+//	MSM_DRM_BLANK_POWERDOWN,
+//};
+
+enum {
+	DRM_BLANK_UNBLANK	= 1,
+	DRM_BLANK_LP1		= 2,
+	DRM_BLANK_LP2		= 3,
+	DRM_BLANK_STANDBY	= 4,
+	DRM_BLANK_SUSPEND	= 5,
+	DRM_BLANK_POWERDOWN	= 6,
+};
+
+enum msm_drm_display_id {
+	/* primary display */
+	MSM_DRM_PRIMARY_DISPLAY,
+	/* external display */
+	MSM_DRM_EXTERNAL_DISPLAY,
+	MSM_DRM_DISPLAY_MAX
+};
+
+struct msm_drm_notifier {
+	enum msm_drm_display_id id;
+	int data;
+};
+
+struct drm_notify_data {
+	bool is_primary;
+	int data;
+};
+
+int msm_drm_register_client(struct notifier_block *nb);
+int msm_drm_unregister_client(struct notifier_block *nb);
+int drm_register_client(struct notifier_block *nb);
+int drm_unregister_client(struct notifier_block *nb);
+int msm_drm_notifier_call_chain(unsigned long val, void *v);
+#endif
diff --git a/scripts/check-local-export b/scripts/check-local-export
index 6ccc2f467416..6bc49d6e3155 100755
--- a/scripts/check-local-export
+++ b/scripts/check-local-export
@@ -32,7 +32,7 @@ exit_code=0
 # Then, the following line will be really simple:
 #   ${NM} --quiet ${1} |
 
-{ ${NM} ${1} 2>/dev/null || { echo "${0}: ${NM} failed" >&2; false; } } |
+{ ${NM} ${1} 2>/dev/null || { echo "${0}: ${NM} failed" >&2; true; } } |
 while read value type name
 do
 	# Skip the line if the number of fields is less than 3.
diff --git a/sm7125-idp.dts b/sm7125-idp.dts
new file mode 120000
index 000000000000..7a058e85148d
--- /dev/null
+++ b/sm7125-idp.dts
@@ -0,0 +1 @@
+qcom/sm7125-idp.dts
\ No newline at end of file
