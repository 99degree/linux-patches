commit fe4b36bfc87cba31216c90603cd7d7fc373cb6d6
Author: root <root@LAPTOP-VDEV89N4.localdomain>
Date:   Mon Aug 1 03:03:29 2022 +0800

    Bringup Redmi Note 9 Pro (joyeuse) smart phone as sm7125-idp.

diff --git a/arch/arm64/boot/dts/qcom/Makefile b/arch/arm64/boot/dts/qcom/Makefile
index f9e6343acd..e1bb7a741a 100644
--- a/arch/arm64/boot/dts/qcom/Makefile
+++ b/arch/arm64/boot/dts/qcom/Makefile
@@ -88,12 +88,14 @@ dtb-$(CONFIG_ARCH_QCOM)	+= sc7280-herobrine-herobrine-r1.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sc7280-idp.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sc7280-idp2.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sc7280-crd.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sm7125-idp.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sdm630-sony-xperia-ganges-kirin.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sdm630-sony-xperia-nile-discovery.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sdm630-sony-xperia-nile-pioneer.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sdm630-sony-xperia-nile-voyager.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sdm632-fairphone-fp3.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sdm636-sony-xperia-ganges-mermaid.dtb
+dtb-$(CONFIG_ARCH_QCOM)	+= sdm636-meizu-E3.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sdm660-xiaomi-lavender.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sdm845-cheza-r1.dtb
 dtb-$(CONFIG_ARCH_QCOM)	+= sdm845-cheza-r2.dtb
diff --git a/arch/arm64/boot/dts/qcom/pm6150l.dtsi b/arch/arm64/boot/dts/qcom/pm6150l.dtsi
index 7aa2ef90cb..5a0594905a 100644
--- a/arch/arm64/boot/dts/qcom/pm6150l.dtsi
+++ b/arch/arm64/boot/dts/qcom/pm6150l.dtsi
@@ -12,6 +12,22 @@ pm6150l_lsid4: pmic@4 {
 		#address-cells = <1>;
 		#size-cells = <0>;
 
+                pm6150l_pon: pon@800 {
+                        compatible = "qcom,pm8998-pon";
+                        reg = <0x800>;
+                        mode-bootloader = <0x2>;
+                        mode-recovery = <0x1>;
+#if 0
+                        pm6150l_pwrkey: pwrkey {
+                                compatible = "qcom,pm8941-pwrkey";
+                                interrupts = <0x0 0x8 0 IRQ_TYPE_EDGE_BOTH>;
+                                debounce = <15625>;
+                                bias-pull-up;
+                                linux,code = <KEY_POWER>;
+                        };
+#endif
+                };
+
 		pm6150l_adc: adc@3100 {
 			compatible = "qcom,spmi-adc5";
 			reg = <0x3100>;
diff --git a/arch/arm64/boot/dts/qcom/sm7125-idp.dts b/arch/arm64/boot/dts/qcom/sm7125-idp.dts
new file mode 100644
index 0000000000..9cc81a97f3
--- /dev/null
+++ b/arch/arm64/boot/dts/qcom/sm7125-idp.dts
@@ -0,0 +1,1156 @@
+// SPDX-License-Identifier: BSD-3-Clause
+/*
+ * SC7180 IDP board device tree source
+ *
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/regulator/qcom,rpmh-regulator.h>
+#include <dt-bindings/pinctrl/qcom,pmic-gpio.h>
+#include "sc7180.dtsi"
+#include "pm6150.dtsi"
+#include "pm6150l.dtsi"
+
+/ {
+	model = "Qualcomm Technologies, Inc. SM7125 IDP";
+	compatible = "qcom,sm7125", "qcom,sc7180-idp", "qcom,sc7180";
+        qcom,board-id = <0x50022 0x01>;
+        qcom,msm-id = <0x1bb 0x00>;
+        qcom,msm-name = "ATOLL-AB";
+        qcom,pmic-name = "PM6150";
+
+	aliases {
+		bluetooth0 = &bluetooth;
+		hsuart0 = &uart3;
+		serial0 = &uart8;
+		wifi0 = &wifi;
+	};
+
+        chosen {
+                #address-cells = <2>;
+                #size-cells = <2>;
+                ranges;
+
+                stdout-path = "serial0:115200n8";
+
+                framebuffer: framebuffer@9c000000 {
+                        compatible = "drm-simple-framebuffer", "simple-framebuffer";
+                        reg = <0 0x9c000000 0 0x1700000>;
+                        width = <1080>;
+                        height = <2400>;
+                        stride = <(1080 * 4)>;
+                        format = "a8r8g8b8";
+
+                        /*
+                         * That's a lot of clocks, but it's necessary due
+                         * to unused clk cleanup & no panel driver yet..
+                         */
+#if 0
+                        clocks = <&gcc GCC_DISP_AHB_CLK>,
+                                 <&gcc GCC_DISP_HF_AXI_CLK>,
+                                 <&gcc GCC_DISP_THROTTLE_CORE_CLK>,
+                                 <&gcc GCC_DISP_GPLL0_DIV_CLK_SRC>;
+#endif
+                };
+        };
+};
+
+&CPU0 { compatible = "qcom,kryo465"; };
+&CPU1 { compatible = "qcom,kryo465"; };
+&CPU2 { compatible = "qcom,kryo465"; };
+&CPU3 { compatible = "qcom,kryo465"; };
+&CPU4 { compatible = "qcom,kryo465"; };
+&CPU5 { compatible = "qcom,kryo465"; };
+&CPU6 { compatible = "qcom,kryo465"; };
+&CPU7 { compatible = "qcom,kryo465"; };
+
+/*
+ * Reserved memory changes
+ *
+ * Delete all unused memory nodes and define the peripheral memory regions
+ * required by the board dts.
+ *
+ */
+
+/* Increase the size from 2MB to 8MB */
+&rmtfs_mem {
+	reg = <0x0 0x94600000 0x0 0x800000>;
+};
+
+///delete-node/ &rmtfs_mem;
+/delete-node/ &ipa_fw_mem;
+
+/ {
+	reserved-memory {
+/*joyeuse
+@1:0x800000                      adsp_mem = "/reserved-memory/adsp_region";
+@0                      reserved_memory = "/reserved-memory";
+@2:0x1000000                      qseecom_ta_mem = "/reserved-memory/qseecom_ta_region";
+@3:0x8c00000                      secure_display_memory = "/reserved-memory/secure_display_region";
+@80000000";0x600000             hyp_region = "/reserved-memory/hyp_region
+@80700000";0x140000             xbl_aop_mem = "/reserved-memory/xbl_aop_mem
+@808ff000";0x1000             sec_apps_mem = "/reserved-memory/sec_apps_region
+@80900000";0x200000             smem_region = "/reserved-memory/smem
+@80b00000";0x3900000             removed_region = "/reserved-memory/removed_region
+@86000000";0x8400000             pil_modem_mem = "/reserved-memory/modem_region
+@8e400000";0x500000             pil_camera_mem = "/reserved-memory/camera_region
+@8e900000";0x500000             pil_npu_mem = "/reserved-memory/pil_npu_region
+@8ee00000";0x500000             pil_video_mem = "/reserved-memory/pil_video_region
+@8f300000";0x1e00000             pil_cdsp_mem = "/reserved-memory/cdsp_regions
+@91100000";0x2800000             pil_adsp_mem = "/reserved-memory/pil_adsp_region
+@93900000";0x200000             wlan_fw_mem = "/reserved-memory/wlan_fw_region
+@93b00000":0x10000             pil_ipa_fw_mem = "/reserved-memory/ipa_fw_region
+@93b10000";0x5000             pil_ipa_gsi_mem = "/reserved-memory/ipa_gsi_region
+@93b15000";0x2000             pil_gpu_mem = "/reserved-memory/gpu_region
+@9c000000";0x1700000           cont_splash_memory = "/reserved-memory/cont_splash_region
+@9d700000";0x100000             dfps_data_memory = "/reserved-memory/dfps_data_region
+@9e000000";0x1400000             qseecom_mem = "/reserved-memory/qseecom_region
+@9f400000";0x1e00000           cdsp_sec_mem = "/reserved-memory/cdsp_sec_regions
+*/
+
+		/*
+		sc7180 arrangement:
+			xbl_mem arranged 0x80600000-0x80800000
+			aop_mem arranged 0x80800000-0x80820000
+
+		which is equivlent to joyeuse
+			@80600000-80700000	joyeuse@available to sc7180@xbl_mem (80600000:200000)
+			@80700000";0x140000             xbl_aop_mem = "/reserved-memory/xbl_aop_mem
+
+		====
+
+		sc7180:
+			sec_apps_mem: memory@808ff000 { //size 0x1000
+			@808ff000";0x1000             sec_apps_mem = "/reserved-memory/sec_apps_region
+		joyeuse:
+			sec_apps_mem = "/reserved-memory/sec_apps_region		
+
+		====
+		sc7180:
+			smem_mem: memory@80900000 {
+		joyeuse:
+			smem_region = "/reserved-memory/smem
+
+		*/
+
+
+		/*
+		sc7180:
+			tz_mem: memory@80b00000 {
+		joyeuse:
+			removed_region = "/reserved-memory/removed_region
+
+		*/
+
+		atf_mem: memory@80b00000 {
+			reg = <0x0 0x80b00000 0x0 0x100000>;
+			no-map;
+		};
+
+		/*
+		joyeuse:
+			@86000000";0x8400000             pil_modem_mem = "/reserved-memory/modem_region
+
+			@86000000 till 0x8E400000
+		sc7180:
+			@86000000 till 0x8EC00000
+		*/
+		mpss_mem: memory@86000000 {
+			reg = <0x0 0x86000000 0x0 0x8400000>;
+			no-map;
+		};
+
+		/*
+		joyeuse:
+			@8e400000";0x500000             pil_camera_mem = "/reserved-memory/camera_region
+		sc7180:
+			0x0 0x8ec00000 0x0 0x500000
+	
+		*/
+		camera_mem: memory@8e400000 {
+			reg = <0x0 0x8e400000 0x0 0x500000>;
+			no-map;
+		};
+
+		/* TODO:check
+		joyeuse:
+			@8ee00000";0x500000             pil_video_mem = "/reserved-memory/pil_video_region
+		sc7180:
+			reg = <0 0x8f600000 0 0x500000>;
+		*/
+		venus_mem: memory@8ee00000 {
+			reg = <0 0x8ee00000 0 0x500000>;
+			no-map;
+		};
+
+		/*
+			@8f300000";0x1e00000             pil_cdsp_mem = "/reserved-memory/cdsp_regions
+		*/
+                cdsp_mem: memory@8f300000 {
+                        reg = <0x0 0x8f300000 0x0 0x1e00000>;
+                        no-map;
+                };
+
+		/*
+			@91100000";0x2800000             pil_adsp_mem = "/reserved-memory/pil_adsp_region
+		*/
+                adsp_mem: memory@91100000 {
+                        reg = <0x0 0x91100000 0x0 0x2800000>;
+                        no-map;
+                };
+
+                /*
+                joyeuse:
+                        @93900000";0x200000             wlan_fw_mem = "/reserved-memory/wlan_fw_region
+                sc7180:
+                        reg = <0x0 0x94100000 0x0 0x200000>;
+                */
+                wlan_mem: memory@93900000 {
+                        reg = <0x0 0x93900000 0x0 0x200000>;
+                        no-map;
+                };
+
+		/*
+			@93b00000":0x10000             pil_ipa_fw_mem = "/reserved-memory/ipa_fw_region
+			@93b10000";0x5000             pil_ipa_gsi_mem = "/reserved-memory/ipa_gsi_region
+		sc7180:
+			memory@8b700000 (0x000000008b700000--0x000000008b710000)
+		*/
+		ipa_fw_mem: memory@93b00000 {
+                        reg = <0x0 0x93b00000 0x0 0x15000>;
+                        no-map;
+                };
+
+
+		/*
+			@93b15000";0x2000             pil_gpu_mem = "/reserved-memory/gpu_region
+		*/
+                gpu_mem: memory@93b15000 {
+                        reg = <0x0 0x93b15000 0x0 0x2000>;
+                        no-map;
+                };
+
+                //TODO:
+                mba_mem: memory@94400000 {
+                        reg = <0x0 0x94400000 0x0 0x200000>;
+                        no-map;
+                };
+
+		/*
+			@9c000000";0x1700000           cont_splash_memory = "/reserved-memory/cont_splash_region
+		*/
+		splash_mem: memory@9c000000 {
+                        reg = <0x0 0x9c000000 0x0 0x1700000>;
+                        no-map;
+                };
+
+		/*
+			@9d700000";0x100000             dfps_data_memory = "/reserved-memory/dfps_data_region
+		*/
+                dfps_data_mem: memory@9d700000 {
+                        reg = <0x0 0x9d700000 0x0 0x100000>;
+                        no-map;
+                };
+
+	        ramoops_mem: ramoops@9d800000 {
+			compatible = "ramoops";
+			reg = <0x0 0x9d800000 0x0 0x00400000>;
+
+			record-size = <0x80000>;
+	                pmsg-size = <0x200000>;
+			console-size = <0x100000>;
+			mem-type = <1>;
+	        };
+
+		/*
+			@9e000000";0x1400000             qseecom_mem = "/reserved-memory/qseecom_region
+		*/
+		qseecom_mem: memory@9e000000 {
+                        reg = <0x0 0x9e000000 0x0 0x1400000>;
+                        no-map;
+                };
+
+		/*
+			@9f400000";0x1e00000           cdsp_sec_mem = "/reserved-memory/cdsp_sec_regions
+		*/
+		cdsp_sec_mem: memory@9f400000 {
+                        reg = <0x0 0x9f400000 0x0 0x1e00000>;
+                        no-map;
+                };
+#if 0
+                protect_mem: memory@80000000 {
+                        reg = <0x0 0x80000000 0x0 0x21200000>;
+                        no-map;
+                };
+#endif
+	};
+};
+
+&apps_rsc {
+	pm6150-rpmh-regulators {
+		compatible = "qcom,pm6150-rpmh-regulators";
+		qcom,pmic-id = "a";
+
+		vreg_s1a_1p1: smps1 {
+			regulator-min-microvolt = <1128000>;
+			regulator-max-microvolt = <1128000>;
+		};
+
+		vreg_s4a_1p0: smps4 {
+			regulator-min-microvolt = <824000>;
+			regulator-max-microvolt = <1120000>;
+		};
+
+		vreg_s5a_2p0: smps5 {
+			regulator-min-microvolt = <1744000>;
+			regulator-max-microvolt = <2040000>;
+		};
+
+		vreg_l1a_1p2: ldo1 {
+			regulator-min-microvolt = <1178000>;
+			regulator-max-microvolt = <1256000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l2a_1p0: ldo2 {
+			regulator-min-microvolt = <944000>;
+			regulator-max-microvolt = <1056000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l3a_1p0: ldo3 {
+			regulator-min-microvolt = <968000>;
+			regulator-max-microvolt = <1064000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l4a_0p8: ldo4 {
+			regulator-min-microvolt = <824000>;
+			regulator-max-microvolt = <928000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l5a_2p7: ldo5 {
+			regulator-min-microvolt = <2496000>;
+			regulator-max-microvolt = <3000000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l6a_0p6: ldo6 {
+			regulator-min-microvolt = <568000>;
+			regulator-max-microvolt = <648000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l9a_0p6: ldo9 {
+			regulator-min-microvolt = <488000>;
+			regulator-max-microvolt = <800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l10a_1p8: ldo10 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1832000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l11a_1p8: ldo11 {
+			regulator-min-microvolt = <1696000>;
+			regulator-max-microvolt = <1904000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l12a_1p8: ldo12 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l13a_1p8: ldo13 {
+			regulator-min-microvolt = <1696000>;
+			regulator-max-microvolt = <1904000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l14a_1p8: ldo14 {
+			regulator-min-microvolt = <1728000>;
+			regulator-max-microvolt = <1832000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l15a_1p8: ldo15 {
+			regulator-min-microvolt = <1696000>;
+			regulator-max-microvolt = <1904000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l16a_2p7: ldo16 {
+			regulator-min-microvolt = <2496000>;
+			regulator-max-microvolt = <3304000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l17a_3p0: ldo17 {
+			regulator-min-microvolt = <2920000>;
+			regulator-max-microvolt = <3232000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l18a_2p8: ldo18 {
+			regulator-min-microvolt = <2496000>;
+			regulator-max-microvolt = <3304000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l19a_2p9: ldo19 {
+			regulator-min-microvolt = <2960000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+	};
+
+	pm6150l-rpmh-regulators {
+		compatible = "qcom,pm6150l-rpmh-regulators";
+		qcom,pmic-id = "c";
+
+		vreg_s8c_1p3: smps8 {
+			regulator-min-microvolt = <1120000>;
+			regulator-max-microvolt = <1408000>;
+		};
+
+		vreg_l1c_1p8: ldo1 {
+			regulator-min-microvolt = <1616000>;
+			regulator-max-microvolt = <1984000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l2c_1p3: ldo2 {
+			regulator-min-microvolt = <1168000>;
+			regulator-max-microvolt = <1304000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l3c_1p2: ldo3 {
+			regulator-min-microvolt = <1144000>;
+			regulator-max-microvolt = <1304000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l4c_1p8: ldo4 {
+			regulator-min-microvolt = <1648000>;
+			regulator-max-microvolt = <3304000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l5c_1p8: ldo5 {
+			regulator-min-microvolt = <1648000>;
+			regulator-max-microvolt = <3304000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l6c_2p9: ldo6 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <2950000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l7c_3p0: ldo7 {
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3312000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l8c_1p8: ldo8 {
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1904000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l9c_2p9: ldo9 {
+			regulator-min-microvolt = <2960000>;
+			regulator-max-microvolt = <2960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_HPM>;
+		};
+
+		vreg_l10c_3p3: ldo10 {
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3400000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_l11c_3p3: ldo11 {
+			regulator-min-microvolt = <3000000>;
+			regulator-max-microvolt = <3400000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_LPM>;
+		};
+
+		vreg_bob: bob {
+			regulator-min-microvolt = <3008000>;
+			regulator-max-microvolt = <3960000>;
+			regulator-initial-mode = <RPMH_REGULATOR_MODE_AUTO>;
+		};
+	};
+};
+
+&dsi0 {
+	status = "okay";
+
+	vdda-supply = <&vreg_l3c_1p2>;
+
+	panel@0 {
+		//compatible = "visionox,rm69299-1080p-display";
+		compatible = "mdss,nt36675-tianma";
+
+		reg = <0>;
+
+		vdda-supply = <&vreg_l8c_1p8>;
+		vdd3p3-supply = <&vreg_l18a_2p8>;
+
+		/* display_sde.dtsi
+                vddio-supply = <&L13A>;
+                vdda-3p3-supply = <&L18A>;
+                lab-supply = <&lcdb_ldo_vreg>;
+                ibb-supply = <&lcdb_ncp_vreg>;
+		*/
+
+		/* cust_sde.dtsi
+		/delete-property/ vdda-3p3-supply;
+	        vddio-supply = <&L18A>;
+		*/
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&disp_pins>;
+
+		reset-gpios = <&pm6150l_gpio 3 GPIO_ACTIVE_HIGH>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+				reg = <0>;
+				panel0_in: endpoint {
+					remote-endpoint = <&dsi0_out>;
+				};
+			};
+		};
+	};
+
+	ports {
+		port@1 {
+			endpoint {
+				remote-endpoint = <&panel0_in>;
+				data-lanes = <0 1 2 3>;
+			};
+		};
+	};
+};
+
+&dsi_phy {
+	status = "okay";
+};
+
+&mdp {
+	status = "okay";
+};
+
+&mdss {
+	status = "okay";
+};
+
+&adreno_smmu {
+	status = "okay";
+};
+
+&gpu {
+	status = "okay";
+	zap-shader {
+		memory-region = <&gpu_mem>;
+		//firmware-name = "qcom/a630_zap.mbn";
+	};
+};
+
+&gmu {
+        status = "okay";
+};
+
+&apps_smmu {
+	status = "okay";
+};
+
+/* override with sm7125 own addr */
+&qfprom {
+	status = "disabled";
+};
+
+&soc {
+	qfprom0: efuse@780000 {
+		compatible = "qcom,sm7125-qfprom", "qcom,qfprom";
+		reg = <0 0x00780000 0 0x6310>;
+		status = "okay";
+
+                clocks = <&gcc GCC_SEC_CTRL_CLK_SRC>;
+                clock-names = "core";
+                #address-cells = <1>;
+                #size-cells = <1>;
+
+                vcc-supply = <&vreg_l11a_1p8>;
+
+	        qusb2_hstx_trim_new: hstx-trim@258 {
+			reg = <0x258 0x1>;
+			bits = <25 3>;
+	        };
+
+		/* 0x780000 0x6300 */
+                gpu_speed_bin_new: gpu_speed_bin@6300 {
+			reg = <0x6015 0x1>;
+			bits = <0 8>;
+                };
+	};
+};
+
+/* reassign nvmem cell */
+&usb_1_hsphy {
+	status = "okay";
+	nvmem-cells = <&qusb2_hstx_trim_new>;
+}; 
+
+/* reassign nvmem cell */
+&gpu {
+        status = "okay";
+        nvmem-cells = <&gpu_speed_bin_new>;
+};	
+
+&qspi {
+	status = "okay";
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&qspi_clk &qspi_cs0 &qspi_data01>;
+
+	flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <25000000>;
+		spi-tx-bus-width = <2>;
+		spi-rx-bus-width = <2>;
+
+		status = "disabled";
+	};
+};
+
+&qupv3_id_0 {
+	status = "okay";
+};
+
+&qupv3_id_1 {
+	status = "okay";
+};
+
+&remoteproc_mpss {
+	status = "okay";
+	compatible = "qcom,sc7180-mss-pil";
+	iommus = <&apps_smmu 0x461 0x0>, <&apps_smmu 0x444 0x3>;
+	memory-region = <&mba_mem &mpss_mem>;
+};
+
+&sdhc_1 {
+	status = "disabled";
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&sdc1_on>;
+	pinctrl-1 = <&sdc1_off>;
+	vmmc-supply = <&vreg_l19a_2p9>;
+	vqmmc-supply = <&vreg_l12a_1p8>;
+};
+
+&sdhc_2 {
+	status = "disabled";
+
+	pinctrl-names = "default","sleep";
+	pinctrl-0 = <&sdc2_on>;
+	pinctrl-1 = <&sdc2_off>;
+	vmmc-supply  = <&vreg_l9c_2p9>;
+	vqmmc-supply = <&vreg_l6c_2p9>;
+
+	cd-gpios = <&tlmm 69 GPIO_ACTIVE_LOW>;
+};
+
+&uart3 {
+	status = "disabled";
+
+	/delete-property/interrupts;
+	interrupts-extended = <&intc GIC_SPI 604 IRQ_TYPE_LEVEL_HIGH>,
+				<&tlmm 41 IRQ_TYPE_EDGE_FALLING>;
+
+	pinctrl-names = "default", "sleep";
+	pinctrl-1 = <&qup_uart3_sleep>;
+
+	bluetooth: wcn3990-bt {
+		compatible = "qcom,wcn3990-bt";
+		vddio-supply = <&vreg_l10a_1p8>;
+		vddxo-supply = <&vreg_l1c_1p8>;
+		vddrf-supply = <&vreg_l2c_1p3>;
+		vddch0-supply = <&vreg_l10c_3p3>;
+		max-speed = <3200000>;
+		status = "disabled";
+	};
+};
+
+&uart8 {
+	status = "okay";
+};
+
+&usb_1 {
+	status = "okay";
+	qcom,select-utmi-as-pipe-clk;
+};
+
+&usb_1_dwc3 {
+	/delete-property/ snps,dis_enblslpm_quirk;
+
+	status = "okay";
+
+	//dr_mode = "peripherial";
+	dr_mode = "peripheral";
+
+	snps,hird-threshold = /bits/ 8 <0x10>;
+	snps,usb2-gadget-lpm-disable;
+	snps,dis_u2_susphy_quirk;
+	snps,is-utmi-l1-suspend;
+	snps,dis-u1-entry-quirk;
+	snps,dis-u2-entry-quirk;
+	snps,usb3_lpm_capable;
+	snps,has-lpm-erratum;
+	tx-fifo-resize;
+
+
+        maximum-speed = "high-speed";
+
+};
+
+&usb_1_hsphy {
+	status = "okay";
+
+	vdd-supply = <&vreg_l4a_0p8>;
+	vdda-pll-supply = <&vreg_l11a_1p8>;
+	vdda-phy-dpdm-supply = <&vreg_l17a_3p0>;
+	qcom,imp-res-offset-value = <8>;
+	qcom,preemphasis-level = <QUSB2_V2_PREEMPHASIS_15_PERCENT>;
+	qcom,preemphasis-width = <QUSB2_V2_PREEMPHASIS_WIDTH_HALF_BIT>;
+	qcom,bias-ctrl-value = <0x22>;
+	qcom,charge-ctrl-value = <3>;
+	qcom,hsdisc-trim-value = <0>;
+};
+
+&usb_1_qmpphy {
+	status = "okay";
+	vdda-phy-supply = <&vreg_l3c_1p2>;
+	vdda-pll-supply = <&vreg_l4a_0p8>;
+};
+
+&venus {
+	status = "okay";
+	status = "disabled";
+	video-firmware {
+		iommus = <&apps_smmu 0x0c42 0x0>;
+	};
+};
+
+&wifi {
+	status = "okay";
+
+	vdd-0.8-cx-mx-supply = <&vreg_l9a_0p6>;
+	vdd-1.8-xo-supply = <&vreg_l1c_1p8>;
+	vdd-1.3-rfa-supply = <&vreg_l2c_1p3>;
+	vdd-3.3-ch0-supply = <&vreg_l10c_3p3>;
+	vdd-3.3-ch1-supply = <&vreg_l11c_3p3>;
+	wifi-firmware {
+		iommus = <&apps_smmu 0xc2 0x1>;
+	};
+};
+
+/* PINCTRL - additions to nodes defined in sc7180.dtsi */
+
+&pm6150l_gpio {
+	disp_pins: disp-pins {
+		pinconf {
+			pins = "gpio3";
+			function = PMIC_GPIO_FUNC_FUNC1;
+			qcom,drive-strength = <PMIC_GPIO_STRENGTH_MED>;
+			power-source = <0>;
+			bias-disable;
+			output-low;
+		};
+	};
+};
+
+&qspi_clk {
+	pinconf {
+		pins = "gpio63";
+		bias-disable;
+	};
+};
+
+&qspi_cs0 {
+	pinconf {
+		pins = "gpio68";
+		bias-disable;
+	};
+};
+
+&qspi_data01 {
+	pinconf {
+		pins = "gpio64", "gpio65";
+
+		/* High-Z when no transfers; nice to park the lines */
+		bias-pull-up;
+	};
+};
+
+&qup_i2c2_default {
+	pinconf {
+		pins = "gpio15", "gpio16";
+		drive-strength = <2>;
+
+		/* Has external pullup */
+		bias-disable;
+	};
+};
+
+&qup_i2c4_default {
+	pinconf {
+		pins = "gpio115", "gpio116";
+		drive-strength = <2>;
+
+		/* Has external pullup */
+		bias-disable;
+	};
+};
+
+&qup_i2c7_default {
+	pinconf {
+		pins = "gpio6", "gpio7";
+		drive-strength = <2>;
+
+		/* Has external pullup */
+		bias-disable;
+	};
+};
+
+&qup_i2c9_default {
+	pinconf {
+		pins = "gpio46", "gpio47";
+		drive-strength = <2>;
+
+		/* Has external pullup */
+		bias-disable;
+	};
+};
+
+&qup_uart3_default {
+	pinconf-cts {
+		/*
+		 * Configure a pull-down on CTS to match the pull of
+		 * the Bluetooth module.
+		 */
+		pins = "gpio38";
+		bias-pull-down;
+	};
+
+	pinconf-rts {
+		/* We'll drive RTS, so no pull */
+		pins = "gpio39";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	pinconf-tx {
+		/* We'll drive TX, so no pull */
+		pins = "gpio40";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	pinconf-rx {
+		/*
+		 * Configure a pull-up on RX. This is needed to avoid
+		 * garbage data when the TX pin of the Bluetooth module is
+		 * in tri-state (module powered off or not driving the
+		 * signal yet).
+		 */
+		pins = "gpio41";
+		bias-pull-up;
+	};
+};
+
+&qup_uart8_default {
+	pinconf-tx {
+		pins = "gpio44";
+		drive-strength = <2>;
+		bias-disable;
+	};
+
+	pinconf-rx {
+		pins = "gpio45";
+		drive-strength = <2>;
+		bias-pull-up;
+	};
+};
+
+&qup_spi0_default {
+	pinconf {
+		pins = "gpio34", "gpio35", "gpio36", "gpio37";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
+
+&qup_spi6_default {
+	pinconf {
+		pins = "gpio59", "gpio60", "gpio61", "gpio62";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
+
+&qup_spi10_default {
+	pinconf {
+		pins = "gpio86", "gpio87", "gpio88", "gpio89";
+		drive-strength = <2>;
+		bias-disable;
+	};
+};
+
+&tlmm {
+	qup_uart3_sleep: qup-uart3-sleep {
+		pinmux {
+			pins = "gpio38", "gpio39",
+			       "gpio40", "gpio41";
+			function = "gpio";
+		};
+
+		pinconf-cts {
+			/*
+			 * Configure a pull-down on CTS to match the pull of
+			 * the Bluetooth module.
+			 */
+			pins = "gpio38";
+			bias-pull-down;
+		};
+
+		pinconf-rts {
+			/*
+			 * Configure pull-down on RTS. As RTS is active low
+			 * signal, pull it low to indicate the BT SoC that it
+			 * can wakeup the system anytime from suspend state by
+			 * pulling RX low (by sending wakeup bytes).
+			 */
+			 pins = "gpio39";
+			 bias-pull-down;
+		};
+
+		pinconf-tx {
+			/*
+			 * Configure pull-up on TX when it isn't actively driven
+			 * to prevent BT SoC from receiving garbage during sleep.
+			 */
+			pins = "gpio40";
+			bias-pull-up;
+		};
+
+		pinconf-rx {
+			/*
+			 * Configure a pull-up on RX. This is needed to avoid
+			 * garbage data when the TX pin of the Bluetooth module
+			 * is floating which may cause spurious wakeups.
+			 */
+			pins = "gpio41";
+			bias-pull-up;
+		};
+	};
+
+	sdc1_on: sdc1-on {
+		pinconf-clk {
+			pins = "sdc1_clk";
+			bias-disable;
+			drive-strength = <16>;
+		};
+
+		pinconf-cmd {
+			pins = "sdc1_cmd";
+			bias-pull-up;
+			drive-strength = <10>;
+		};
+
+		pinconf-data {
+			pins = "sdc1_data";
+			bias-pull-up;
+			drive-strength = <10>;
+		};
+
+		pinconf-rclk {
+			pins = "sdc1_rclk";
+			bias-pull-down;
+		};
+	};
+
+	sdc1_off: sdc1-off {
+		pinconf-clk {
+			pins = "sdc1_clk";
+			bias-disable;
+			drive-strength = <2>;
+		};
+
+		pinconf-cmd {
+			pins = "sdc1_cmd";
+			bias-pull-up;
+			drive-strength = <2>;
+		};
+
+		pinconf-data {
+			pins = "sdc1_data";
+			bias-pull-up;
+			drive-strength = <2>;
+		};
+
+		pinconf-rclk {
+			pins = "sdc1_rclk";
+			bias-pull-down;
+		};
+	};
+
+	sdc2_on: sdc2-on {
+		pinconf-clk {
+			pins = "sdc2_clk";
+			bias-disable;
+			drive-strength = <16>;
+		};
+
+		pinconf-cmd {
+			pins = "sdc2_cmd";
+			bias-pull-up;
+			drive-strength = <10>;
+		};
+
+		pinconf-data {
+			pins = "sdc2_data";
+			bias-pull-up;
+			drive-strength = <10>;
+		};
+
+		pinconf-sd-cd {
+			pins = "gpio69";
+			bias-pull-up;
+			drive-strength = <2>;
+		};
+	};
+
+	sdc2_off: sdc2-off {
+		pinconf-clk {
+			pins = "sdc2_clk";
+			bias-disable;
+			drive-strength = <2>;
+		};
+
+		pinconf-cmd {
+			pins = "sdc2_cmd";
+			bias-pull-up;
+			drive-strength = <2>;
+		};
+
+		pinconf-data {
+			pins = "sdc2_data";
+			bias-pull-up;
+			drive-strength = <2>;
+		};
+
+		pinconf-sd-cd {
+			pins = "gpio69";
+			bias-pull-up;
+			drive-strength = <2>;
+		};
+	};
+};
+
+&ipa {
+        status = "okay";
+        modem-init;
+};
+
+#if 0
+/* Below are one-liner control status */
+&spi0      { status = "disabled"; };
+&spi1      { status = "disabled"; };
+&spi3      { status = "disabled"; };
+&spi5      { status = "disabled"; };
+&spi6      { status = "disabled"; };
+&spi8      { status = "disabled"; };
+
+&i2c1      { status = "disabled"; };
+&i2c2      { status = "disabled"; };
+&i2c3      { status = "disabled"; };
+&i2c5      { status = "disabled"; };
+&i2c6      { status = "disabled"; };
+&i2c7      { status = "disabled"; };
+&i2c8      { status = "disabled"; };
+&i2c10     { status = "disabled"; };
+&i2c11     { status = "disabled"; };
+
+&uart0    { status = "disabled" ;};
+&uart1    { status = "disabled" ;};
+&uart2    { status = "disabled" ;};
+&uart3    { status = "disabled" ;}; //enabled default to bt
+&uart4    { status = "disabled" ;};
+&uart5    { status = "disabled" ;};
+&uart6    { status = "disabled" ;};
+&uart7    { status = "disabled" ;};
+&uart8    { status = "disabled" ;}; //enabled not sure for what
+&uart9    { status = "disabled" ;};
+&uart10   { status = "disabled" ;};
+&uart11   { status = "disabled" ;};
+#endif
+
+//&qspi { status = "disabled"; };
+//&qupv3_id_0 { status = "disabled"; };
+//&qupv3_id_1 { status = "disabled"; };
+
+///{ smp2p-mpss { status = "disabled" ;}; };
+///{ smp2p-lpass { status = "disabled" ;}; };
+///{ smp2p-cdsp { status = "disabled" ;}; };
+
+//&qfprom0 { status = "disabled" ;};
+//&soc { cpufreq@18323000 { status = "disabled" ;};      };
+
+//&dsi_phy { status = "disabled"; };
+//&mdp { status = "disabled"; };
+//&mdss { status = "disabled"; };
+//&adreno_smmu { status = "disabled"; };
+//&gpu { status = "disabled"; };
+//&gmu { status = "disabled"; };
+//&apps_smmu { status = "disabled"; };
+//&venus { status = "disabled"; };
+&framebuffer { status = "disabled"; };
+
+//&ipa { status = "disabled"; };
+/delete-node/ &rmtfs_mem ;
+//&wifi { status = "disabled"; };
+
+//&usb_1 {status = "disabled";};
+//&usb_1_dwc3 {status = "disabled";};
+//&usb_1_hsphy {status = "disabled"; };
+
+/* boot blocking obstacle, atoll soc does not handle this addr as clk */
+//&soc { clock-controller@63000000       { status = "disabled" ;};      };
+&lpass_hm { status = "disabled" ;}; //same as above
+/**************************/
+
+//&soc { clock-controller@62d00000       { status = "disabled" ;};      };
+//&soc { clock-controller@af00000        { status = "disabled" ;};      };
+
+//&soc { clock-controller@ad00000        { status = "disabled" ;};      };
+//&soc { clock-controller@ab00000        { status = "disabled" ;};      };
+//&soc { clock-controller@5090000        { status = "disabled" ;};      };
+//&soc { geniqup@ac0000                  { status = "disabled" ;};      };
+//&soc { geniqup@8c0000                  { status = "disabled" ;};      };
diff --git a/drivers/gpu/drm/msm/adreno/adreno_device.c b/drivers/gpu/drm/msm/adreno/adreno_device.c
index 8706bcdd14..ae27780ff8 100644
--- a/drivers/gpu/drm/msm/adreno/adreno_device.c
+++ b/drivers/gpu/drm/msm/adreno/adreno_device.c
@@ -259,11 +259,12 @@ static const struct adreno_info gpulist[] = {
 		.name = "A618",
 		.fw = {
 			[ADRENO_FW_SQE] = "a630_sqe.fw",
-			[ADRENO_FW_GMU] = "a630_gmu.bin",
+			[ADRENO_FW_GMU] = "a618_gmu.bin",
 		},
 		.gmem = SZ_512K,
 		.inactive_period = DRM_MSM_INACTIVE_PERIOD,
 		.init = a6xx_gpu_init,
+		.zapfw = "a615_zap.mdt",
 	}, {
 		.rev = ADRENO_REV(6, 3, 0, ANY_ID),
 		.revn = 630,
@@ -355,6 +356,10 @@ MODULE_FIRMWARE("qcom/a530_zap.mdt");
 MODULE_FIRMWARE("qcom/a530_zap.b00");
 MODULE_FIRMWARE("qcom/a530_zap.b01");
 MODULE_FIRMWARE("qcom/a530_zap.b02");
+MODULE_FIRMWARE("qcom/a615_zap.mdt");
+MODULE_FIRMWARE("qcom/a615_zap.b00");
+MODULE_FIRMWARE("qcom/a615_zap.b01");
+MODULE_FIRMWARE("qcom/a615_zap.b02");
 MODULE_FIRMWARE("qcom/a630_sqe.fw");
 MODULE_FIRMWARE("qcom/a630_gmu.bin");
 MODULE_FIRMWARE("qcom/a630_zap.mbn");
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 5740911f63..74039cd382 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -8,6 +8,9 @@ obj-$(CONFIG_DRM_PANEL_BOE_TV101WUM_NL6) += panel-boe-tv101wum-nl6.o
 obj-$(CONFIG_DRM_PANEL_DSI_CM) += panel-dsi-cm.o
 obj-$(CONFIG_DRM_PANEL_LVDS) += panel-lvds.o
 obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-simple.o
+obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-s6d6ft0-tianma-fhd.o
+obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-k9d-36-02-0a-dsc.o
+obj-$(CONFIG_DRM_PANEL_SIMPLE) += panel-nt36675-tianma.o
 obj-$(CONFIG_DRM_PANEL_EDP) += panel-edp.o
 obj-$(CONFIG_DRM_PANEL_ELIDA_KD35T133) += panel-elida-kd35t133.o
 obj-$(CONFIG_DRM_PANEL_FEIXIN_K101_IM2BA02) += panel-feixin-k101-im2ba02.o
@@ -62,7 +65,10 @@ obj-$(CONFIG_DRM_PANEL_SITRONIX_ST7701) += panel-sitronix-st7701.o
 obj-$(CONFIG_DRM_PANEL_SITRONIX_ST7703) += panel-sitronix-st7703.o
 obj-$(CONFIG_DRM_PANEL_SITRONIX_ST7789V) += panel-sitronix-st7789v.o
 obj-$(CONFIG_DRM_PANEL_SONY_ACX565AKM) += panel-sony-acx565akm.o
+obj-$(CONFIG_DRM_PANEL_SONY_DISCOVERY_TD4322_INNOLUX) += panel-td4322-innolux-fhd.o
+obj-$(CONFIG_DRM_PANEL_SONY_PIONEER_TD4322_TRULY) += panel-td4322-truly-fhd.o
 obj-$(CONFIG_DRM_PANEL_SONY_TULIP_TRULY_NT35521) += panel-sony-tulip-truly-nt35521.o
+obj-$(CONFIG_DRM_PANEL_SONY_VOYAGER_TD4328_TIANMA) += panel-td4328-tianma-fhdplus.o
 obj-$(CONFIG_DRM_PANEL_TDO_TL070WSH30) += panel-tdo-tl070wsh30.o
 obj-$(CONFIG_DRM_PANEL_TPO_TD028TTEC1) += panel-tpo-td028ttec1.o
 obj-$(CONFIG_DRM_PANEL_TPO_TD043MTEA1) += panel-tpo-td043mtea1.o
diff --git a/drivers/gpu/drm/panel/panel-k9d-36-02-0a-dsc.c b/drivers/gpu/drm/panel/panel-k9d-36-02-0a-dsc.c
new file mode 100644
index 0000000000..cfe3e8221e
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-k9d-36-02-0a-dsc.c
@@ -0,0 +1,483 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2022 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/backlight.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct k9d_36_02_0a_dsc {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline
+struct k9d_36_02_0a_dsc *to_k9d_36_02_0a_dsc(struct drm_panel *panel)
+{
+	return container_of(panel, struct k9d_36_02_0a_dsc, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void k9d_36_02_0a_dsc_reset(struct k9d_36_02_0a_dsc *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(11000, 12000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(11000, 12000);
+}
+
+static int k9d_36_02_0a_dsc_on(struct k9d_36_02_0a_dsc *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	dsi_dcs_write_seq(dsi, 0xba,
+			  0x01, 0xe6, 0x00, 0x10, 0x00, 0x30, 0x00, 0x01);
+	dsi_dcs_write_seq(dsi, 0xb2, 0x58);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x02);
+	dsi_dcs_write_seq(dsi, 0xb2, 0x0c, 0x0c);
+	dsi_dcs_write_seq(dsi, 0xbe, 0x0e, 0x0b, 0x14, 0x13);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x05);
+	dsi_dcs_write_seq(dsi, 0xbe, 0x8a);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x66);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x08);
+	dsi_dcs_write_seq(dsi, 0xb5, 0x32);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x07);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x01);
+	dsi_dcs_write_seq(dsi, 0xc1,
+			  0x30, 0x0f, 0x04, 0xc9, 0x0f, 0x81, 0xee, 0xc6, 0x3f,
+			  0xfb, 0xb3, 0x6a, 0x3f, 0xf6, 0xd1, 0x42, 0x80, 0x00,
+			  0xf7, 0x33, 0xb1, 0x00, 0x18, 0x00, 0x00, 0x8b, 0x23,
+			  0x33, 0xc0, 0x0f, 0xb9, 0x0f, 0xdd, 0x8d, 0x00, 0x00,
+			  0x00, 0x0d, 0x08, 0x00, 0x17, 0x23, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc2,
+			  0x38, 0x0f, 0x0b, 0x64, 0x02, 0x11, 0xf6, 0x4c, 0x3f,
+			  0xfa, 0xe2, 0x14, 0xff, 0xfe, 0x41, 0xa8, 0x00, 0x00,
+			  0x5e, 0x26, 0x90, 0x00, 0x00, 0x24, 0x00, 0x17, 0x90,
+			  0x33, 0xc0, 0x09, 0xb4, 0x0f, 0x94, 0xe9, 0x00, 0x00,
+			  0x90, 0x0d, 0x3c, 0x90, 0x17, 0x57, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc3,
+			  0x3c, 0x00, 0x04, 0xc9, 0x0f, 0x81, 0x11, 0x3a, 0x3f,
+			  0xf9, 0x58, 0x7c, 0x00, 0x04, 0xf1, 0x78, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x90, 0x18, 0x3c, 0x90, 0x8b, 0x5f,
+			  0x33, 0x60, 0x00, 0x00, 0x0c, 0xdd, 0x73, 0x00, 0x00,
+			  0x04, 0x20, 0x08, 0x04, 0x2a, 0x23, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc4,
+			  0x3c, 0x00, 0x0b, 0x64, 0x02, 0x11, 0x09, 0xb4, 0x3f,
+			  0xf6, 0xca, 0x24, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x80, 0x00, 0xcf, 0x90, 0x17, 0x3b,
+			  0x33, 0xc0, 0x00, 0x00, 0x0c, 0x94, 0x17, 0x00, 0x00,
+			  0x94, 0x20, 0x3c, 0x94, 0x2a, 0x57, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc5,
+			  0x26, 0x00, 0x04, 0xc9, 0x0f, 0x81, 0x11, 0x3a, 0x00,
+			  0x00, 0x00, 0x00, 0x3f, 0xef, 0x14, 0x34, 0x80, 0x00,
+			  0x00, 0x00, 0x00, 0x03, 0xac, 0x00, 0x04, 0x1f, 0x23,
+			  0x33, 0xc0, 0x00, 0x00, 0x03, 0x23, 0x8d, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc6,
+			  0x2e, 0x00, 0x0b, 0x64, 0x02, 0x11, 0x09, 0xb4, 0x00,
+			  0x03, 0x11, 0xf4, 0xff, 0xfd, 0x62, 0x7c, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x04, 0x20, 0x24, 0x04, 0x37, 0x90,
+			  0x33, 0xc0, 0x00, 0x00, 0x03, 0x6c, 0xe9, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc7,
+			  0x2a, 0x0f, 0x04, 0xc9, 0x0f, 0x81, 0xee, 0xc6, 0x00,
+			  0x02, 0x5a, 0xee, 0x00, 0x0c, 0xae, 0x86, 0x7f, 0xfd,
+			  0xf9, 0xf3, 0x65, 0x93, 0xac, 0x3c, 0x94, 0x1f, 0x5f,
+			  0x33, 0x6f, 0xf0, 0x47, 0x00, 0x23, 0x73, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc8,
+			  0x2a, 0x0f, 0x0b, 0x64, 0x02, 0x11, 0xf6, 0x4c, 0x00,
+			  0x07, 0x29, 0xe4, 0xc0, 0x00, 0xdf, 0x2c, 0x7f, 0xff,
+			  0x43, 0xb2, 0xe0, 0x84, 0x20, 0xcf, 0x94, 0x37, 0x3b,
+			  0x33, 0xcf, 0xf6, 0x4c, 0x00, 0x6c, 0x17, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc9,
+			  0x27, 0x00, 0x03, 0xc1, 0x04, 0x41, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x3f, 0xfe, 0xf8, 0x42, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x63, 0x24, 0x00, 0x84, 0x43,
+			  0x33, 0x90, 0x00, 0x00, 0x03, 0x1f, 0xdf, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xca,
+			  0x21, 0x00, 0x03, 0xc1, 0x04, 0x00, 0x00, 0x00, 0x3f,
+			  0xff, 0x0f, 0xc0, 0x3f, 0xff, 0x08, 0x00, 0x00, 0x00,
+			  0x0f, 0x04, 0x00, 0x00, 0x42, 0x24, 0x00, 0x62, 0x43,
+			  0x33, 0x90, 0x03, 0xe0, 0x0f, 0xe1, 0xe0, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xcb,
+			  0x2d, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x3f,
+			  0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x42, 0x44, 0x00, 0x62, 0x64,
+			  0x33, 0x60, 0x00, 0x00, 0x0c, 0xe0, 0x20, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xcc,
+			  0x2b, 0x00, 0x04, 0x00, 0x04, 0x41, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
+			  0xee, 0xfc, 0x00, 0x00, 0x63, 0x44, 0x00, 0x84, 0x64,
+			  0x33, 0x6f, 0xfb, 0xe0, 0x00, 0x20, 0x21, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xb4, 0xc0);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x01);
+	dsi_dcs_write_seq(dsi, 0xb4, 0x00, 0x80, 0x80);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x01);
+	dsi_dcs_write_seq(dsi, 0xd2, 0x00, 0x00, 0x11);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x06);
+	dsi_dcs_write_seq(dsi, 0xd2, 0x05);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x0f);
+	dsi_dcs_write_seq(dsi, 0xd2, 0x00);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x09);
+	dsi_dcs_write_seq(dsi, 0xd2, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xce, 0x00);
+	dsi_dcs_write_seq(dsi, 0xff, 0xaa, 0x55, 0xa5, 0x80);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x61);
+	dsi_dcs_write_seq(dsi, 0xf3, 0x80);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	dsi_dcs_write_seq(dsi, 0xc0, 0x46);
+	dsi_dcs_write_seq(dsi, 0xbe, 0x0e, 0x0b);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x05);
+	dsi_dcs_write_seq(dsi, 0xbe, 0x88);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x08);
+	dsi_dcs_write_seq(dsi, 0xb5, 0x32);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x0b);
+	dsi_dcs_write_seq(dsi, 0xb5, 0x33, 0x23, 0x2b);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	dsi_dcs_write_seq(dsi, 0xd1, 0x07, 0x00, 0x04);
+	dsi_dcs_write_seq(dsi, 0x3b, 0x00, 0x10, 0x00, 0x30);
+	dsi_dcs_write_seq(dsi, 0xd9, 0xc8);
+	dsi_dcs_write_seq(dsi, 0x90, 0x01);
+	dsi_dcs_write_seq(dsi, 0x91,
+			  0xab, 0x28, 0x00, 0x0c, 0xc2, 0x00, 0x03, 0x1c, 0x01,
+			  0x7e, 0x00, 0x0f, 0x08, 0xbb, 0x04, 0x3d, 0x10, 0xf0);
+	dsi_dcs_write_seq(dsi, 0x03, 0x01);
+	dsi_dcs_write_seq(dsi, 0x51, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x20);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_column_address(dsi, 0x0000, 0x0437);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set column address: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_page_address(dsi, 0x0000, 0x095f);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set page address: %d\n", ret);
+		return ret;
+	}
+
+	dsi_dcs_write_seq(dsi, 0x2f, 0x02);
+	dsi_dcs_write_seq(dsi, 0xff, 0xaa, 0x55, 0xa5, 0x81);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x0f);
+	dsi_dcs_write_seq(dsi, 0xfd, 0x01, 0x5a);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x04);
+	dsi_dcs_write_seq(dsi, 0xfd, 0x5f);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x1a);
+	dsi_dcs_write_seq(dsi, 0xfd, 0x5f);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_MEMORY_START);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	dsi_dcs_write_seq(dsi, 0xca, 0x12, 0x00, 0x92, 0x02);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x02);
+	dsi_dcs_write_seq(dsi, 0xec, 0x80, 0x10);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	dsi_dcs_write_seq(dsi, 0xcd, 0x05, 0x31);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x10);
+	dsi_dcs_write_seq(dsi, 0xd8, 0x0c);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x05);
+	dsi_dcs_write_seq(dsi, 0xb3, 0x86, 0x80);
+	dsi_dcs_write_seq(dsi, 0xb5, 0x85, 0x81);
+	dsi_dcs_write_seq(dsi, 0xb7, 0x85, 0x00, 0x00, 0x81);
+	dsi_dcs_write_seq(dsi, 0xb8, 0x05, 0x00, 0x00, 0x81);
+	dsi_dcs_write_seq(dsi, 0xec, 0x0d, 0x11);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x02);
+	dsi_dcs_write_seq(dsi, 0xec,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x00);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x08);
+	dsi_dcs_write_seq(dsi, 0xb5, 0x32);
+	dsi_dcs_write_seq(dsi, 0x6f, 0x0b);
+	dsi_dcs_write_seq(dsi, 0xb5, 0x33, 0x23, 0x2b);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	dsi_dcs_write_seq(dsi, 0xce, 0x00);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x55, 0xaa, 0x52, 0x08, 0x01);
+	dsi_dcs_write_seq(dsi, 0xc3, 0x94, 0x01, 0x97, 0xd0, 0x22, 0x02, 0x00);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(50);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(16000, 17000);
+
+	return 0;
+}
+
+static int k9d_36_02_0a_dsc_off(struct k9d_36_02_0a_dsc *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(80);
+
+	return 0;
+}
+
+static int k9d_36_02_0a_dsc_prepare(struct drm_panel *panel)
+{
+	struct k9d_36_02_0a_dsc *ctx = to_k9d_36_02_0a_dsc(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	k9d_36_02_0a_dsc_reset(ctx);
+
+	ret = k9d_36_02_0a_dsc_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int k9d_36_02_0a_dsc_unprepare(struct drm_panel *panel)
+{
+	struct k9d_36_02_0a_dsc *ctx = to_k9d_36_02_0a_dsc(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = k9d_36_02_0a_dsc_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode k9d_36_02_0a_dsc_mode = {
+	.clock = (1080 + 16 + 8 + 8) * (2400 + 1212 + 4 + 8) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 16,
+	.hsync_end = 1080 + 16 + 8,
+	.htotal = 1080 + 16 + 8 + 8,
+	.vdisplay = 2400,
+	.vsync_start = 2400 + 1212,
+	.vsync_end = 2400 + 1212 + 4,
+	.vtotal = 2400 + 1212 + 4 + 8,
+	.width_mm = 683,
+	.height_mm = 1517,
+};
+
+static int k9d_36_02_0a_dsc_get_modes(struct drm_panel *panel,
+				      struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &k9d_36_02_0a_dsc_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs k9d_36_02_0a_dsc_panel_funcs = {
+	.prepare = k9d_36_02_0a_dsc_prepare,
+	.unprepare = k9d_36_02_0a_dsc_unprepare,
+	.get_modes = k9d_36_02_0a_dsc_get_modes,
+};
+
+static int k9d_36_02_0a_dsc_bl_update_status(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness = backlight_get_brightness(bl);
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return 0;
+}
+
+// TODO: Check if /sys/class/backlight/.../actual_brightness actually returns
+// correct values. If not, remove this function.
+static int k9d_36_02_0a_dsc_bl_get_brightness(struct backlight_device *bl)
+{
+	struct mipi_dsi_device *dsi = bl_get_data(bl);
+	u16 brightness;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	ret = mipi_dsi_dcs_get_display_brightness(dsi, &brightness);
+	if (ret < 0)
+		return ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	return brightness;
+}
+
+static const struct backlight_ops k9d_36_02_0a_dsc_bl_ops = {
+	.update_status = k9d_36_02_0a_dsc_bl_update_status,
+	.get_brightness = k9d_36_02_0a_dsc_bl_get_brightness,
+};
+
+static struct backlight_device *
+k9d_36_02_0a_dsc_create_backlight(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct backlight_properties props = {
+		.type = BACKLIGHT_RAW,
+		.brightness = 4095,
+		.max_brightness = 4095,
+	};
+
+	return devm_backlight_device_register(dev, dev_name(dev), dev, dsi,
+					      &k9d_36_02_0a_dsc_bl_ops, &props);
+}
+
+static int k9d_36_02_0a_dsc_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct k9d_36_02_0a_dsc *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_LPM;
+
+	drm_panel_init(&ctx->panel, dev, &k9d_36_02_0a_dsc_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ctx->panel.backlight = k9d_36_02_0a_dsc_create_backlight(dsi);
+	if (IS_ERR(ctx->panel.backlight))
+		return dev_err_probe(dev, PTR_ERR(ctx->panel.backlight),
+				     "Failed to create backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int k9d_36_02_0a_dsc_remove(struct mipi_dsi_device *dsi)
+{
+	struct k9d_36_02_0a_dsc *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id k9d_36_02_0a_dsc_of_match[] = {
+	{ .compatible = "mdss,k9d-36-02-0a-dsc" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, k9d_36_02_0a_dsc_of_match);
+
+static struct mipi_dsi_driver k9d_36_02_0a_dsc_driver = {
+	.probe = k9d_36_02_0a_dsc_probe,
+	.remove = k9d_36_02_0a_dsc_remove,
+	.driver = {
+		.name = "panel-k9d-36-02-0a-dsc",
+		.of_match_table = k9d_36_02_0a_dsc_of_match,
+	},
+};
+module_mipi_dsi_driver(k9d_36_02_0a_dsc_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for xiaomi 36 02 0a cmd mode dsc dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-nt36675-tianma.c b/drivers/gpu/drm/panel/panel-nt36675-tianma.c
new file mode 100644
index 0000000000..fcbc8a2061
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-nt36675-tianma.c
@@ -0,0 +1,318 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2022 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+
+#include <video/mipi_display.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct nt36675_tianma {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline struct nt36675_tianma *to_nt36675_tianma(struct drm_panel *panel)
+{
+	return container_of(panel, struct nt36675_tianma, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void nt36675_tianma_reset(struct nt36675_tianma *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+}
+
+static int nt36675_tianma_on(struct nt36675_tianma *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0xff, 0x10);
+	dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	dsi_dcs_write_seq(dsi, 0x3b, 0x03, 0x1e, 0x0a, 0x04, 0x04);
+	dsi_dcs_write_seq(dsi, 0xb0, 0x00);
+
+	ret = mipi_dsi_dcs_set_tear_on(dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set tear on: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_set_display_brightness(dsi, 0x00b8);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display brightness: %d\n", ret);
+		return ret;
+	}
+
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_CONTROL_DISPLAY, 0x24);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_WRITE_POWER_SAVE, 0x00);
+	dsi_dcs_write_seq(dsi, 0xff, 0x27);
+	dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	dsi_dcs_write_seq(dsi, 0x07, 0x01);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_VSYNC_TIMING, 0x25);
+	dsi_dcs_write_seq(dsi, 0xff, 0x23);
+	dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	dsi_dcs_write_seq(dsi, 0x0a, 0x20);
+	dsi_dcs_write_seq(dsi, 0x0b, 0x20);
+	dsi_dcs_write_seq(dsi, 0x0c, 0x20);
+	dsi_dcs_write_seq(dsi, 0x0d, 0x2a);
+	dsi_dcs_write_seq(dsi, 0x10, 0x50);
+	dsi_dcs_write_seq(dsi, 0x11, 0x01);
+	dsi_dcs_write_seq(dsi, 0x12, 0x95);
+	dsi_dcs_write_seq(dsi, 0x15, 0x68);
+	dsi_dcs_write_seq(dsi, 0x16, 0x0b);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_ROWS, 0xff);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_PARTIAL_COLUMNS, 0xff);
+	dsi_dcs_write_seq(dsi, 0x32, 0xff);
+	dsi_dcs_write_seq(dsi, 0x33, 0xfe);
+	dsi_dcs_write_seq(dsi, 0x34, 0xfd);
+	dsi_dcs_write_seq(dsi, 0x35, 0xfa);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_ADDRESS_MODE, 0xf6);
+	dsi_dcs_write_seq(dsi, 0x37, 0xf2);
+	dsi_dcs_write_seq(dsi, 0x38, 0xf0);
+	dsi_dcs_write_seq(dsi, 0x39, 0xee);
+
+	ret = mipi_dsi_dcs_set_pixel_format(dsi, 0xec);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set pixel format: %d\n", ret);
+		return ret;
+	}
+
+	dsi_dcs_write_seq(dsi, 0x3b, 0xea);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_3D_CONTROL, 0xe8);
+	dsi_dcs_write_seq(dsi, 0x3f, 0xe7);
+	dsi_dcs_write_seq(dsi, MIPI_DCS_SET_VSYNC_TIMING, 0xe6);
+	dsi_dcs_write_seq(dsi, 0x41, 0xe5);
+	dsi_dcs_write_seq(dsi, 0xa0, 0x11);
+	dsi_dcs_write_seq(dsi, 0xff, 0x10);
+	dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(80);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+	usleep_range(5000, 6000);
+
+	dsi_dcs_write_seq(dsi, 0xff, 0x27);
+	dsi_dcs_write_seq(dsi, 0xfb, 0x01);
+	dsi_dcs_write_seq(dsi, 0x3f, 0x01);
+	dsi_dcs_write_seq(dsi, 0x43, 0x08);
+	dsi_dcs_write_seq(dsi, 0xff, 0x10);
+
+	return 0;
+}
+
+static int nt36675_tianma_off(struct nt36675_tianma *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	dsi_dcs_write_seq(dsi, 0xff, 0x10);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+	usleep_range(10000, 11000);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(140);
+
+	return 0;
+}
+
+static int nt36675_tianma_prepare(struct drm_panel *panel)
+{
+	struct nt36675_tianma *ctx = to_nt36675_tianma(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	nt36675_tianma_reset(ctx);
+
+	ret = nt36675_tianma_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int nt36675_tianma_unprepare(struct drm_panel *panel)
+{
+	struct nt36675_tianma *ctx = to_nt36675_tianma(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = nt36675_tianma_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode nt36675_tianma_mode = {
+	.clock = (1080 + 20 + 4 + 22) * (2400 + 10 + 2 + 30) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 20,
+	.hsync_end = 1080 + 20 + 4,
+	.htotal = 1080 + 20 + 4 + 22,
+	.vdisplay = 2400,
+	.vsync_start = 2400 + 10,
+	.vsync_end = 2400 + 10 + 2,
+	.vtotal = 2400 + 10 + 2 + 30,
+	.width_mm = 69,
+	.height_mm = 154,
+};
+
+static int nt36675_tianma_get_modes(struct drm_panel *panel,
+				    struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &nt36675_tianma_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs nt36675_tianma_panel_funcs = {
+	.prepare = nt36675_tianma_prepare,
+	.unprepare = nt36675_tianma_unprepare,
+	.get_modes = nt36675_tianma_get_modes,
+};
+
+static int nt36675_tianma_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct nt36675_tianma *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	drm_panel_init(&ctx->panel, dev, &nt36675_tianma_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int nt36675_tianma_remove(struct mipi_dsi_device *dsi)
+{
+	struct nt36675_tianma *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id nt36675_tianma_of_match[] = {
+	{ .compatible = "mdss,nt36675-tianma" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, nt36675_tianma_of_match);
+
+static struct mipi_dsi_driver nt36675_tianma_driver = {
+	.probe = nt36675_tianma_probe,
+	.remove = nt36675_tianma_remove,
+	.driver = {
+		.name = "panel-nt36675-tianma",
+		.of_match_table = nt36675_tianma_of_match,
+	},
+};
+module_mipi_dsi_driver(nt36675_tianma_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for nt36675 video mode dsi tianma panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-s6d6ft0-tianma-fhd.c b/drivers/gpu/drm/panel/panel-s6d6ft0-tianma-fhd.c
new file mode 100644
index 0000000000..7f75ddcd03
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-s6d6ft0-tianma-fhd.c
@@ -0,0 +1,276 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2022 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/of.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+struct s6d6ft0_tianma_fhd {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct gpio_desc *reset_gpio;
+	bool prepared;
+};
+
+static inline
+struct s6d6ft0_tianma_fhd *to_s6d6ft0_tianma_fhd(struct drm_panel *panel)
+{
+	return container_of(panel, struct s6d6ft0_tianma_fhd, panel);
+}
+
+#define dsi_dcs_write_seq(dsi, seq...) do {				\
+		static const u8 d[] = { seq };				\
+		int ret;						\
+		ret = mipi_dsi_dcs_write_buffer(dsi, d, ARRAY_SIZE(d));	\
+		if (ret < 0)						\
+			return ret;					\
+	} while (0)
+
+static void s6d6ft0_tianma_fhd_reset(struct s6d6ft0_tianma_fhd *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(40);
+}
+
+static int s6d6ft0_tianma_fhd_on(struct s6d6ft0_tianma_fhd *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_dcs_write_seq(dsi, 0x9f, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to exit sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(120);
+
+	dsi_dcs_write_seq(dsi, 0x55);
+	dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0x73, 0x94);
+	dsi_dcs_write_seq(dsi, 0xea,
+			  0x00, 0x73, 0x11, 0x1b, 0x23, 0x2a, 0x40, 0x59, 0x70,
+			  0x6e, 0xa1, 0x86, 0x92, 0x9f, 0xab, 0xb8, 0x4d, 0x59,
+			  0x65, 0x7f, 0x00, 0x73, 0x11, 0x1b, 0x23, 0x2a, 0x40,
+			  0x59, 0x70, 0x6e, 0xa1, 0x86, 0x92, 0x9f, 0xab, 0xb8,
+			  0x4d, 0x59, 0x65, 0x7f, 0x00, 0x73, 0x11, 0x1b, 0x23,
+			  0x2a, 0x40, 0x59, 0x70, 0x6e, 0xa1, 0x86, 0x92, 0x9f,
+			  0xab, 0xb8, 0x4d, 0x59, 0x65, 0x7f);
+	dsi_dcs_write_seq(dsi, 0xeb,
+			  0x00, 0x73, 0x11, 0x1b, 0x23, 0x2a, 0x40, 0x59, 0x70,
+			  0x6e, 0xa1, 0x86, 0x92, 0x9f, 0xab, 0xb8, 0x4d, 0x59,
+			  0x65, 0x7f, 0x00, 0x73, 0x11, 0x1b, 0x23, 0x2a, 0x40,
+			  0x59, 0x70, 0x6e, 0xa1, 0x86, 0x92, 0x9f, 0xab, 0xb8,
+			  0x4d, 0x59, 0x65, 0x7f, 0x00, 0x73, 0x11, 0x1b, 0x23,
+			  0x2a, 0x40, 0x59, 0x70, 0x6e, 0xa1, 0x86, 0x92, 0x9f,
+			  0xab, 0xb8, 0x4d, 0x59, 0x65, 0x7f);
+	dsi_dcs_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_set_display_on(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display on: %d\n", ret);
+		return ret;
+	}
+
+	dsi_dcs_write_seq(dsi, 0x9f, 0x5a, 0x5a);
+
+	return 0;
+}
+
+static int s6d6ft0_tianma_fhd_off(struct s6d6ft0_tianma_fhd *ctx)
+{
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	struct device *dev = &dsi->dev;
+	int ret;
+
+	dsi_dcs_write_seq(dsi, 0x9f, 0xa5, 0xa5);
+
+	ret = mipi_dsi_dcs_set_display_off(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to set display off: %d\n", ret);
+		return ret;
+	}
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to enter sleep mode: %d\n", ret);
+		return ret;
+	}
+	msleep(80);
+
+	dsi_dcs_write_seq(dsi, 0xf0, 0x5a, 0x5a);
+	dsi_dcs_write_seq(dsi, 0x73, 0x90);
+	dsi_dcs_write_seq(dsi, 0xf0, 0xa5, 0xa5);
+	dsi_dcs_write_seq(dsi, 0x24);
+	dsi_dcs_write_seq(dsi, 0x9f, 0x5a, 0x5a);
+
+	return 0;
+}
+
+static int s6d6ft0_tianma_fhd_prepare(struct drm_panel *panel)
+{
+	struct s6d6ft0_tianma_fhd *ctx = to_s6d6ft0_tianma_fhd(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (ctx->prepared)
+		return 0;
+
+	s6d6ft0_tianma_fhd_reset(ctx);
+
+	ret = s6d6ft0_tianma_fhd_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		return ret;
+	}
+
+	ctx->prepared = true;
+	return 0;
+}
+
+static int s6d6ft0_tianma_fhd_unprepare(struct drm_panel *panel)
+{
+	struct s6d6ft0_tianma_fhd *ctx = to_s6d6ft0_tianma_fhd(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	if (!ctx->prepared)
+		return 0;
+
+	ret = s6d6ft0_tianma_fhd_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+	ctx->prepared = false;
+	return 0;
+}
+
+static const struct drm_display_mode s6d6ft0_tianma_fhd_mode = {
+	.clock = (1080 + 229 + 4 + 4) * (2160 + 8 + 2 + 6) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 229,
+	.hsync_end = 1080 + 229 + 4,
+	.htotal = 1080 + 229 + 4 + 4,
+	.vdisplay = 2160,
+	.vsync_start = 2160 + 8,
+	.vsync_end = 2160 + 8 + 2,
+	.vtotal = 2160 + 8 + 2 + 6,
+	.width_mm = 0,
+	.height_mm = 0,
+};
+
+static int s6d6ft0_tianma_fhd_get_modes(struct drm_panel *panel,
+					struct drm_connector *connector)
+{
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &s6d6ft0_tianma_fhd_mode);
+	if (!mode)
+		return -ENOMEM;
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs s6d6ft0_tianma_fhd_panel_funcs = {
+	.prepare = s6d6ft0_tianma_fhd_prepare,
+	.unprepare = s6d6ft0_tianma_fhd_unprepare,
+	.get_modes = s6d6ft0_tianma_fhd_get_modes,
+};
+
+static int s6d6ft0_tianma_fhd_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct s6d6ft0_tianma_fhd *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST;
+
+	drm_panel_init(&ctx->panel, dev, &s6d6ft0_tianma_fhd_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		dev_err(dev, "Failed to attach to DSI host: %d\n", ret);
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int s6d6ft0_tianma_fhd_remove(struct mipi_dsi_device *dsi)
+{
+	struct s6d6ft0_tianma_fhd *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id s6d6ft0_tianma_fhd_of_match[] = {
+	{ .compatible = "mdss,s6d6ft0-tianma-fhd" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, s6d6ft0_tianma_fhd_of_match);
+
+static struct mipi_dsi_driver s6d6ft0_tianma_fhd_driver = {
+	.probe = s6d6ft0_tianma_fhd_probe,
+	.remove = s6d6ft0_tianma_fhd_remove,
+	.driver = {
+		.name = "panel-s6d6ft0-tianma-fhd",
+		.of_match_table = s6d6ft0_tianma_fhd_of_match,
+	},
+};
+module_mipi_dsi_driver(s6d6ft0_tianma_fhd_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for s6d6ff0 tianma fhd video mode dsi panel");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-simple-nt36675-tianma.c b/drivers/gpu/drm/panel/panel-simple-nt36675-tianma.c
new file mode 100644
index 0000000000..02c51bc60e
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-simple-nt36675-tianma.c
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2013, The Linux Foundation. All rights reserved.
+
+static const struct drm_display_mode nt36675_tianma_mode = {
+	.clock = (1080 + 20 + 4 + 22) * (2400 + 10 + 2 + 30) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 20,
+	.hsync_end = 1080 + 20 + 4,
+	.htotal = 1080 + 20 + 4 + 22,
+	.vdisplay = 2400,
+	.vsync_start = 2400 + 10,
+	.vsync_end = 2400 + 10 + 2,
+	.vtotal = 2400 + 10 + 2 + 30,
+	.width_mm = 69,
+	.height_mm = 154,
+};
+
+static const struct panel_desc_dsi nt36675_tianma = {
+	.desc = {
+		.modes = &nt36675_tianma_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 69,
+			.height = 154,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
diff --git a/drivers/gpu/drm/panel/panel-simple-s6d6ft0-tianma-fhd.c b/drivers/gpu/drm/panel/panel-simple-s6d6ft0-tianma-fhd.c
new file mode 100644
index 0000000000..9bd5edb848
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-simple-s6d6ft0-tianma-fhd.c
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2013, The Linux Foundation. All rights reserved.
+
+static const struct drm_display_mode s6d6ft0_tianma_fhd_mode = {
+	.clock = (1080 + 229 + 4 + 4) * (2160 + 8 + 2 + 6) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 229,
+	.hsync_end = 1080 + 229 + 4,
+	.htotal = 1080 + 229 + 4 + 4,
+	.vdisplay = 2160,
+	.vsync_start = 2160 + 8,
+	.vsync_end = 2160 + 8 + 2,
+	.vtotal = 2160 + 8 + 2 + 6,
+	.width_mm = 0,
+	.height_mm = 0,
+};
+
+static const struct panel_desc_dsi s6d6ft0_tianma_fhd = {
+	.desc = {
+		.modes = &s6d6ft0_tianma_fhd_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 0,
+			.height = 0,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index a34f4198a5..27ee76d462 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -4308,6 +4308,71 @@ static const struct panel_desc_dsi osd101t2045_53ts = {
 	.lanes = 4,
 };
 
+#include "panel-simple-s6d6ft0-tianma-fhd.c"
+#include "panel-simple-nt36675-tianma.c"
+
+static const struct drm_display_mode sony_kirin_nt36672a_truly_mode = {
+	.clock = (1080 + 25 + 12 + 120) * (2520 + 12 + 4 + 10) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 25,
+	.hsync_end = 1080 + 25 + 12,
+	.htotal = 1080 + 25 + 12 + 120,
+	.vdisplay = 2520,
+	.vsync_start = 2520 + 12,
+	.vsync_end = 2520 + 12 + 4,
+	.vtotal = 2520 + 12 + 4 + 10,
+	.width_mm = 60,
+	.height_mm = 139,
+};
+
+static const struct panel_desc_dsi sony_kirin_nt36672a_truly = {
+	.desc = {
+		.modes = &sony_kirin_nt36672a_truly_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 60,
+			.height = 139,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+		 MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
+static const struct drm_display_mode sony_mermaid_nt36672a_tianma_mode = {
+	.clock = (1080 + 102 + 20 + 40) * (2520 + 10 + 2 + 8) * 60 / 1000,
+	.hdisplay = 1080,
+	.hsync_start = 1080 + 102,
+	.hsync_end = 1080 + 102 + 20,
+	.htotal = 1080 + 102 + 20 + 40,
+	.vdisplay = 2520,
+	.vsync_start = 2520 + 10,
+	.vsync_end = 2520 + 10 + 2,
+	.vtotal = 2520 + 10 + 2 + 8,
+	.width_mm = 65,
+	.height_mm = 151,
+};
+
+static const struct panel_desc_dsi sony_mermaid_nt36672a_tianma = {
+	.desc = {
+		.modes = &sony_mermaid_nt36672a_tianma_mode,
+		.num_modes = 1,
+		.bpc = 8,
+		.size = {
+			.width = 65,
+			.height = 151,
+		},
+		.connector_type = DRM_MODE_CONNECTOR_DSI,
+	},
+	.flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+		 MIPI_DSI_CLOCK_NON_CONTINUOUS,
+	.format = MIPI_DSI_FMT_RGB888,
+	.lanes = 4,
+};
+
 static const struct of_device_id dsi_of_match[] = {
 	{
 		.compatible = "auo,b080uan01",
@@ -4330,6 +4395,18 @@ static const struct of_device_id dsi_of_match[] = {
 	}, {
 		.compatible = "osddisplays,osd101t2045-53ts",
 		.data = &osd101t2045_53ts
+        }, {
+                .compatible = "meizu,s6d6ft0-tianma-fhd",
+                .data = &s6d6ft0_tianma_fhd,
+	}, {
+                .compatible = "xiaomi,nt36675-tianma",
+                .data = &nt36675_tianma,
+        }, {
+		.compatible = "sony,kirin-nt36672a-truly",
+		.data = &sony_kirin_nt36672a_truly
+	}, {
+		.compatible = "sony,mermaid-nt36672a-tianma",
+		.data = &sony_mermaid_nt36672a_tianma
 	}, {
 		/* sentinel */
 	}
